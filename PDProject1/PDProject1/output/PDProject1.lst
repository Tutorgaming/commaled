FILE: .\boot.asm                        (0001) ;  Generated by PSoC Designer 5.4.3191
                                        (0002) ;
                                        (0003) ;@Id: boot.tpl#902 @
                                        (0004) ;=============================================================================
                                        (0005) ;  FILENAME:   boot.asm
                                        (0006) ;  Version:    4.09
                                        (0007) ;
                                        (0008) ;  DESCRIPTION:
                                        (0009) ;  M8C Boot Code for CY7C63300 microcontroller family.
                                        (0010) ;  This file also contains the Interrupt Service Routines for enCoRe II GPIO
                                        (0011) ;  interrupts: INT0, INT1, INT2, as well as the GPIO Port interrupts for
                                        (0012) ;  port 0, port 1, port 2, and port 3.
                                        (0013) ;
                                        (0014) ;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0015) ;
                                        (0016) ; NOTES:
                                        (0017) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
                                        (0018) ; the project's root directory to create BOOT.ASM. Any changes made to 
                                        (0019) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                        (0020) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                        (0021) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
                                        (0022) ; are not accidentally modified.
                                        (0023) ;
                                        (0024) ;=============================================================================
                                        (0025) 
                                        (0026) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
                                        (0027) include "m8c.inc"			;Part specific file
                                        (0028) include "m8ssc.inc"			;Part specific file
                                        (0029) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
                                        (0030) 
                                        (0031) ;-----------------------------------------------------------------------------
                                        (0032) ; Optimization flags
                                        (0033) ;-----------------------------------------------------------------------------
                                        (0034) C_LANGUAGE_SUPPORT: equ 1   ;Set to 0 to optimize for ASM only
                                        (0035) 
                                        (0036) ; For historical reasons, by default the boot code uses an lcall instruction
                                        (0037) ; to invoke the user's _main code. If _main executes a return instruction,
                                        (0038) ; boot provides an infinite loop. By changing the following equate from zero
                                        (0039) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                        (0040) ; bytes on the stack which are otherwise required for the return address. If
                                        (0041) ; this option is enabled, _main must not return. (Beginning with the 4.2
                                        (0042) ; release, the C compiler automatically places an infinite loop at the end
                                        (0043) ; of main, rather than a return instruction.)
                                        (0044) ;
                                        (0045) ENABLE_LJMP_TO_MAIN:             equ 0
                                        (0046) 
                                        (0047) ;-----------------------------------------------------------------------------
                                        (0048) ; Export Declarations
                                        (0049) ;-----------------------------------------------------------------------------
                                        (0050) 
                                        (0051) export __Start
                                        (0052) IF	(TOOLCHAIN & HITECH)
                                        (0053) ELSE
                                        (0054) export __bss_start
                                        (0055) 
                                        (0056) export __lit_start
                                        (0057) export __idata_start
                                        (0058) export __data_start
                                        (0059) export __func_lit_start
                                        (0060) export __text_start
                                        (0061) export __usermodules_start
                                        (0062) export __psoc_config_start
                                        (0063) ENDIF
                                        (0064) ;-----------------------------------------------------------------------------
                                        (0065) ; Interrupt Vector Table
                                        (0066) ;-----------------------------------------------------------------------------
                                        (0067) ;
                                        (0068) ; Interrupt vector table entries are 4 bytes long and contain the code that
                                        (0069) ; services the interrupt (or causes it to be serviced).
                                        (0070) ;
                                        (0071) ;-----------------------------------------------------------------------------
                                        (0072) 
                                        (0073)     AREA    TOP(ROM,ABS,CON)
                                        (0074) 
                                        (0075)     org 0                   ;Reset Interrupt Vector
                                        (0076) IF	(TOOLCHAIN & HITECH)
                                        (0077) ;   jmp   __Start                  ;C compiler fills in this vector
                                        (0078) ELSE
0000: 80 67    JMP   0x0068             (0079)     jmp   __Start                  ;First instruction executed following a Reset
                                        (0080) ENDIF
                                        (0081)     ;@PSoC_BOOT_ISR_UserCode_START@
                                        (0082)     ;---------------------------------------------------
                                        (0083)     ; Insert your custom code below this banner
                                        (0084)     ;---------------------------------------------------
                                        (0085) 
                                        (0086)     org 04h                 ;Low Voltage Detect (LVD) Interrupt Vector
0004: 30       HALT                     (0087)     halt                    ;Stop execution if power falls too low
                                        (0088) 
                                        (0089)     org 08h                 ;INT0 Interrupt Vector
0008: 7D 09 20 LJMP  __UserModules_end  (0090)     ljmp    INT0_ISR
000B: 7E       RETI                     (0091)     reti
                                        (0092) 
                                        (0093)     org 0Ch                 ;SPI TX Empty Interrupt Vector
                                        (0094)     // call	void_handler
000C: 7E       RETI                     (0095)     reti
                                        (0096) 
                                        (0097)     org 10h                 ;SPI RX Full Interrupt Vector
                                        (0098)     // call	void_handler
0010: 7E       RETI                     (0099)     reti
                                        (0100) 
                                        (0101)     org 14h                 ;GPIO Port 0 Interrupt Vector
0014: 7D 09 23 LJMP  0x0923             (0102)     ljmp    PORT0_ISR
0017: 7E       RETI                     (0103)     reti
                                        (0104)     
                                        (0105)     org 18h                 ;GPIO Port 1 Interrupt Vector
0018: 7D 09 24 LJMP  0x0924             (0106)     ljmp    PORT1_ISR
001B: 7E       RETI                     (0107)     reti
                                        (0108)     
                                        (0109)     org 1Ch                 ;INT1 Interrupt Vector
001C: 7D 09 21 LJMP  0x0921             (0110)     ljmp    INT1_ISR
001F: 7E       RETI                     (0111)     reti
                                        (0112)     
                                        (0113)     org 20h                 ;USB Endpoint 0 Interrupt Vector
0020: 7D 05 18 LJMP  _USB_EP0_ISR       (0114)     ljmp	_USB_EP0_ISR
0023: 7E       RETI                     (0115)     reti
                                        (0116) 
                                        (0117)     org 24h                 ;USB Endpoint 1 Interrupt Vector
0024: 7D 09 C7 LJMP  _USB_EP1_ISR       (0118)     ljmp	_USB_EP1_ISR
0027: 7E       RETI                     (0119)     reti
                                        (0120) 
                                        (0121)     org 28h                 ;USB Endpoint 2 Interrupt Vector
0028: 7D 09 D2 LJMP  _USB_EP2_ISR       (0122)     ljmp	_USB_EP2_ISR
002B: 7E       RETI                     (0123)     reti
                                        (0124) 
                                        (0125)     org 2Ch                 ;USB Bus Reset Interrupt Vector
002C: 7D 09 DD LJMP  _USB_RESET_ISR     (0126)     ljmp	_USB_RESET_ISR
002F: 7E       RETI                     (0127)     reti
                                        (0128) 
                                        (0129)     org 30h                 ;USB Bus Activity Interrupt Vector
0030: 7D 09 E7 LJMP  _USB_ACT_ISR       (0130)     ljmp	_USB_ACT_ISR
0033: 7E       RETI                     (0131)     reti
                                        (0132) 
                                        (0133)     org 34h                 ;One Millisecond Interval Timer Interrupt Vector
                                        (0134)     // call	void_handler
0034: 7E       RETI                     (0135)     reti
                                        (0136) 
                                        (0137)     org 38h                 ;Programmable Interval Timer Interrupt Vector
                                        (0138)     // call	void_handler
0038: 7E       RETI                     (0139)     reti
                                        (0140) 
                                        (0141)     org 3Ch                 ;Timer Capture 0 Interrupt Vector
                                        (0142)     // call	void_handler
003C: 7E       RETI                     (0143)     reti
                                        (0144) 	
                                        (0145)     org 40h                 ;Timer Capture 1 Interrupt Vector
                                        (0146)     // call	void_handler
0040: 7E       RETI                     (0147)     reti
                                        (0148) 
                                        (0149)     org 44h                 ;Free Running Counter Wrap Interrupt Vector
                                        (0150)     // call	void_handler
0044: 7E       RETI                     (0151)     reti
                                        (0152) 
                                        (0153)     org 48h                 ;INT 2 Interrupt Vector
0048: 7D 09 22 LJMP  0x0922             (0154)     ljmp    INT2_ISR
004B: 7E       RETI                     (0155)     reti
                                        (0156) 
                                        (0157)     org 4Ch                 ;PS2 Data Low
                                        (0158)     // call	void_handler
004C: 7E       RETI                     (0159)     reti
                                        (0160) 
                                        (0161)     org 50h                 ;GPIO Port 2 Interrupt Vector
0050: 7D 09 25 LJMP  0x0925             (0162)     ljmp    PORT2_ISR
0053: 7E       RETI                     (0163)     reti
                                        (0164) 
                                        (0165)     org 54h                 ;GPIO Port 3 Interrupt Vector
0054: 7D 09 26 LJMP  0x0926             (0166)     ljmp    PORT3_ISR
0057: 7E       RETI                     (0167)     reti
                                        (0168) 
                                        (0169)     org 58h                 ;Reserved
                                        (0170)     // call	void_handler
0058: 7E       RETI                     (0171)     reti
                                        (0172) 
                                        (0173)     org 5Ch                 ;Reserved
                                        (0174)     // call	void_handler
005C: 7E       RETI                     (0175)     reti
                                        (0176) 
                                        (0177)     org 60h                 ;Reserved
                                        (0178)     // call	void_handler
0060: 7E       RETI                     (0179)     reti
                                        (0180) 
                                        (0181)     org 64h                 ;Sleep Timer Interrupt Vector
                                        (0182)     // call	void_handler
0064: 7E       RETI                     (0183)     reti
0068: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0184)     ;---------------------------------------------------
                                        (0185)     ; Insert your custom code above this banner
                                        (0186)     ;---------------------------------------------------
                                        (0187)     ;@PSoC_BOOT_ISR_UserCode_END@
                                        (0188) 
                                        (0189) ;-----------------------------------------------------------------------------
                                        (0190) ;  Start of Execution
                                        (0191) ;  CPU is operating at 3 MHz, change to 12 MHz
                                        (0192) ;  IO Bank is Bank0
                                        (0193) ;-----------------------------------------------------------------------------
                                        (0194) 
                                        (0195) IF	(TOOLCHAIN & HITECH)
                                        (0196)  	AREA PD_startup(CODE, REL, CON)
                                        (0197) ELSE
                                        (0198)     org 68h
                                        (0199) ENDIF
                                        (0200) __Start:
                                        (0201) 
                                        (0202) M8C_ClearWDTAndSleep			   ; Clear WDT before enabling it.
                                        (0203) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                        (0204)     M8C_EnableWatchDog
                                        (0205) ENDIF
                                        (0206)     ;------------------
                                        (0207)     ; Set up the clocks
                                        (0208)     ;------------------
                                        (0209) 
                                        (0210)     ; Configure the Clock Out
006B: 43 32 00 OR    REG[0x32],0x0      (0211)     OR   REG[CLKIOCR], (CLOCK_OUT_JUST)
                                        (0212) 
006E: 55 F8 00 MOV   [_ramareas_end+199],0x0(0213)     mov  [bSSC_KEY1],0             ; Lockout Flash and Supervisiory operations
0071: 55 F9 00 MOV   [_ramareas_end+200],0x0(0214)     mov  [bSSC_KEYSP],0      
                                        (0215) 
                                        (0216) IF	(TOOLCHAIN & HITECH)
                                        (0217)     ;---------------------------
                                        (0218)     ; Set up the Temporary stack
                                        (0219)     ;---------------------------
                                        (0220)     ; A temporary stack is set up for the SSC instructions.
                                        (0221)     ; The real stack start will be assigned later.
                                        (0222)     ;
                                        (0223) 	global		__Lstackps
                                        (0224) 	mov     a,low __Lstackps
                                        (0225) 	swap    a,sp
                                        (0226) ELSE
                                        (0227)     ;------------------
                                        (0228)     ; Set up the stack
                                        (0229)     ;------------------
0074: 50 31    MOV   A,0x31             (0230)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
0076: 4E       SWAP  SP,A               (0231)     swap  SP, A                    ; This is only temporary if going to LMM
                                        (0232) ENDIF
                                        (0233) 
                                        (0234)     ;@PSoC_BOOT_LOADCFG_UserCode_START@
                                        (0235)     ;---------------------------------------------------
                                        (0236)     ; Insert your custom code below this banner
                                        (0237)     ;---------------------------------------------------
                                        (0238) 
                                        (0239)     ;---------------------------------------------------
                                        (0240)     ; Insert your custom code above this banner
                                        (0241)     ;---------------------------------------------------
                                        (0242)     ;@PSoC_BOOT_LOADCFG_UserCode_END@ 
                                        (0243) 
                                        (0244)     ;-------------------------------------------------------------------------
                                        (0245)     ; All the user selections and UserModule selections are now loaded,
                                        (0246)     ; except CPU frequency (CPU is runing at 12 MHz).  Load the PSoC 
                                        (0247)     ; configuration with a 12 MHz CPU clock to keep config time short.
                                        (0248)     ;-------------------------------------------------------------------------
0077: 7C 02 2C LCALL 0x022C             (0249)     lcall LoadConfigInit           ; Configure PSoC blocks per Dev Editor
                                        (0250) IF	(TOOLCHAIN & HITECH)
                                        (0251) ; The C compiler will customize the startup code - it's not required here
                                        (0252) 
                                        (0253) ELSE
                                        (0254) IF (C_LANGUAGE_SUPPORT)
007A: 90 08    CALL  0x0084             (0255)     call InitCRunTime              ; Initialize for C language
                                        (0256) ENDIF ;(C_LANGUAGE_SUPPORT)
                                        (0257) 
                                        (0258) ENDIF
                                        (0259) 
                                        (0260) 
                                        (0261) 
                                        (0262)     ;-------------------------------------------------------------------------
                                        (0263)     ; Global Interrupt are NOT enabled, this should be done in main().
                                        (0264)     ; LVD is set but will not occur unless Global Interrupts are enabled. 
                                        (0265)     ; Global Interrupts should be as soon as possible in main().
                                        (0266)     ;-------------------------------------------------------------------------
007C: 62 E2 00 MOV   REG[0xE2],0x0      (0267)     mov  reg[INT_VC],0              ; Clear any pending interrupts which may
                                        (0268)                                     ; have been set during the boot process. 
                                        (0269) IF	(TOOLCHAIN & HITECH)
                                        (0270) 	ljmp  startup                  ; Jump to C compiler startup code
                                        (0271) ELSE
                                        (0272) IF ENABLE_LJMP_TO_MAIN
                                        (0273)     ljmp  _main                    ; goto main (no return)
                                        (0274) ELSE
007F: 7C 09 27 LCALL __text_start|_main|_main(0275)     lcall _main                    ; call main
                                        (0276) .Exit:
0082: 8F FF    JMP   0x0082             (0277)     jmp  .Exit                     ; Wait here after return till power-off or reset
                                        (0278) ENDIF
                                        (0279) ENDIF ; TOOLCHAIN
                                        (0280) 
                                        (0281) 
                                        (0282) ;-----------------------------------------------------------------------------
                                        (0283) ; C Runtime Environment Initialization
                                        (0284) ; The following code is conditionally assembled.
                                        (0285) ;-----------------------------------------------------------------------------
                                        (0286) IF (TOOLCHAIN & IMAGECRAFT)
                                        (0287) IF (C_LANGUAGE_SUPPORT)
                                        (0288) 
                                        (0289) InitCRunTime:
                                        (0290)     ;-----------------------------
                                        (0291)     ; clear bss segment
                                        (0292)     ;-----------------------------
0084: 50 00    MOV   A,0x0              (0293)     mov  A,0
0086: 55 02 04 MOV   [__r0],0x4         (0294)     mov  [__r0],<__bss_start
                                        (0295) BssLoop:
0089: 3C 02 31 CMP   [__r0],0x31        (0296)     cmp  [__r0],<__bss_end
008C: A0 05    JZ    0x0092             (0297)     jz   BssDone
008E: 3F 02    MVI   [__r0],A           (0298)     mvi  [__r0],A
0090: 8F F8    JMP   0x0089             (0299)     jmp  BssLoop
                                        (0300) BssDone:
                                        (0301)     ;----------------------------
                                        (0302)     ; copy idata to data segment
                                        (0303)     ;----------------------------
0092: 50 02    MOV   A,0x2              (0304)     mov  A,>__idata_start
0094: 57 29    MOV   X,0x29             (0305)     mov  X,<__idata_start
0096: 55 02 00 MOV   [__r0],0x0         (0306)     mov  [__r0],<__data_start
                                        (0307) IDataLoop:
0099: 3C 02 00 CMP   [__r0],0x0         (0308)     cmp  [__r0],<__data_end
009C: A0 0B    JZ    0x00A8             (0309)     jz   IDataDone
009E: 08       PUSH  A                  (0310)     push A
009F: 28       ROMX                     (0311)     romx
00A0: 3F 02    MVI   [__r0],A           (0312)     mvi  [__r0],A
00A2: 18       POP   A                  (0313)     pop  A
00A3: 75       INC   X                  (0314)     inc  X
00A4: 09 00    ADC   A,0x0              (0315)     adc  A,0
00A6: 8F F2    JMP   0x0099             (0316)     jmp  IDataLoop
                                        (0317) IDataDone:
00A8: 7F       RET                      (0318)     ret
FILE: lib\psocconfigtbl.asm             (0001) ;  Generated by PSoC Designer 5.4.3191
0229: 70 EF    AND   F,0xEF             (0002) ;
                                        (0003) ; =============================================================================
                                        (0004) ; FILENAME: PSoCConfigTBL.asm
                                        (0005) ;  
                                        (0006) ; Copyright (c) Cypress Semiconductor 2013. All Rights Reserved.
                                        (0007) ;  
                                        (0008) ; NOTES:
                                        (0009) ; Do not modify this file. It is generated by PSoC Designer each time the
                                        (0010) ; generate application function is run. The values of the parameters in this
                                        (0011) ; file can be modified by changing the values of the global parameters in the
                                        (0012) ; device editor.
                                        (0013) ;  
                                        (0014) ; =============================================================================
                                        (0015)  
                                        (0016) include "m8c.inc"
                                        (0017) ;  Personalization tables 
                                        (0018) export LoadConfigTBL_pdproject1_Bank1
                                        (0019) export LoadConfigTBL_pdproject1_Bank0
                                        (0020) export LoadConfigTBL_pdproject1_Ordered
                                        (0021) AREA lit(rom, rel)
                                        (0022) LoadConfigTBL_pdproject1_Bank0:
                                        (0023) ;  Instance name USB, User Module USB
                                        (0024) ;  Global Register values Bank 0
                                        (0025) 	db		32h, 00h		; CLKIOCR register (CLKIOCR)
                                        (0026) 	db		30h, 00h		; CPUCLKCR register (CPUCLKCR)
                                        (0027) 	db		05h, 01h		; P00CR register (P00CR)
                                        (0028) 	db		06h, 01h		; P01CR register (P01CR)
                                        (0029) 	db		07h, 01h		; P02CR register (P02CR)
                                        (0030) 	db		08h, 01h		; P03CR register (P03CR)
                                        (0031) 	db		09h, 01h		; P04CR register (P04CR)
                                        (0032) 	db		0ah, 01h		; P05CR register (P05CR)
                                        (0033) 	db		0bh, 00h		; P06CR register (P06CR)
                                        (0034) 	db		0dh, 00h		; P10CR register (P10CR)
                                        (0035) 	db		0eh, 00h		; P11CR register (P11CR)
                                        (0036) 	db		0fh, 00h		; P12CR register (P12CR)
                                        (0037) 	db		10h, 00h		; P13CR register (P13CR)
                                        (0038) 	db		11h, 00h		; P14CR register (P14CR)
                                        (0039) 	db		12h, 00h		; P15CR register (P15CR)
                                        (0040) 	db		13h, 00h		; P16CR register (P16CR)
                                        (0041) 	db		3dh, 00h		; SPICR register (SPICR)
                                        (0042) 	db		2bh, 00h		; TCAPINTE register (TCAPINTE)
                                        (0043) 	db		31h, 80h		; TMRCLKCR register (TMRCLKCR)
                                        (0044) 	db		2ah, 00h		; TMRCR register (TMRCR)
                                        (0045) 	db		ffh
                                        (0046) LoadConfigTBL_pdproject1_Bank1:
                                        (0047) ;  Instance name USB, User Module USB
                                        (0048) ;  Global Register values Bank 1
                                        (0049) 	db		e0h, 03h		; OscillatorControl_0 register (OSC_CR0)
                                        (0050) 	db		e3h, 14h		; VLDCR register (VLDCR)
                                        (0051) 	db		ffh
                                        (0052) AREA psoc_config(rom, rel)
                                        (0053) LoadConfigTBL_pdproject1_Ordered:
                                        (0054) ;  Ordered Global Register values
                                        (0055) 	M8C_SetBank0
022B: 7F       RET                      (0056) 	ret
                                        (0057) 
                                        (0058) 
                                        (0059) ; PSoC Configuration file trailer PsocConfig.asm
FILE: lib\psocconfig.asm                (0001) ;  Generated by PSoC Designer 5.4.3191
                                        (0002) ;
                                        (0003) ;==========================================================================
                                        (0004) ;  PSoCConfig.asm
                                        (0005) ;  @PSOC_VERSION
                                        (0006) ;
                                        (0007) ;  Version: 0.85
                                        (0008) ;  Revised: June 22, 2004
                                        (0009) ;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0010) ;
                                        (0011) ;  This file is generated by the Device Editor on Application Generation.
                                        (0012) ;  It contains code which loads the configuration data table generated in
                                        (0013) ;  the file PSoCConfigTBL.asm
                                        (0014) ;
                                        (0015) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                        (0016) ;  Edits to this file will not be preserved.
                                        (0017) ;==========================================================================
                                        (0018) ;
                                        (0019) include "m8c.inc"
                                        (0020) include "memory.inc"
                                        (0021) include "GlobalParams.inc"
                                        (0022) 
                                        (0023) export LoadConfigInit
                                        (0024) export _LoadConfigInit
                                        (0025) export LoadConfig_pdproject1
                                        (0026) export _LoadConfig_pdproject1
                                        (0027) export Port_1_Data_SHADE
                                        (0028) export _Port_1_Data_SHADE
                                        (0029) 
                                        (0030) 
                                        (0031) export NO_SHADOW
                                        (0032) export _NO_SHADOW
                                        (0033) 
                                        (0034) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                        (0035) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                        (0036) 
                                        (0037) AREA psoc_config(rom, rel)
                                        (0038) 
                                        (0039) ;---------------------------------------------------------------------------
                                        (0040) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                        (0041) ;                  parameters handled by boot code, like CPU speed). This
                                        (0042) ;                  function can be called from user code, but typically it
                                        (0043) ;                  is only called from boot.
                                        (0044) ;
                                        (0045) ;       INPUTS: None.
                                        (0046) ;      RETURNS: Nothing.
                                        (0047) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
                                        (0048) ;               In the large memory model currently only the page
                                        (0049) ;               pointer registers listed below are modified.  This does
                                        (0050) ;               not guarantee that in future implementations of this
                                        (0051) ;               function other page pointer registers will not be
                                        (0052) ;               modified.
                                        (0053) ;          
                                        (0054) ;               Page Pointer Registers Modified: 
                                        (0055) ;               CUR_PP
                                        (0056) ;
                                        (0057) _LoadConfigInit:
                                        (0058)  LoadConfigInit:
                                        (0059)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0060)     
022C: 55 03 00 MOV   [0x3],0x0          (0061) 	mov		[Port_1_Data_SHADE], 0h
                                        (0062) 
022F: 7C 02 36 LCALL 0x0236             (0063) 	lcall	LoadConfig_pdproject1
0232: 7C 02 29 LCALL 0x0229             (0064) 	lcall	LoadConfigTBL_pdproject1_Ordered
                                        (0065) 
                                        (0066) 
                                        (0067)     RAM_EPILOGUE RAM_USE_CLASS_4
0235: 7F       RET                      (0068)     ret
                                        (0069) 
                                        (0070) ;---------------------------------------------------------------------------
                                        (0071) ; Load Configuration pdproject1
                                        (0072) ;
                                        (0073) ;    Load configuration registers for pdproject1.
                                        (0074) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                        (0075) ;
                                        (0076) ;       INPUTS: None.
                                        (0077) ;      RETURNS: Nothing.
                                        (0078) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                        (0079) ;               modified as may the Page Pointer registers!
                                        (0080) ;               In the large memory model currently only the page
                                        (0081) ;               pointer registers listed below are modified.  This does
                                        (0082) ;               not guarantee that in future implementations of this
                                        (0083) ;               function other page pointer registers will not be
                                        (0084) ;               modified.
                                        (0085) ;          
                                        (0086) ;               Page Pointer Registers Modified: 
                                        (0087) ;               CUR_PP
                                        (0088) ;
                                        (0089) _LoadConfig_pdproject1:
                                        (0090)  LoadConfig_pdproject1:
                                        (0091)     RAM_PROLOGUE RAM_USE_CLASS_4
                                        (0092) 
0236: 10       PUSH  X                  (0093) 	push	x
0237: 70 EF    AND   F,0xEF             
                                        (0094)     M8C_SetBank0                    ; Force bank 0
0239: 50 00    MOV   A,0x0              (0095)     mov     a, 0                    ; Specify bank 0
023B: 67       ASR   A                  (0096)     asr     a                       ; Store in carry flag
                                        (0097)                                     ; Load bank 0 table:
023C: 50 01    MOV   A,0x1              (0098)     mov     A, >LoadConfigTBL_pdproject1_Bank0
023E: 57 FB    MOV   X,0xFB             (0099)     mov     X, <LoadConfigTBL_pdproject1_Bank0
0240: 7C 02 51 LCALL 0x0251             (0100)     lcall   LoadConfig              ; Load the bank 0 values
                                        (0101) 
0243: 50 01    MOV   A,0x1              (0102)     mov     a, 1                    ; Specify bank 1
0245: 67       ASR   A                  (0103)     asr     a                       ; Store in carry flag
                                        (0104)                                     ; Load bank 1 table:
0246: 50 02    MOV   A,0x2              (0105)     mov     A, >LoadConfigTBL_pdproject1_Bank1
0248: 57 24    MOV   X,0x24             (0106)     mov     X, <LoadConfigTBL_pdproject1_Bank1
024A: 7C 02 51 LCALL 0x0251             (0107)     lcall   LoadConfig              ; Load the bank 1 values
024D: 70 EF    AND   F,0xEF             
                                        (0108) 
                                        (0109)     M8C_SetBank0                    ; Force return to bank 0
024F: 20       POP   X                  (0110) 	pop		x
                                        (0111) 
                                        (0112)     RAM_EPILOGUE RAM_USE_CLASS_4
0250: 7F       RET                      (0113)     ret
                                        (0114) 
                                        (0115) 
                                        (0116) 
                                        (0117) 
                                        (0118) ;---------------------------------------------------------------------------
                                        (0119) ; LoadConfig - Set IO registers as specified in ROM table of (address,value)
                                        (0120) ;              pairs. Terminate on address=0xFF.
                                        (0121) ;
                                        (0122) ;  INPUTS:  [A,X] points to the table to be loaded
                                        (0123) ;           Flag Register Carry bit encodes the Register Bank
                                        (0124) ;           (Carry=0 => Bank 0; Carry=1 => Bank 1)
                                        (0125) ;
                                        (0126) ;  RETURNS: nothing.
                                        (0127) ;
                                        (0128) ;  STACK FRAME:  X-4 I/O Bank 0/1 indicator
                                        (0129) ;                X-3 Temporary store for register address
                                        (0130) ;                X-2 LSB of config table address
                                        (0131) ;                X-1 MSB of config table address
                                        (0132) ;
                                        (0133) LoadConfig:
                                        (0134)     RAM_PROLOGUE RAM_USE_CLASS_2
0251: 38 02    ADD   SP,0x2             (0135)     add     SP, 2                   ; Set up local vars
0253: 10       PUSH  X                  (0136)     push    X                       ; Save config table address on stack
0254: 08       PUSH  A                  (0137)     push    A
0255: 4F       MOV   X,SP               (0138)     mov     X, SP
0256: 56 FC 00 MOV   [X-4],0x0          (0139)     mov     [X-4], 0                ; Set default Destination to Bank 0
0259: D0 04    JNC   0x025E             (0140)     jnc     .BankSelectSaved        ; Carry says Bank 0 is OK
025B: 56 FC 01 MOV   [X-4],0x1          (0141)     mov     [X-4], 1                ; No Carry: default to Bank 1
                                        (0142) .BankSelectSaved:
025E: 18       POP   A                  (0143)     pop     A
025F: 20       POP   X                  (0144)     pop     X
0260: 70 EF    AND   F,0xEF             
0262: 62 E3 00 MOV   REG[0xE3],0x0      
                                        (0145) 
                                        (0146) LoadConfigLp:
                                        (0147)     M8C_SetBank0                    ; Switch to bank 0
                                        (0148)     M8C_ClearWDT                    ; Clear the watchdog for long inits
0265: 10       PUSH  X                  (0149)     push    X                       ; Preserve the config table address
0266: 08       PUSH  A                  (0150)     push    A
0267: 28       ROMX                     (0151)     romx                            ; Load register address from table
0268: 39 FF    CMP   A,0xFF             (0152)     cmp     A, END_CONFIG_TABLE     ; End of table?
026A: A0 1F    JZ    0x028A             (0153)     jz      EndLoadConfig           ;   Yes, go wrap it up
026C: 4F       MOV   X,SP               (0154)     mov     X, SP                   ;
026D: 48 FC 01 TST   [X-4],0x1          (0155)     tst     [X-4], 1                ; Loading IO Bank 1?
0270: A0 03    JZ    0x0274             (0156)     jz      .IOBankNowSet           ;    No, Bank 0 is fine
0272: 71 10    OR    F,0x10             
                                        (0157)     M8C_SetBank1                    ;   Yes, switch to Bank 1
                                        (0158) .IOBankNowSet:
0274: 54 FD    MOV   [X-3],A            (0159)     mov     [X-3], A                ; Stash the register address
0276: 18       POP   A                  (0160)     pop     A                       ; Retrieve the table address
0277: 20       POP   X                  (0161)     pop     X
0278: 75       INC   X                  (0162)     inc     X                       ; Advance to the data byte
0279: 09 00    ADC   A,0x0              (0163)     adc     A, 0
027B: 10       PUSH  X                  (0164)     push    X                       ; Save the config table address again
027C: 08       PUSH  A                  (0165)     push    A
027D: 28       ROMX                     (0166)     romx                            ; load config data from the table
027E: 4F       MOV   X,SP               (0167)     mov     X, SP                   ; retrieve the register address
027F: 59 FD    MOV   X,[X-3]            (0168)     mov     X, [X-3]
0281: 61 00    MOV   REG[X+0x0],A       (0169)     mov     reg[X], A               ; Configure the register
0283: 18       POP   A                  (0170)     pop     A                       ; retrieve the table address
0284: 20       POP   X                  (0171)     pop     X
0285: 75       INC   X                  (0172)     inc     X                       ; advance to next table entry
0286: 09 00    ADC   A,0x0              (0173)     adc     A, 0
0288: 8F D7    JMP   0x0260             (0174)     jmp     LoadConfigLp            ; loop to configure another register
                                        (0175) EndLoadConfig:
028A: 38 FC    ADD   SP,0xFC            (0176)     add     SP, -4
                                        (0177)     RAM_EPILOGUE RAM_USE_CLASS_2
028C: 7F       RET                      (0178)     ret
                                        (0179) 
                                        (0180) AREA InterruptRAM(ram, rel)
                                        (0181) 
                                        (0182) NO_SHADOW:
                                        (0183) _NO_SHADOW:
                                        (0184) ; write only register shadows
                                        (0185) _Port_1_Data_SHADE:
                                        (0186) Port_1_Data_SHADE:	BLK	1
                                        (0187) 
FILE: lib\usb_std.asm                   (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: USB_std.asm
                                        (0004) ;;   Version: 1.90, Updated on 2015/3/4 at 22:20:18
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: USB Device User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API
                                        (0013) ;;        function returns. Even though these registers may be preserved now,
                                        (0014) ;;        there is no guarantee they will be preserved in future releases.
                                        (0015) ;;-----------------------------------------------------------------------------
                                        (0016) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0017) ;;*****************************************************************************
                                        (0018) ;;*****************************************************************************
                                        (0019) 
                                        (0020) include "m8c.inc"
                                        (0021) include "USB_macros.inc"
                                        (0022) include "USB.inc"
                                        (0023) 
                                        (0024) ;-----------------------------------------------
                                        (0025) ;  Global Symbols
                                        (0026) ;-----------------------------------------------
                                        (0027) 
                                        (0028) AREA bss (RAM,REL)
                                        (0029) 
                                        (0030) ;-----------------------------------------------
                                        (0031) ;  Constant Definitions
                                        (0032) ;-----------------------------------------------
                                        (0033) ;-----------------------------------------------
                                        (0034) ; Variable Allocation
                                        (0035) ;-----------------------------------------------
                                        (0036) 
                                        (0037) AREA UserModules (ROM, REL)
                                        (0038) 
                                        (0039) ;-----------------------------------------------------------------------------
                                        (0040) ;  FUNCTION NAME: USB_Not_Supported
                                        (0041) ;
                                        (0042) ;  DESCRIPTION:   The USB_Not_Supported routine is invoked for any
                                        (0043) ;         USB request that is not supported.  It is invoked with a
                                        (0044) ;         JMP/LJMP and does not return.  It exits through the common
                                        (0045) ;                 EP0 exit.
                                        (0046) ;
                                        (0047) ;-----------------------------------------------------------------------------
                                        (0048) ;
                                        (0049) ;  ARGUMENTS:     None
                                        (0050) ;
                                        (0051) ;  RETURNS:       Does not return
                                        (0052) ;
                                        (0053) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0054) ;
                                        (0055) ;  THEORY of OPERATION or PROCEDURE:
                                        (0056) ;
                                        (0057) ;-----------------------------------------------------------------------------
                                        (0058) 
                                        (0059) ; d2h_std_dev
                                        (0060) IF (USB_CB_SRC_d2h_std_dev_00 & USB_NOT_SUPPORTED)
                                        (0061) export  USB_CB_d2h_std_dev_00
                                        (0062) USB_CB_d2h_std_dev_00:
                                        (0063) ENDIF
                                        (0064) IF (USB_CB_SRC_d2h_std_dev_01 & USB_NOT_SUPPORTED)
                                        (0065) export  USB_CB_d2h_std_dev_01
                                        (0066) USB_CB_d2h_std_dev_01:
                                        (0067) ENDIF
                                        (0068) IF (USB_CB_SRC_d2h_std_dev_02 & USB_NOT_SUPPORTED)
                                        (0069) export  USB_CB_d2h_std_dev_02
                                        (0070) USB_CB_d2h_std_dev_02:
                                        (0071) ENDIF
                                        (0072) IF (USB_CB_SRC_d2h_std_dev_03 & USB_NOT_SUPPORTED)
                                        (0073) export  USB_CB_d2h_std_dev_03
                                        (0074) USB_CB_d2h_std_dev_03:
                                        (0075) ENDIF
                                        (0076) IF (USB_CB_SRC_d2h_std_dev_04 & USB_NOT_SUPPORTED)
                                        (0077) export  USB_CB_d2h_std_dev_04
                                        (0078) USB_CB_d2h_std_dev_04:
                                        (0079) ENDIF
                                        (0080) IF (USB_CB_SRC_d2h_std_dev_05 & USB_NOT_SUPPORTED)
                                        (0081) export  USB_CB_d2h_std_dev_05
                                        (0082) USB_CB_d2h_std_dev_05:
                                        (0083) ENDIF
                                        (0084) IF (USB_CB_SRC_d2h_std_dev_06 & USB_NOT_SUPPORTED)
                                        (0085) export  USB_CB_d2h_std_dev_06
                                        (0086) USB_CB_d2h_std_dev_06:
                                        (0087) ENDIF
                                        (0088) IF (USB_CB_SRC_d2h_std_dev_07 & USB_NOT_SUPPORTED)
                                        (0089) export  USB_CB_d2h_std_dev_07
                                        (0090) USB_CB_d2h_std_dev_07:
                                        (0091) ENDIF
                                        (0092) IF (USB_CB_SRC_d2h_std_dev_08 & USB_NOT_SUPPORTED)
                                        (0093) export  USB_CB_d2h_std_dev_08
                                        (0094) USB_CB_d2h_std_dev_08:
                                        (0095) ENDIF
                                        (0096) 
                                        (0097) ; h2d_std_dev
                                        (0098) IF (USB_CB_SRC_h2d_std_dev_00 & USB_NOT_SUPPORTED)
                                        (0099) export  USB_CB_h2d_std_dev_00
                                        (0100) USB_CB_h2d_std_dev_00:
                                        (0101) ENDIF
                                        (0102) IF (USB_CB_SRC_h2d_std_dev_01 & USB_NOT_SUPPORTED)
                                        (0103) export  USB_CB_h2d_std_dev_01
                                        (0104) USB_CB_h2d_std_dev_01:
                                        (0105) ENDIF
                                        (0106) IF (USB_CB_SRC_h2d_std_dev_02 & USB_NOT_SUPPORTED)
                                        (0107) export  USB_CB_h2d_std_dev_02
                                        (0108) USB_CB_h2d_std_dev_02:
                                        (0109) ENDIF
                                        (0110) IF (USB_CB_SRC_h2d_std_dev_03 & USB_NOT_SUPPORTED)
                                        (0111) export  USB_CB_h2d_std_dev_03
                                        (0112) USB_CB_h2d_std_dev_03:
                                        (0113) ENDIF
                                        (0114) IF (USB_CB_SRC_h2d_std_dev_04 & USB_NOT_SUPPORTED)
                                        (0115) export  USB_CB_h2d_std_dev_04
                                        (0116) USB_CB_h2d_std_dev_04:
                                        (0117) ENDIF
                                        (0118) IF (USB_CB_SRC_h2d_std_dev_05 & USB_NOT_SUPPORTED)
                                        (0119) export  USB_CB_h2d_std_dev_05
                                        (0120) USB_CB_h2d_std_dev_05:
                                        (0121) ENDIF
                                        (0122) IF (USB_CB_SRC_h2d_std_dev_06 & USB_NOT_SUPPORTED)
                                        (0123) export  USB_CB_h2d_std_dev_06
                                        (0124) USB_CB_h2d_std_dev_06:
                                        (0125) ENDIF
                                        (0126) IF (USB_CB_SRC_h2d_std_dev_07 & USB_NOT_SUPPORTED)
                                        (0127) export  USB_CB_h2d_std_dev_07
                                        (0128) USB_CB_h2d_std_dev_07:
                                        (0129) ENDIF
                                        (0130) IF (USB_CB_SRC_h2d_std_dev_08 & USB_NOT_SUPPORTED)
                                        (0131) export  USB_CB_h2d_std_dev_08
                                        (0132) USB_CB_h2d_std_dev_08:
                                        (0133) ENDIF
                                        (0134) IF (USB_CB_SRC_h2d_std_dev_09 & USB_NOT_SUPPORTED)
                                        (0135) export  USB_CB_h2d_std_dev_09
                                        (0136) USB_CB_h2d_std_dev_09:
                                        (0137) ENDIF
                                        (0138) 
                                        (0139) ; d2h_std_ifc
                                        (0140) IF (USB_CB_SRC_d2h_std_ifc_00 & USB_NOT_SUPPORTED)
                                        (0141) export  USB_CB_d2h_std_ifc_00
                                        (0142) USB_CB_d2h_std_ifc_00:
                                        (0143) ENDIF
                                        (0144) IF (USB_CB_SRC_d2h_std_ifc_01 & USB_NOT_SUPPORTED)
                                        (0145) export  USB_CB_d2h_std_ifc_01
                                        (0146) USB_CB_d2h_std_ifc_01:
                                        (0147) ENDIF
                                        (0148) IF (USB_CB_SRC_d2h_std_ifc_02 & USB_NOT_SUPPORTED)
                                        (0149) export  USB_CB_d2h_std_ifc_02
                                        (0150) USB_CB_d2h_std_ifc_02:
                                        (0151) ENDIF
                                        (0152) IF (USB_CB_SRC_d2h_std_ifc_03 & USB_NOT_SUPPORTED)
                                        (0153) export  USB_CB_d2h_std_ifc_03
                                        (0154) USB_CB_d2h_std_ifc_03:
                                        (0155) ENDIF
                                        (0156) IF (USB_CB_SRC_d2h_std_ifc_04 & USB_NOT_SUPPORTED)
                                        (0157) export  USB_CB_d2h_std_ifc_04
                                        (0158) USB_CB_d2h_std_ifc_04:
                                        (0159) ENDIF
                                        (0160) IF (USB_CB_SRC_d2h_std_ifc_05 & USB_NOT_SUPPORTED)
                                        (0161) export  USB_CB_d2h_std_ifc_05
                                        (0162) USB_CB_d2h_std_ifc_05:
                                        (0163) ENDIF
                                        (0164) IF (USB_CB_SRC_d2h_std_ifc_06 & USB_NOT_SUPPORTED)
                                        (0165) export  USB_CB_d2h_std_ifc_06
                                        (0166) USB_CB_d2h_std_ifc_06:
                                        (0167) ENDIF
                                        (0168) IF (USB_CB_SRC_d2h_std_ifc_07 & USB_NOT_SUPPORTED)
                                        (0169) export  USB_CB_d2h_std_ifc_07
                                        (0170) USB_CB_d2h_std_ifc_07:
                                        (0171) ENDIF
                                        (0172) IF (USB_CB_SRC_d2h_std_ifc_08 & USB_NOT_SUPPORTED)
                                        (0173) export  USB_CB_d2h_std_ifc_08
                                        (0174) USB_CB_d2h_std_ifc_08:
                                        (0175) ENDIF
                                        (0176) IF (USB_CB_SRC_d2h_std_ifc_09 & USB_NOT_SUPPORTED)
                                        (0177) export  USB_CB_d2h_std_ifc_09
                                        (0178) USB_CB_d2h_std_ifc_09:
                                        (0179) ENDIF
                                        (0180) IF (USB_CB_SRC_d2h_std_ifc_10 & USB_NOT_SUPPORTED)
                                        (0181) export  USB_CB_d2h_std_ifc_10
                                        (0182) USB_CB_d2h_std_ifc_10:
                                        (0183) ENDIF
                                        (0184) 
                                        (0185) ; d2h_std_ifc
                                        (0186) IF (USB_CB_SRC_h2d_std_ifc_00 & USB_NOT_SUPPORTED)
                                        (0187) export  USB_CB_h2d_std_ifc_00
                                        (0188) USB_CB_h2d_std_ifc_00:
                                        (0189) ENDIF
                                        (0190) 
                                        (0191) ; d2h_std_ep
                                        (0192) IF (USB_CB_SRC_d2h_std_ep_00 & USB_NOT_SUPPORTED)
                                        (0193) export  USB_CB_d2h_std_ep_00
                                        (0194) USB_CB_d2h_std_ep_00:
                                        (0195) ENDIF
                                        (0196) 
                                        (0197) ; h2d_std_ep
                                        (0198) IF (USB_CB_SRC_h2d_std_ep_00 & USB_NOT_SUPPORTED)
                                        (0199) export  USB_CB_h2d_std_ep_00
                                        (0200) USB_CB_h2d_std_ep_00:
                                        (0201) ENDIF
                                        (0202) IF (USB_CB_SRC_h2d_std_ep_01 & USB_NOT_SUPPORTED)
                                        (0203) export  USB_CB_h2d_std_ep_01
                                        (0204) USB_CB_h2d_std_ep_01:
                                        (0205) ENDIF
                                        (0206) IF (USB_CB_SRC_h2d_std_ep_02 & USB_NOT_SUPPORTED)
                                        (0207) export  USB_CB_h2d_std_ep_02
                                        (0208) USB_CB_h2d_std_ep_02:
                                        (0209) ENDIF
                                        (0210) IF (USB_CB_SRC_h2d_std_ep_03 & USB_NOT_SUPPORTED)
                                        (0211) export  USB_CB_h2d_std_ep_03
                                        (0212) USB_CB_h2d_std_ep_03:
                                        (0213) ENDIF
                                        (0214) 
                                        (0215) export  USB_Not_Supported
                                        (0216) export _USB_Not_Supported
                                        (0217) USB_Not_Supported:
                                        (0218) _USB_Not_Supported:
028D: 50 00    MOV   A,0x0              (0219)    MOV    A, 0                         ; Count 0
028F: 57 03    MOV   X,0x3              (0220)    MOV    X, USB_MODE_STALL_IN_OUT     ; Stall the request
0291: 7D 05 34 LJMP  USB_EP0_UPD_MODE_EXIT(0221)    LJMP   USB_EP0_UPD_MODE_EXIT
                                        (0222) ;-----------------------------------------------------------------------------
                                        (0223) ;  FUNCTION NAME: USB_CB_d2h_std_dev_00
                                        (0224) ;
                                        (0225) ;  DESCRIPTION:   Get Device Status
                                        (0226) ;
                                        (0227) ;****************************************************************
                                        (0228) ; STANDARD DEVICE IN REQUEST: Get_Device_Status
                                        (0229) ;****************************************************************
                                        (0230) ;
                                        (0231) ; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h     
                                        (0232) ; bRequest       : GET_STATUS                     = 00h    
                                        (0233) ; wValue         : RESERVED                       = 0000h  
                                        (0234) ; wIndex         : RESERVED                       = 0000h
                                        (0235) ; wLength        : SIZEOF_ENDPOINT_STATUS         = 0002h  
                                        (0236) ; 
                                        (0237) ; The GET_DEVICE_STATUS request returns the current device status.
                                        (0238) ;
                                        (0239) ;****************************************************************
                                        (0240) ;-----------------------------------------------------------------------------
                                        (0241) ;
                                        (0242) ;  ARGUMENTS:
                                        (0243) ;
                                        (0244) ;  RETURNS:
                                        (0245) ;
                                        (0246) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0247) ;
                                        (0248) ;  THEORY of OPERATION or PROCEDURE:
                                        (0249) ;
                                        (0250) ;-----------------------------------------------------------------------------
                                        (0251) .LITERAL
                                        (0252) GetStatusTransferDescrTable:
                                        (0253)     TD_START_TABLE 1                   ; One entry
                                        (0254)     TD_ENTRY    USB_DS_RAM, 2, USB_TransferBuffer, NULL_PTR  ; Intermediate Buffer
                                        (0255) .ENDLITERAL
                                        (0256) IF (USB_CB_SRC_d2h_std_dev_00 & USB_UM_SUPPLIED)
                                        (0257) export  USB_CB_d2h_std_dev_00
                                        (0258) USB_CB_d2h_std_dev_00:
029D: 55 26 00 MOV   [USB_t2],0x0       (0259)     MOV     [USB_t2], 0                ; Use the UM temp var--Selector
                                        (0260) 
02A0: 55 14 00 MOV   [USB_TransferBuffer+1],0x0(0261)     MOV     [USB_TransferBuffer+1], 0  ; Use the UM Transfer Buffer
02A3: 5F 13 0C MOV   [USB_TransferBuffer],[USB_DeviceStatus](0262)     MOV     [USB_TransferBuffer], [USB_DeviceStatus]
                                        (0263) 
02A6: 50 02    MOV   A,0x2              (0264)     MOV     A,>GetStatusTransferDescrTable  ; Get the ROM Address MSB
02A8: 57 94    MOV   X,0x94             (0265)     MOV     X,<GetStatusTransferDescrTable  ; Get the ROM Address LSB
02AA: 82 67    JMP   0x0512             (0266)     JMP     USB_GetTableEntry_Local_Std
                                        (0267) ELSE
                                        (0268) IF (USB_CB_SRC_d2h_std_dev_00 & USB_APP_SUPPLIED)
                                        (0269) export  USB_CB_d2h_std_dev_00
                                        (0270) USB_CB_d2h_std_dev_00:
                                        (0271)     LJMP    APP_USB_CB_d2h_std_dev_00
                                        (0272) ENDIF
                                        (0273) ENDIF
                                        (0274) ;-----------------------------------------------------------------------------
                                        (0275) ; FUNCTION NAME: USB_CB_d2h_std_dev_06
                                        (0276) ;
                                        (0277) ; DESCRIPTION:   Get Device Descriptor
                                        (0278) ;
                                        (0279) ;****************************************************************
                                        (0280) ; STANDARD DEVICE IN REQUEST: Get_Device_Descriptor
                                        (0281) ;****************************************************************
                                        (0282) ;
                                        (0283) ; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h
                                        (0284) ; bRequest       : GET_DESCRIPTOR                 = 06h    
                                        (0285) ; wValue         : DESCRIPTOR TYPE | INDEX        = xxxxh  
                                        (0286) ; wIndex         : ZERO or LANG_ID                = xxxxh
                                        (0287) ; wLength        : SIZEOF_DESCRIPTOR              = --xxh  
                                        (0288) ; 
                                        (0289) ; The GET_DEVICE_DESCRIPTOR returns the specified descriptor if 
                                        (0290) ; the descriptor exists. 
                                        (0291) ; 
                                        (0292) ; The upper byte of wValue contains the descriptor type and 
                                        (0293) ; the lower byte contains the descriptor index. wIndex 
                                        (0294) ; contains either 0000h or the Language ID. wLength contains 
                                        (0295) ; the descriptor length. The actual descriptor information is 
                                        (0296) ; transferred in subsequent data packets. 
                                        (0297) ;
                                        (0298) ;****************************************************************
                                        (0299) ;
                                        (0300) ;-----------------------------------------------------------------------------
                                        (0301) ;
                                        (0302) ;  ARGUMENTS:
                                        (0303) ;
                                        (0304) ;  RETURNS:
                                        (0305) ;
                                        (0306) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0307) ;
                                        (0308) ;  THEORY of OPERATION or PROCEDURE:
                                        (0309) ;
                                        (0310) ;-----------------------------------------------------------------------------
                                        (0311) IF (USB_CB_SRC_d2h_std_dev_06 & USB_UM_SUPPLIED)
                                        (0312) export  USB_CB_d2h_std_dev_06
                                        (0313) USB_CB_d2h_std_dev_06:
                                        (0314) ;-----------------------------------------------------------------------------
                                        (0315) ; Dispatch to the proper handler
                                        (0316) ;-----------------------------------------------------------------------------
02AC: 5D 53    MOV   A,REG[0x53]        (0317)     MOV     A, REG[USB_EP0DATA+wValueHi] ; Get the descrptor type
02AE: 64       ASL   A                  (0318)     ASL     A                          ; Make it into a offset
02AF: 39 08    CMP   A,0x8              (0319)     CMP     A, GET_DESCR_DISPATCH_SIZE         ; Validity check
02B1: DF DB    JNC   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(0320)     JNC     USB_Not_Supported
                                        (0321) 
02B3: E0 01    JACC  0x02B5             (0322)     JACC    GET_DESCR_DISPATCH
                                        (0323) 
                                        (0324) GET_DESCR_DISPATCH:
02B5: 8F D7    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(0325)     JMP     USB_Not_Supported          ; Invalid
02B7: 80 28    JMP   0x02E0             (0326)     JMP     USB_SendDeviceDescr        ; Device Descriptor
02B9: 80 03    JMP   0x02BD             (0327)     JMP     USB_SendConfigDescr        ; Configuration Descriptor
                                        (0328) IF  USB_bNumStringDescrs               ; Number of String Descriptor defined with the Wizard
02BB: 80 34    JMP   0x02F0             (0329)     JMP     USB_SendStringDescr        ; String Descriptor
                                        (0330) ELSE
                                        (0331)     JMP     USB_Not_Supported          ; Not supported if we don't have
                                        (0332)                                             ; any String Descriptor
                                        (0333) ENDIF
                                        (0334) GET_DESCR_DISPATCH_END:
                                        (0335) GET_DESCR_DISPATCH_SIZE: EQU (GET_DESCR_DISPATCH_END - GET_DESCR_DISPATCH)     
                                        (0336) ;-----------------------------------------------------------------------------
                                        (0337) ; Configuration Descriptor Handler
                                        (0338) ;-----------------------------------------------------------------------------
                                        (0339) USB_SendConfigDescr:
02BD: 94 65    CALL  USB_GET_DEVICE_TABLE_ENTRY(0340)     CALL    USB_GET_DEVICE_TABLE_ENTRY
02BF: 4B       SWAP  A,X                (0341)     SWAP    A, X
02C0: 01 02    ADD   A,0x2              (0342)     ADD     A, 2                       ; We want the pointer to the descriptor table (second entry)
02C2: 4B       SWAP  A,X                (0343)     SWAP    A, X
02C3: 09 00    ADC   A,0x0              (0344)     ADC     A, 0                       ; Don't forget the carry
02C5: 55 26 27 MOV   [USB_t2],0x27      (0345)     MOV    [USB_t2], USB_t1            ; Set up the destination  
02C8: 94 49    CALL  USB_GETWORD        (0346)     CALL    USB_GETWORD                ; Get the pointer
                                        (0347)     
02CA: 51 27    MOV   A,[USB_t1]         (0348)     MOV     A, [USB_t1]                ; Pointer MSB
02CC: 58 28    MOV   X,[USB_t0]         (0349)     MOV     X, [USB_t1+1]              ; Pointer LSB
                                        (0350)     
02CE: 08       PUSH  A                  (0351)     PUSH    A                          ; Save the MSB
                                        (0352)     
02CF: 5D 52    MOV   A,REG[0x52]        (0353)     MOV     A, REG[USB_EP0DATA+wValueLo]  ; Get the descrptor index
02D1: 53 26    MOV   [USB_t2],A         (0354)     MOV     [USB_t2], A                ; Use the UM temp var--Selector
02D3: 18       POP   A                  (0355)     POP     A                          ; Need the MSB for the range check
02D4: 08       PUSH  A                  (0356)     PUSH    A                          ; Save the MSB for after the range check
02D5: 28       ROMX                     (0357)     ROMX                               ; First entry is the table size (only a byte)
02D6: 3A 26    CMP   A,[USB_t2]         (0358)     CMP     A, [USB_t2]                ; Range check
02D8: D0 04    JNC   0x02DD             (0359)     JNC     .range_ok
                                        (0360)     
02DA: 18       POP   A                  (0361)     POP     A                          ; Fix the stack
02DB: 8F B1    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(0362)     JMP    USB_Not_Supported
                                        (0363) 
                                        (0364) .range_ok:
02DD: 18       POP   A                  (0365)     POP     A                          ; Get the MSB back
02DE: 82 33    JMP   0x0512             (0366)     JMP     USB_GetTableEntry_Local_Std
                                        (0367) ;-----------------------------------------------------------------------------
                                        (0368) ; Device Descriptor Handler
                                        (0369) ;-----------------------------------------------------------------------------
                                        (0370) USB_SendDeviceDescr:
02E0: 5F 26 0A MOV   [USB_t2],[USB_bCurrentDevice](0371)     MOV     [USB_t2], [USB_bCurrentDevice]  ; Use the UM temp var--Selector
02E3: 50 01    MOV   A,0x1              (0372)     MOV     A,>USB_DEVICE_DESCR_TABLE  ; Get the ROM Address MSB
02E5: 57 70    MOV   X,0x70             (0373)     MOV     X,<USB_DEVICE_DESCR_TABLE  ; Get the ROM Address LSB
02E7: 28       ROMX                     (0374)     ROMX                               ; First entry is the table size (only a byte)
02E8: 3A 26    CMP   A,[USB_t2]         (0375)     CMP     A, [USB_t2]                ; Range check
02EA: CF A2    JC    __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(0376)     JC      USB_Not_Supported
                                        (0377) 
02EC: 50 01    MOV   A,0x1              (0378)     MOV     A,>USB_DEVICE_DESCR_TABLE  ; Get the ROM Address MSB
                                        (0379) 
02EE: 82 23    JMP   0x0512             (0380)     JMP     USB_GetTableEntry_Local_Std
                                        (0381) ;-----------------------------------------------------------------------------
                                        (0382) ; String Descriptor Handler
                                        (0383) ;-----------------------------------------------------------------------------
                                        (0384) IF  USB_bNumStringDescrs    ; Not needed if we don't have any String Descriptors
                                        (0385) USB_SendStringDescr:
02F0: 5D 52    MOV   A,REG[0x52]        (0386)     MOV     A, REG[USB_EP0DATA+wValueLo]  ; Get the descrptor index
02F2: 53 26    MOV   [USB_t2],A         (0387)     MOV     [USB_t2], A                ; Use the UM temp var--Selector
                                        (0388) 
02F4: 50 01    MOV   A,0x1              (0389)     MOV     A,>USB_StringTable         ; Get the ROM Address MSB
02F6: 57 A4    MOV   X,0xA4             (0390)     MOV     X,<USB_StringTable         ; Get the ROM Address LSB
02F8: 28       ROMX                     (0391)     ROMX                               ; First entry is the table size (only a byte)
02F9: 3A 26    CMP   A,[USB_t2]         (0392)     CMP     A, [USB_t2]                ; Range check
02FB: CF 91    JC    __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(0393)     JC      USB_Not_Supported
                                        (0394) 
02FD: 50 01    MOV   A,0x1              (0395)     MOV     A,>USB_StringTable         ; Get the ROM Address MSB
                                        (0396) 
02FF: 82 12    JMP   0x0512             (0397)     JMP     USB_GetTableEntry_Local_Std
                                        (0398) ENDIF
                                        (0399) ELSE
                                        (0400) IF (USB_CB_SRC_d2h_std_dev_06 & USB_APP_SUPPLIED)
                                        (0401) export  USB_CB_d2h_std_dev_06
                                        (0402) USB_CB_d2h_std_dev_06:
                                        (0403)     LJMP    APP_USB_CB_d2h_std_dev_06
                                        (0404) ENDIF
                                        (0405) ENDIF
                                        (0406) ;-----------------------------------------------------------------------------
                                        (0407) ;  FUNCTION NAME: USB_CB_d2h_std_dev_08
                                        (0408) ;
                                        (0409) ;  DESCRIPTION:   Get Device Configuration
                                        (0410) ;
                                        (0411) ;****************************************************************
                                        (0412) ; STANDARD DEVICE IN REQUEST: Get_Device_Configuration
                                        (0413) ;****************************************************************
                                        (0414) ;
                                        (0415) ; bmRequestType  : (IN | STANDARD | DEVICE)       = 80h
                                        (0416) ; bRequest       : GET_CONFIGURATION              = 08h    
                                        (0417) ; wValue         : RESERVED                       = 0000h  
                                        (0418) ; wIndex         : RESERVED                       = 0000h
                                        (0419) ; wLength        : SIZEOF_DEVICE_CONFIGURATION    = 0001h  
                                        (0420) ; 
                                        (0421) ; The GET_DEVICE_CONFIGURATION request returns the currently 
                                        (0422) ; selected device configuration number. 
                                        (0423) ;
                                        (0424) ; request_value and request_index contain 0000h. request_length 
                                        (0425) ; contains 0001h and the one-byte configuration number is returned 
                                        (0426) ; in a separate data transfer.
                                        (0427) ;
                                        (0428) ;-----------------------------------------------------------------------------
                                        (0429) ;
                                        (0430) ;  ARGUMENTS:
                                        (0431) ;
                                        (0432) ;  RETURNS:
                                        (0433) ;
                                        (0434) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0435) ;
                                        (0436) ;  THEORY of OPERATION or PROCEDURE:
                                        (0437) ;
                                        (0438) ;-----------------------------------------------------------------------------
                                        (0439) IF (USB_CB_SRC_d2h_std_dev_08 & USB_UM_SUPPLIED)
                                        (0440) .LITERAL
                                        (0441) GetConfigTransferDescrTable:
                                        (0442)     TD_START_TABLE  1                  ; One entry
                                        (0443)     TD_ENTRY    USB_DS_RAM, 1, USB_Configuration, NULL_PTR  ; Current configuration
                                        (0444) .ENDLITERAL
                                        (0445) export  USB_CB_d2h_std_dev_08
                                        (0446) USB_CB_d2h_std_dev_08:
030A: 55 26 00 MOV   [USB_t2],0x0       (0447)     MOV     [USB_t2], 0                ; Use the UM temp var--Selector
030D: 50 03    MOV   A,0x3              (0448)     MOV     A,>GetConfigTransferDescrTable  ; Get the ROM Address MSB
030F: 57 01    MOV   X,0x1              (0449)     MOV     X,<GetConfigTransferDescrTable  ; Get the ROM Address LSB
0311: 82 00    JMP   0x0512             (0450)     JMP     USB_GetTableEntry_Local_Std
                                        (0451) ELSE
                                        (0452) IF (USB_CB_SRC_d2h_std_dev_08 & USB_APP_SUPPLIED)
                                        (0453) export  USB_CB_d2h_std_dev_08
                                        (0454) USB_CB_d2h_std_dev_08:
                                        (0455)     LJMP    APP_USB_CB_d2h_std_dev_08
                                        (0456) ENDIF
                                        (0457) ENDIF
                                        (0458) ;-----------------------------------------------------------------------------
                                        (0459) ;  FUNCTION NAME: USB_CB_h2d_std_dev_01
                                        (0460) ;
                                        (0461) ;  DESCRIPTION:   Clear Device Feature
                                        (0462) ;
                                        (0463) ;****************************************************************
                                        (0464) ; STANDARD DEVICE OUT REQUEST: Clear_Device_Feature
                                        (0465) ;****************************************************************
                                        (0466) ;
                                        (0467) ; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
                                        (0468) ; bRequest       : CLEAR_FEATURE                  = 01h    
                                        (0469) ; wValue         : FEATURE_SELECTOR               = --xxh  
                                        (0470) ; wIndex         : RESERVED                       = 0000h
                                        (0471) ; wLength        : RESERVED                       = 0000h  
                                        (0472) ; 
                                        (0473) ; The CLEAR_DEVICE_FEATURE request disables a particular feature 
                                        (0474) ; for a device. The only feature supported for a device is the 
                                        (0475) ; REMOTE_WAKEUP feature.
                                        (0476) ; 
                                        (0477) ;****************************************************************
                                        (0478) ;-----------------------------------------------------------------------------
                                        (0479) ;
                                        (0480) ;  ARGUMENTS:
                                        (0481) ;
                                        (0482) ;  RETURNS:
                                        (0483) ;
                                        (0484) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0485) ;
                                        (0486) ;  THEORY of OPERATION or PROCEDURE:
                                        (0487) ;
                                        (0488) ;-----------------------------------------------------------------------------
                                        (0489) IF (USB_CB_SRC_h2d_std_dev_01 & USB_UM_SUPPLIED)
                                        (0490) export  USB_CB_h2d_std_dev_01
                                        (0491) USB_CB_h2d_std_dev_01:
0313: 5D 52    MOV   A,REG[0x52]        (0492)     MOV     A, REG[USB_EP0DATA+wValueLo]  ; Get the Feature Selector
                                        (0493)                                        ; Check against valid features
                                        (0494)                                        ;  for device receipient
0315: 39 01    CMP   A,0x1              (0495)     CMP     A, USB_DEVICE_REMOTE_WAKEUP  ; Only remote wakeup is defined for clear
0317: BF 75    JNZ   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(0496)     JNZ     USB_Not_Supported          ;      
0319: 26 0C FD AND   [USB_DeviceStatus],0xFD(0497)     AND     [USB_DeviceStatus], ~USB_DEVICE_STATUS_REMOTE_WAKEUP
031C: 81 F8    JMP   0x0515             (0498)     JMP     USB_NoDataStageControlTransfer_Local_Std
                                        (0499) ELSE
                                        (0500) IF (USB_CB_SRC_h2d_std_dev_01 & USB_APP_SUPPLIED)
                                        (0501) export  USB_CB_h2d_std_dev_01
                                        (0502) USB_CB_h2d_std_dev_01:
                                        (0503)     LJMP    APP_USB_CB_h2d_std_dev_01
                                        (0504) ENDIF
                                        (0505) ENDIF
                                        (0506) ;-----------------------------------------------------------------------------
                                        (0507) ;  FUNCTION NAME: USB_CB_h2d_std_dev_03
                                        (0508) ;
                                        (0509) ;  DESCRIPTION:   Set Device Featue
                                        (0510) ;
                                        (0511) ;****************************************************************
                                        (0512) ; STANDARD DEVICE OUT REQUEST: Set_Device_Feature
                                        (0513) ;****************************************************************
                                        (0514) ;
                                        (0515) ; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
                                        (0516) ; bRequest       : SET_FEATURE                    = 03h    
                                        (0517) ; wValue         : FEATURE_SELECTOR               = --xxh  
                                        (0518) ; wIndex         : RESERVED                       = 0000h
                                        (0519) ; wLength        : RESERVED                       = 0000h  
                                        (0520) ; 
                                        (0521) ; The SET_DEVICE_FEATURE request enables a particular feature
                                        (0522) ; on a device. The only feature supported for a device is the 
                                        (0523) ; REMOTE_WAKEUP feature.
                                        (0524) ;
                                        (0525) ;****************************************************************
                                        (0526) ;-----------------------------------------------------------------------------
                                        (0527) ;
                                        (0528) ;  ARGUMENTS:
                                        (0529) ;
                                        (0530) ;  RETURNS:
                                        (0531) ;
                                        (0532) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0533) ;
                                        (0534) ;  THEORY of OPERATION or PROCEDURE:
                                        (0535) ;
                                        (0536) ;-----------------------------------------------------------------------------
                                        (0537) IF (USB_CB_SRC_h2d_std_dev_03 & USB_UM_SUPPLIED)
                                        (0538) export  USB_CB_h2d_std_dev_03
                                        (0539) USB_CB_h2d_std_dev_03:
031E: 5D 52    MOV   A,REG[0x52]        (0540)     MOV     A, REG[USB_EP0DATA+wValueLo]  ; Get the Feature Selector
                                        (0541)                                        ; Check against valid features
                                        (0542)                                        ;  for device receipient
0320: 39 01    CMP   A,0x1              (0543)     CMP     A, USB_DEVICE_REMOTE_WAKEUP  ; Remote wakeup?
0322: A0 07    JZ    0x032A             (0544)     JZ      .remote_wakeup
                                        (0545) 
0324: 39 02    CMP   A,0x2              (0546)     CMP     A, USB_TEST_MODE           ; Test Mode 
0326: A0 08    JZ    0x032F             (0547)     JZ      .test_mode
                                        (0548) ; Flow here for any other selector is invalid for device receipient
0328: 8F 64    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(0549)     JMP     USB_Not_Supported
                                        (0550) ; Jump here to enable remote wake up
                                        (0551) .remote_wakeup:
032A: 2E 0C 02 OR    [USB_DeviceStatus],0x2(0552)     OR      [USB_DeviceStatus], USB_DEVICE_STATUS_REMOTE_WAKEUP
032D: 80 03    JMP   0x0331             (0553)     JMP     .finish
                                        (0554) ; Jump here to enable test mode
                                        (0555) .test_mode:
032F: 8F 5D    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(0556)     JMP     USB_Not_Supported
                                        (0557) .finish:
0331: 81 E3    JMP   0x0515             (0558)     JMP     USB_NoDataStageControlTransfer_Local_Std
                                        (0559) ELSE
                                        (0560) IF (USB_CB_SRC_h2d_std_dev_03 & USB_APP_SUPPLIED)
                                        (0561) export  USB_CB_h2d_std_dev_03
                                        (0562) USB_CB_h2d_std_dev_03:
                                        (0563)     LJMP    APP_USB_CB_h2d_std_dev_03
                                        (0564) ENDIF
                                        (0565) ENDIF
                                        (0566) ;-----------------------------------------------------------------------------
                                        (0567) ;  FUNCTION NAME: USB_CB_h2d_std_dev_05
                                        (0568) ;
                                        (0569) ;  DESCRIPTION:   Set Device Address
                                        (0570) ;
                                        (0571) ;****************************************************************
                                        (0572) ; STANDARD DEVICE OUT REQUEST: Set_Device_Address
                                        (0573) ;****************************************************************
                                        (0574) ;
                                        (0575) ; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
                                        (0576) ; bRequest       : SET_ADDRESS                    = 05h    
                                        (0577) ; wValue         : DEVICE_ADDRESS                 = 00xxh  
                                        (0578) ; wIndex         : RESERVED                       = 0000h
                                        (0579) ; wLength        : RESERVED                       = 0000h  
                                        (0580) ; 
                                        (0581) ; The SET_DEVICE_ADDRESS request sets the USB device address
                                        (0582) ; for all future USB accesses. 
                                        (0583) ;
                                        (0584) ;****************************************************************
                                        (0585) ;
                                        (0586) ;-----------------------------------------------------------------------------
                                        (0587) ;
                                        (0588) ;  ARGUMENTS:
                                        (0589) ;
                                        (0590) ;  RETURNS:
                                        (0591) ;
                                        (0592) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0593) ;
                                        (0594) ;  THEORY of OPERATION or PROCEDURE:
                                        (0595) ;
                                        (0596) ;-----------------------------------------------------------------------------
                                        (0597) 
                                        (0598) IF (USB_CB_SRC_h2d_std_dev_05 & USB_UM_SUPPLIED)
                                        (0599) export  USB_CB_h2d_std_dev_05
                                        (0600) USB_CB_h2d_std_dev_05:
                                        (0601)       
0333: 55 25 01 MOV   [USB_fDataPending],0x1(0602)     MOV     [USB_fDataPending], USB_ADDRESS_CHANGE_PENDING       
0336: 5D 52    MOV   A,REG[0x52]        (0603)     MOV     A, REG[USB_EP0DATA+wValueLo]       
0338: 53 13    MOV   [USB_TransferBuffer],A(0604)     MOV     [USB_TransferBuffer],A       
                                        (0605)                                                    
033A: 81 DA    JMP   0x0515             (0606)     JMP     USB_NoDataStageControlTransfer_Local_Std
                                        (0607) ELSE
                                        (0608) IF (USB_CB_SRC_h2d_std_dev_05 & USB_APP_SUPPLIED)
                                        (0609) export  USB_CB_h2d_std_dev_05
                                        (0610) USB_CB_h2d_std_dev_05:
                                        (0611)     LJMP    APP_USB_CB_h2d_std_dev_05
                                        (0612) ENDIF
                                        (0613) ENDIF
                                        (0614) ;-----------------------------------------------------------------------------
                                        (0615) ;  FUNCTION NAME: USB_CB_h2d_std_dev_09
                                        (0616) ;
                                        (0617) ;  DESCRIPTION:   Set Configuration
                                        (0618) ;
                                        (0619) ;****************************************************************
                                        (0620) ; STANDARD DEVICE OUT REQUEST: Set_Device_Configuration
                                        (0621) ;****************************************************************
                                        (0622) ;
                                        (0623) ; bmRequestType  : (OUT | STANDARD | DEVICE)      = 00h
                                        (0624) ; bRequest       : SET_CONFIGURATION              = 09h    
                                        (0625) ; wValue         : CONFIGURATION_VALUE            = --xxh  
                                        (0626) ; wIndex         : RESERVED                       = 0000h
                                        (0627) ; wLength        : RESERVED                       = 0000h  
                                        (0628) ; 
                                        (0629) ; The SET_DEVICE_CONFIGURATION request selects a device 
                                        (0630) ; configuration to be activated as the current configuration. 
                                        (0631) ;
                                        (0632) ;****************************************************************
                                        (0633) ;-----------------------------------------------------------------------------
                                        (0634) ;
                                        (0635) ;  ARGUMENTS:
                                        (0636) ;
                                        (0637) ;  RETURNS:
                                        (0638) ;
                                        (0639) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0640) ;
                                        (0641) ;  THEORY of OPERATION or PROCEDURE:
                                        (0642) ;
                                        (0643) ;-----------------------------------------------------------------------------
                                        (0644) IF (USB_CB_SRC_h2d_std_dev_09 & USB_UM_SUPPLIED)
                                        (0645) export  USB_CB_h2d_std_dev_09
                                        (0646) USB_CB_h2d_std_dev_09:
033C: 93 E6    CALL  USB_GET_DEVICE_TABLE_ENTRY(0647)     CALL    USB_GET_DEVICE_TABLE_ENTRY ; Get the selected device
033E: 55 26 27 MOV   [USB_t2],0x27      (0648)     MOV     [USB_t2],USB_t1            ; Set the GETWORD destination 
0341: 93 D0    CALL  USB_GETWORD        (0649)     CALL    USB_GETWORD                ; Get the pointer to the CONFIG_LOOKUP table
                                        (0650)                                        ; ITempW has the address
0343: 5D 52    MOV   A,REG[0x52]        (0651)     MOV     A, REG[USB_EP0DATA+wValueLo]  ; Get the configuration number
0345: 53 26    MOV   [USB_t2],A         (0652)     MOV     [USB_t2],A                 ; Save it 
0347: 51 27    MOV   A,[USB_t1]         (0653)     MOV     A, [USB_t1]                ; Get the CONFIG_LOOKUP ROM Address MSB
0349: 58 28    MOV   X,[USB_t0]         (0654)     MOV     X, [USB_t1+1]              ; Get the CONFIG_LOOKUP ROM Address LSB
034B: 28       ROMX                     (0655)     ROMX                               ; First entry is the table size (only a byte)
034C: 3A 26    CMP   A,[USB_t2]         (0656)     CMP     A, [USB_t2]                ; Range check
034E: CF 3E    JC    __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(0657)     JC      USB_Not_Supported
                                        (0658) 
                                        (0659) ; Refactored from the two loops below
0350: 5F 0B 26 MOV   [USB_Configuration],[USB_t2](0660)     MOV     [USB_Configuration],[USB_t2]  ; Save the config number
                                        (0661) 
0353: 3C 26 00 CMP   [USB_t2],0x0       (0662)     CMP     [USB_t2], 0                ; Unconfigure?
0356: A0 25    JZ    0x037C             (0663)     JZ      .unconfigure
                                        (0664) 
                                        (0665) ; Flow here to configure the endpoints
0358: 51 27    MOV   A,[USB_t1]         (0666)     MOV     A, [USB_t1]                ; Get the CONFIG_LOOKUP ROM Address MSB
035A: 58 28    MOV   X,[USB_t0]         (0667)     MOV     X, [USB_t1+1]              ; Get the CONFIG_LOOKUP ROM Address LSB
035C: 75       INC   X                  (0668)     INC     X                          ; Point to the first table entry
035D: 09 00    ADC   A,0x0              (0669)     ADC     A, 0                       ;
035F: 55 26 27 MOV   [USB_t2],0x27      (0670)     MOV    [USB_t2], USB_t1            ; Set up the destination  
0362: 93 AF    CALL  USB_GETWORD        (0671)     CALL    USB_GETWORD                ; Get the pointer to the CONFIG_LOOKUP table
                                        (0672)                                        ; ITempW has the address
0364: 57 00    MOV   X,0x0              (0673)     MOV     X, 0                       ; Start the index at 0, but we INC first
                                        (0674) .configure_next:
0366: 75       INC   X                  (0675)     INC     X                          ; Do the next one
0367: 10       PUSH  X                  (0676)     PUSH    X                          ; Save the endpoint number
0368: 51 27    MOV   A,[USB_t1]         (0677)     MOV     A, [USB_t1]                ; Get the CONFIG_LOOKUP ROM Address MSB
036A: 58 28    MOV   X,[USB_t0]         (0678)     MOV     X, [USB_t1+1]              ; Get the CONFIG_LOOKUP ROM Address LSB
036C: 28       ROMX                     (0679)     ROMX
036D: 76 28    INC   [USB_t0]           (0680)     INC     [USB_t1+1]                 ; Point to the next 
036F: 0E 27 00 ADC   [USB_t1],0x0       (0681)     ADC     [USB_t1], 0                ;
0372: 20       POP   X                  (0682)     POP     X
0373: 90 AC    CALL  0x0421             (0683)     CALL    ConfigureEP                ; X contains the EP number
                                        (0684)                                        ; A contains the EP Direction
0375: 5B       MOV   A,X                (0685)     MOV     A, X                       ; 
0376: 39 02    CMP   A,0x2              (0686)     CMP     A, USB_MAX_EP_NUMBER       ; Configure each of the endpoints
0378: BF ED    JNZ   0x0366             (0687)     JNZ     .configure_next            ; Do another one?
                                        (0688) ; Flow here when we are done
037A: 80 0C    JMP   0x0387             (0689)     JMP     .done
                                        (0690) 
                                        (0691) ; Jump here to unconfigure the endpoints
                                        (0692) .unconfigure:
037C: 57 02    MOV   X,0x2              (0693)     MOV     X, USB_MAX_EP_NUMBER       ; Configure each of the endpoints
                                        (0694) .unconfigure_next:
037E: 56 29 02 MOV   [X+41],0x2         (0695)     MOV     [X+USB_EndpointAPIStatus], NO_EVENT_ALLOWED ; For the API
0381: 63 44 00 MOV   REG[X+0x44],0x0    (0696)     MOV     REG[X+EP0MODE], USB_MODE_DISABLE ; Disable the endpoint
0384: 79       DEC   X                  (0697)     DEC     X                          ; One more down
0385: BF F8    JNZ   0x037E             (0698)     JNZ     .unconfigure_next          ; Don't unconfigure EP0
                                        (0699) .done:
0387: 81 8D    JMP   0x0515             (0700)     JMP     USB_NoDataStageControlTransfer_Local_Std
                                        (0701) ELSE
                                        (0702) IF (USB_CB_SRC_h2d_std_dev_09 & USB_APP_SUPPLIED)
                                        (0703) export  USB_CB_h2d_std_dev_09
                                        (0704) USB_CB_h2d_std_dev_09:
                                        (0705)     LJMP    APP_USB_CB_h2d_std_dev_09
                                        (0706) ENDIF
                                        (0707) ENDIF
                                        (0708) ;-----------------------------------------------------------------------------
                                        (0709) ;  FUNCTION NAME: USB_CB_d2h_std_ifc_00
                                        (0710) ;
                                        (0711) ;  DESCRIPTION:   Get Interface Status
                                        (0712) ;
                                        (0713) ;****************************************************************
                                        (0714) ; STANDARD INTERFACE IN REQUEST: Get_Interface_Status
                                        (0715) ;****************************************************************
                                        (0716) ;
                                        (0717) ; bmRequestType  : (IN | STANDARD | INTERFACE)    = 81h    
                                        (0718) ; bRequest       : GET_STATUS                     = 00h    
                                        (0719) ; wValue         : RESERVED                       = 0000h  
                                        (0720) ; wIndex         : INTERFACE                      = --xxh
                                        (0721) ; wLength        : SIZEOF_INTERFACE_STATUS        = 0002h  
                                        (0722) ; 
                                        (0723) ; The GET_INTERFACE_STATUS request returns status for the 
                                        (0724) ; specified interface.
                                        (0725) ;
                                        (0726) ;****************************************************************
                                        (0727) ;-----------------------------------------------------------------------------
                                        (0728) ;
                                        (0729) ;  ARGUMENTS:
                                        (0730) ;
                                        (0731) ;  RETURNS:
                                        (0732) ;
                                        (0733) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0734) ;
                                        (0735) ;  THEORY of OPERATION or PROCEDURE:
                                        (0736) ;
                                        (0737) ;-----------------------------------------------------------------------------
                                        (0738) IF (USB_CB_SRC_d2h_std_ifc_00 & USB_UM_SUPPLIED)
                                        (0739) .LITERAL
                                        (0740) GetInterfaceStatusTransferDescrTable:
                                        (0741)     TD_START_TABLE  1                  ; One entry
                                        (0742)     TD_ENTRY        USB_DS_RAM, 2, USB_TransferBuffer, NULL_PTR  ; Reuse the transfer buffer
                                        (0743) .ENDLITERAL
                                        (0744) export  USB_CB_d2h_std_ifc_00
                                        (0745) USB_CB_d2h_std_ifc_00:
                                        (0746) 
0392: 55 13 00 MOV   [USB_TransferBuffer],0x0(0747)     MOV     [USB_TransferBuffer], 0    ; Zero the transfer buffer
0395: 55 14 00 MOV   [USB_TransferBuffer+1],0x0(0748)     MOV     [USB_TransferBuffer+1], 0  ; 
                                        (0749) 
0398: 55 26 00 MOV   [USB_t2],0x0       (0750)     MOV     [USB_t2], 0                ; Use the UM temp var--Selector
039B: 50 03    MOV   A,0x3              (0751)     MOV     A,>GetInterfaceStatusTransferDescrTable  ; Get the ROM Address MSB
039D: 57 89    MOV   X,0x89             (0752)     MOV     X,<GetInterfaceStatusTransferDescrTable  ; Get the ROM Address LSB
                                        (0753) 
039F: 81 72    JMP   0x0512             (0754)     JMP     USB_GetTableEntry_Local_Std
                                        (0755) ELSE
                                        (0756) IF (USB_CB_SRC_d2h_std_ifc_00 & USB_APP_SUPPLIED)
                                        (0757) export  USB_CB_d2h_std_ifc_00
                                        (0758) USB_CB_d2h_std_ifc_00:
                                        (0759)     LJMP    APP_USB_CB_d2h_std_ifc_00
                                        (0760) ENDIF
                                        (0761) ENDIF
                                        (0762) ;-----------------------------------------------------------------------------
                                        (0763) ;  FUNCTION NAME: USB_CB_d2h_std_ifc_10
                                        (0764) ;
                                        (0765) ;  DESCRIPTION:   Get Interface
                                        (0766) ;
                                        (0767) ;****************************************************************
                                        (0768) ; STANDARD INTERFACE IN REQUEST: Get_Interface
                                        (0769) ;****************************************************************
                                        (0770) ;
                                        (0771) ; bmRequestType  : (IN | STANDARD | INTERFACE)    = 81h
                                        (0772) ; bRequest       : GET_INTERFACE                  = 0Ah    
                                        (0773) ; wValue         : RESERVED                       = 0000h  
                                        (0774) ; wIndex         : INTERFACE                      = xxxxh
                                        (0775) ; wLength        : SIZEOF_GET_INTERFACE           = 0001h  
                                        (0776) ; 
                                        (0777) ; The GET_INTERFACE request returns the selected alternate 
                                        (0778) ; setting for the specified interface. 
                                        (0779) ;
                                        (0780) ;****************************************************************
                                        (0781) ;-----------------------------------------------------------------------------
                                        (0782) ;
                                        (0783) ;  ARGUMENTS:
                                        (0784) ;
                                        (0785) ;  RETURNS:
                                        (0786) ;
                                        (0787) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0788) ;
                                        (0789) ;  THEORY of OPERATION or PROCEDURE:
                                        (0790) ;
                                        (0791) ;-----------------------------------------------------------------------------
                                        (0792) 
                                        (0793) IF (USB_CB_SRC_d2h_std_ifc_10 & USB_UM_SUPPLIED)
                                        (0794) .LITERAL
                                        (0795) GetInterfaceTransferDescrTable:
                                        (0796)     TD_START_TABLE  1                  ; One entry
                                        (0797)     TD_ENTRY        USB_DS_RAM, 1, USB_TransferBuffer, NULL_PTR  ; Reuse the transfer buffer
                                        (0798) .ENDLITERAL
                                        (0799) export  USB_CB_d2h_std_ifc_10
                                        (0800) USB_CB_d2h_std_ifc_10:
03AA: 5D 54    MOV   A,REG[0x54]        (0801)     MOV     A, REG[USB_EP0DATA+wIndexLo]  ; Get the interface number
03AC: 39 01    CMP   A,0x1              (0802)     CMP     A, 1h                      ; Valid interface number? (UM Parameter: NumInterfaces)
03AE: DE DE    JNC   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(0803)     JNC     USB_Not_Supported
                                        (0804) 
03B0: 5C       MOV   X,A                (0805)     MOV     X, A                       ; The interface number is the index into alternates settings table
                                        (0806) 
03B1: 52 0D    MOV   A,[X+13]           (0807)     MOV     A, [X + USB_InterfaceSetting]  ; Save the current interface setting
03B3: 53 13    MOV   [USB_TransferBuffer],A(0808)     MOV     [USB_TransferBuffer], A    ; into the transfer buffer
                                        (0809) 
03B5: 55 26 00 MOV   [USB_t2],0x0       (0810)     MOV     [USB_t2], 0                ; Use the UM temp var--Selector
03B8: 50 03    MOV   A,0x3              (0811)     MOV     A,>GetInterfaceTransferDescrTable  ; Get the ROM Address MSB
03BA: 57 A1    MOV   X,0xA1             (0812)     MOV     X,<GetInterfaceTransferDescrTable  ; Get the ROM Address LSB
                                        (0813) 
03BC: 81 55    JMP   0x0512             (0814)     JMP     USB_GetTableEntry_Local_Std
                                        (0815) ELSE
                                        (0816) IF (USB_CB_SRC_d2h_std_ifc_10 & USB_APP_SUPPLIED)
                                        (0817) export  USB_CB_d2h_std_ifc_10
                                        (0818) USB_CB_d2h_std_ifc_10:
                                        (0819)     LJMP    APP_USB_CB_d2h_std_ifc_10
                                        (0820) ENDIF
                                        (0821) ENDIF
                                        (0822) ;-----------------------------------------------------------------------------
                                        (0823) ;  FUNCTION NAME: USB_CB_d2h_std_ep_00
                                        (0824) ;
                                        (0825) ;  DESCRIPTION:   Get Endpoint Status
                                        (0826) ;
                                        (0827) ;****************************************************************
                                        (0828) ; STANDARD ENDPOINT IN REQUEST: Get_Endpoint_Status
                                        (0829) ;****************************************************************
                                        (0830) ;
                                        (0831) ; bmRequestType  : (IN | STANDARD | ENDPOINT)     = 82h    
                                        (0832) ; bRequest       : GET_STATUS                     = 00h    
                                        (0833) ; wValue         : RESERVED                       = 0000h  
                                        (0834) ; wIndex         : ENDPOINT                       = 00xxh
                                        (0835) ; wLength        : SIZEOF_ENDPOINT_STATUS         = 0002h  
                                        (0836) ; 
                                        (0837) ; The GET_ENDPOINT_STATUS request returns status for the specified 
                                        (0838) ; endpoint.
                                        (0839) ;
                                        (0840) ;****************************************************************
                                        (0841) ;-----------------------------------------------------------------------------
                                        (0842) ;
                                        (0843) ;  ARGUMENTS:
                                        (0844) ;
                                        (0845) ;  RETURNS:
                                        (0846) ;
                                        (0847) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0848) ;
                                        (0849) ;  THEORY of OPERATION or PROCEDURE:
                                        (0850) ;
                                        (0851) ;-----------------------------------------------------------------------------
                                        (0852) IF (USB_CB_SRC_d2h_std_ep_00 & USB_UM_SUPPLIED)
                                        (0853) export  USB_CB_d2h_std_ep_00
                                        (0854) USB_CB_d2h_std_ep_00:
03BE: 5D 54    MOV   A,REG[0x54]        (0855)     MOV     A, REG[USB_EP0DATA+wIndexLo]  ; Get the endpoint number
03C0: 21 7F    AND   A,0x7F             (0856)     AND     A, ~USB_DIR_IN             ; Strip off the direction bit
03C2: 39 03    CMP   A,0x3              (0857)     CMP     A, USB_NUM_ENDPOINTS       ; Range check
03C4: DE C8    JNC   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(0858)     JNC     USB_Not_Supported
                                        (0859) 
03C6: 5C       MOV   X,A                (0860)     MOV     X, A                       ; The endpoint number is the index
                                        (0861) 
03C7: 55 26 00 MOV   [USB_t2],0x0       (0862)     MOV     [USB_t2], 0                ; Use the UM temp var--Selector
                                        (0863) 
03CA: 55 14 00 MOV   [USB_TransferBuffer+1],0x0(0864)     MOV     [USB_TransferBuffer + 1], 0  ; Use the UM Transfer Buffer
03CD: 52 0E    MOV   A,[X+14]           (0865)     MOV     A, [X + USB_EndpointStatus]  ; Get the status
03CF: 53 13    MOV   [USB_TransferBuffer],A(0866)     MOV     [USB_TransferBuffer], A    ; Save it in the report
                                        (0867) 
03D1: 50 02    MOV   A,0x2              (0868)     MOV     A,>GetStatusTransferDescrTable  ; Get the ROM Address MSB
03D3: 57 94    MOV   X,0x94             (0869)     MOV     X,<GetStatusTransferDescrTable  ; Get the ROM Address LSB
                                        (0870) 
03D5: 81 3C    JMP   0x0512             (0871)     JMP     USB_GetTableEntry_Local_Std
                                        (0872) ELSE
                                        (0873) IF (USB_CB_SRC_d2h_std_ep_00 & USB_APP_SUPPLIED)
                                        (0874) export  USB_CB_d2h_std_ep_00
                                        (0875) USB_CB_d2h_std_ep_00:
                                        (0876)     LJMP    APP_USB_CB_d2h_std_ep_00
                                        (0877) ENDIF
                                        (0878) ENDIF
                                        (0879) 
                                        (0880) ;-----------------------------------------------------------------------------
                                        (0881) ;  FUNCTION NAME: USB_CB_h2d_std_ep_01
                                        (0882) ;
                                        (0883) ;  DESCRIPTION:   Clear Endpoint Feature
                                        (0884) ;
                                        (0885) ;****************************************************************
                                        (0886) ; STANDARD ENDPOINT OUT REQUEST: Clear_Endpoint_Feature
                                        (0887) ;****************************************************************
                                        (0888) ;
                                        (0889) ; bmRequestType  : (OUT | STANDARD | ENDPOINT)    = 02h
                                        (0890) ; bRequest       : CLEAR_FEATURE                  = 01h    
                                        (0891) ; wValue         : FEATURE_SELECTOR               = --xxh  
                                        (0892) ; wIndex         : ENDPOINT                       = 00xxh
                                        (0893) ; wLength        : RESERVED                       = 0000h  
                                        (0894) ; 
                                        (0895) ; The CLEAR_ENDPOINT_FEATURE request disables a particular 
                                        (0896) ; feature for an endpoint. 
                                        (0897) ;
                                        (0898) ; The only feature supported for an endpoint is the EP_HALT 
                                        (0899) ; feature.
                                        (0900) ;
                                        (0901) ;****************************************************************
                                        (0902) ;-----------------------------------------------------------------------------
                                        (0903) ;
                                        (0904) ;  ARGUMENTS:
                                        (0905) ;
                                        (0906) ;  RETURNS:
                                        (0907) ;
                                        (0908) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0909) ;
                                        (0910) ;  THEORY of OPERATION or PROCEDURE:
                                        (0911) ;
                                        (0912) ;-----------------------------------------------------------------------------
                                        (0913) IF (USB_CB_SRC_h2d_std_ep_01 & USB_UM_SUPPLIED)
                                        (0914) export  USB_CB_h2d_std_ep_01
                                        (0915) USB_CB_h2d_std_ep_01:
03D7: 5D 52    MOV   A,REG[0x52]        (0916)     MOV     A, REG[USB_EP0DATA+wValueLo]  ; Get the feature selector
03D9: 39 00    CMP   A,0x0              (0917)     CMP     A, USB_ENDPOINT_HALT       ; Halt is the only selector defined for endpoints
03DB: BE B1    JNZ   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(0918)     JNZ     USB_Not_Supported
                                        (0919) 
03DD: 5D 54    MOV   A,REG[0x54]        (0920)     MOV     A, REG[USB_EP0DATA+wIndexLo]  ; Get the Endpoint number
03DF: 21 7F    AND   A,0x7F             (0921)     AND     A, ~USB_DIR_IN             ; Strip off the direction bit
03E1: 39 00    CMP   A,0x0              (0922)     CMP     A, 0                       ; Since we can't halt the Control Endpoint
03E3: A0 16    JZ    0x03FA             (0923)     JZ      .done
                                        (0924) 
03E5: 39 03    CMP   A,0x3              (0925)     CMP     A, USB_NUM_ENDPOINTS       ; Range check
03E7: DE A5    JNC   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(0926)     JNC     USB_Not_Supported
                                        (0927) 
03E9: 5C       MOV   X,A                (0928)     MOV     X, A                       ; Endpoint number is the index
03EA: 27 0E FE AND   [X+14],0xFE        (0929)     AND     [X+USB_EndpointStatus], ~USB_ENDPOINT_STATUS_HALT  ; Clear the endpoint halt
                                        (0930) 
03ED: 49 54 80 TST   REG[0x54],0x80     (0931)     TST     REG[USB_EP0DATA+wIndexLo], USB_DIR_IN  ; IN or OUT endpoint?
03F0: B0 06    JNZ   0x03F7             (0932)     JNZ     .in
                                        (0933) 
03F2: 63 44 08 MOV   REG[X+0x44],0x8    (0934)     MOV     REG[X + USB_EP0MODE], USB_MODE_NAK_OUT  ; NAK the endpoint
03F5: 80 04    JMP   0x03FA             (0935)     JMP     .done    
                                        (0936) .in:
03F7: 63 44 0C MOV   REG[X+0x44],0xC    (0937)     MOV     REG[X + USB_EP0MODE], USB_MODE_NAK_IN  ; NAK the endpoint
                                        (0938) .done:        
03FA: 81 1A    JMP   0x0515             (0939)     JMP     USB_NoDataStageControlTransfer_Local_Std
                                        (0940) ELSE
                                        (0941) IF (USB_CB_SRC_h2d_std_ep_01 & USB_APP_SUPPLIED)
                                        (0942) export  USB_CB_h2d_std_ep_01
                                        (0943) USB_CB_h2d_std_ep_01:
                                        (0944)     LJMP    APP_USB_CB_h2d_std_ep_01
                                        (0945) ENDIF
                                        (0946) ENDIF
                                        (0947) ;-----------------------------------------------------------------------------
                                        (0948) ;  FUNCTION NAME: USB_CB_h2d_std_ep_03
                                        (0949) ;
                                        (0950) ;  DESCRIPTION:   Set Endpoint Feature
                                        (0951) ;
                                        (0952) ;****************************************************************
                                        (0953) ; STANDARD ENDPOINT OUT REQUEST: Set_Endpoint_Feature
                                        (0954) ;****************************************************************
                                        (0955) ;
                                        (0956) ; bmRequestType  : (OUT | STANDARD | ENDPOINT)    = 02h
                                        (0957) ; bRequest       : SET_FEATURE                    = 03h    
                                        (0958) ; wValue         : FEATURE_SELECTOR               = --xxh  
                                        (0959) ; wIndex         : ENDPOINT                       = 00xxh
                                        (0960) ; wLength        : RESERVED                       = 0000h  
                                        (0961) ; 
                                        (0962) ; The SET_ENDPOINT_FEATURE request enables a particular feature
                                        (0963) ; for a specific endpoint. The only feature supported for an 
                                        (0964) ; endpoint is the EP_HALT feature.
                                        (0965) ; 
                                        (0966) ;****************************************************************
                                        (0967) ;-----------------------------------------------------------------------------
                                        (0968) ;
                                        (0969) ;  ARGUMENTS:
                                        (0970) ;
                                        (0971) ;  RETURNS:
                                        (0972) ;
                                        (0973) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0974) ;
                                        (0975) ;  THEORY of OPERATION or PROCEDURE:
                                        (0976) ;
                                        (0977) ;-----------------------------------------------------------------------------
                                        (0978) IF (USB_CB_SRC_h2d_std_ep_03 & USB_UM_SUPPLIED)
                                        (0979) export  USB_CB_h2d_std_ep_03
                                        (0980) USB_CB_h2d_std_ep_03:
03FC: 5D 52    MOV   A,REG[0x52]        (0981)     MOV     A, REG[USB_EP0DATA+wValueLo]  ; Get the feature selector
03FE: 39 00    CMP   A,0x0              (0982)     CMP     A, USB_ENDPOINT_HALT       ; Halt is the only selector defined for endpoints
0400: BE 8C    JNZ   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(0983)     JNZ     USB_Not_Supported
                                        (0984) 
0402: 5D 54    MOV   A,REG[0x54]        (0985)     MOV     A, REG[USB_EP0DATA+wIndexLo]  ; Get the Endpoint number
0404: 21 7F    AND   A,0x7F             (0986)     AND     A, ~USB_DIR_IN             ; Strip off the direction bit
0406: 39 00    CMP   A,0x0              (0987)     CMP     A, 0                       ; Never halt the Control Endpoint
0408: A0 16    JZ    0x041F             (0988)     JZ      .done
                                        (0989) 
040A: 39 03    CMP   A,0x3              (0990)     CMP     A, USB_NUM_ENDPOINTS       ; Range check
040C: DE 80    JNC   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(0991)     JNC     USB_Not_Supported
                                        (0992) 
040E: 5C       MOV   X,A                (0993)     MOV     X, A                       ; Endpoint number is the index
                                        (0994) 
040F: 2F 0E 01 OR    [X+14],0x1         (0995)     OR      [X+USB_EndpointStatus], USB_ENDPOINT_STATUS_HALT  ; Halt the endpoint
                                        (0996) 
0412: 49 54 80 TST   REG[0x54],0x80     (0997)     TST     REG[USB_EP0DATA+wIndexLo], USB_DIR_IN  ; IN or OUT endpoint?
0415: B0 06    JNZ   0x041C             (0998)     JNZ     .in
                                        (0999) 
0417: 63 44 89 MOV   REG[X+0x44],0x89   (1000)     MOV     REG[X + USB_EP0MODE], USB_MODE_STALL_DATA_EP | USB_MODE_ACK_OUT  ; Stall the endpoint
041A: 80 04    JMP   0x041F             (1001)     JMP     .done    
                                        (1002) .in:
041C: 63 44 8D MOV   REG[X+0x44],0x8D   (1003)     MOV     REG[X + USB_EP0MODE], USB_MODE_STALL_DATA_EP | USB_MODE_ACK_IN  ; Stall the endpoint
                                        (1004) .done:        
041F: 80 F5    JMP   0x0515             (1005)     JMP     USB_NoDataStageControlTransfer_Local_Std
                                        (1006) ELSE
                                        (1007) IF (USB_CB_SRC_h2d_std_ep_03 & USB_APP_SUPPLIED)
                                        (1008) export  USB_CB_h2d_std_ep_03
                                        (1009) USB_CB_h2d_std_ep_03:
                                        (1010)     LJMP    APP_USB_CB_h2d_std_ep_03
                                        (1011) ENDIF
                                        (1012) ENDIF
                                        (1013) ;-----------------------------------------------------------------------------
                                        (1014) ;  FUNCTION NAME: ConfigureEP
                                        (1015) ;
                                        (1016) ;  DESCRIPTION:   Configure an endpoint
                                        (1017) ;
                                        (1018) ;  ARGUMENTS:    A contains the endpoint direction
                                        (1019) ;                X contains the endpoint number
                                        (1020) ;
                                        (1021) ;  RETURNS:
                                        (1022) ;
                                        (1023) ;  SIDE EFFECTS:  The A REGISTER IS VOLATILE.  X REGISTER IS MAINTAINED!
                                        (1024) ;
                                        (1025) ;  THEORY of OPERATION or PROCEDURE:
                                        (1026) ;
                                        (1027) ;-----------------------------------------------------------------------------
                                        (1028) ConfigureEP:
0421: 39 7F    CMP   A,0x7F             (1029)     CMP     A, USB_DIR_UNUSED          ; Is this endpoint unused?
0423: B0 02    JNZ   0x0426             (1030)     JNZ     .enable                    ; Only enable it if it is used
0425: 7F       RET                      (1031)     RET                                ; Quick exit if this endpoint is unused
                                        (1032) 
                                        (1033) ; Jump here to enable an endpoint
                                        (1034) .enable:
0426: 08       PUSH  A                  (1035)     PUSH    A                          ; Save the endpoint direction
0427: 5B       MOV   A,X                (1036)     MOV     A, X                       ; We are using a JACC to dispatch to enable the interrupt
0428: 64       ASL   A                  (1037)     ASL     A                          ;  
0429: E0 01    JACC  0x042B             (1038)     JACC    .EP_INT_ENABLE             ;  
                                        (1039) .EP_INT_ENABLE:
042B: 80 05    JMP   0x0431             (1040)     JMP     .EP0IntEnable              ; Enable EP0
042D: 80 08    JMP   0x0436             (1041)     JMP     .EP1IntEnable              ; Enable EP1
042F: 80 0B    JMP   0x043B             (1042)     JMP     .EP2IntEnable              ; Enable EP2
0431: 43 E1 01 OR    REG[0xE1],0x1      
                                        (1043) ; Jump here to enable EP0 Interrupts
                                        (1044) .EP0IntEnable:
                                        (1045)     M8C_EnableIntMask INT_MSK1, INT_MSK1_USB_EP0
0434: 80 09    JMP   0x043E             (1046)     JMP     .cont
0436: 43 E1 02 OR    REG[0xE1],0x2      
                                        (1047) .EP1IntEnable:
                                        (1048)     M8C_EnableIntMask INT_MSK1, INT_MSK1_USB_EP1
0439: 80 04    JMP   0x043E             (1049)     JMP     .cont
043B: 43 E1 04 OR    REG[0xE1],0x4      
                                        (1050) .EP2IntEnable:
                                        (1051)     M8C_EnableIntMask INT_MSK1, INT_MSK1_USB_EP2
                                        (1052) ; Jump or flow here to continue configuring the endpoint    
                                        (1053) .cont:
                                        (1054) 
043E: 5B       MOV   A,X                (1055)     MOV     A, X
043F: F3 7E    INDEX USB_USB_EP_BIT_LOOKUP(1056)     INDEX   USB_USB_EP_BIT_LOOKUP
0441: 31 FF    XOR   A,0xFF             (1057)     XOR     A, FFh
0443: 24 24    AND   [USB_EPDataToggle],A(1058)     AND     [USB_EPDataToggle], A ; Clear the data toggle
                                        (1059) 
0445: 18       POP   A                  (1060)     POP     A                          ; Get the endpoint direction back
0446: 21 80    AND   A,0x80             (1061)     AND     A, USB_DIR_IN              ; Is it an IN endpoint?
0448: B0 08    JNZ   0x0451             (1062)     JNZ     .in                        ; Jump on IN
                                        (1063) ; Flow here for an OUT Endpoint
044A: 63 44 08 MOV   REG[X+0x44],0x8    (1064)     MOV     REG[X+EP0MODE], USB_MODE_NAK_OUT ; NAK the endpoint
044D: 56 29 00 MOV   [X+41],0x0         (1065)     MOV     [X+USB_EndpointAPIStatus], NO_EVENT_PENDING ; For the API
0450: 7F       RET                      (1066)     RET
                                        (1067) ; Jump here for an IN Endpoint
                                        (1068) .in:
0451: 63 44 0C MOV   REG[X+0x44],0xC    (1069)     MOV     REG[X+EP0MODE], USB_MODE_NAK_IN ; NAK the endpoint
0454: 56 29 01 MOV   [X+41],0x1         (1070)     MOV     [X+USB_EndpointAPIStatus], EVENT_PENDING ; For the API
0457: 7F       RET                      (1071)     RET
                                        (1072) ;-----------------------------------------------------------------------------
                                        (1073) ;  USB 2nd Tier Dispactch Jump Tables for Standard Requests (based on bRequest)
                                        (1074) ;-----------------------------------------------------------------------------
                                        (1075) ;  FUNCTION NAME: ;  USB 2nd Tier Dispactch Jump Table
                                        (1076) ;
                                        (1077) ;  DESCRIPTION:   The following tables dispatch to the Standard request handler
                                        (1078) ;                 functions.  (Assumes bmRequestType(5:6) is 0, Standard)
                                        (1079) ;
                                        (1080) ;-----------------------------------------------------------------------------
                                        (1081) ;
                                        (1082) ;  ARGUMENTS:
                                        (1083) ;
                                        (1084) ;  RETURNS:
                                        (1085) ;
                                        (1086) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (1087) ;
                                        (1088) ;  THEORY of OPERATION or PROCEDURE:
                                        (1089) ;
                                        (1090) ;-----------------------------------------------------------------------------
                                        (1091) USB_DT_d2h_std_dev:
                                        (1092) ;-----------------------------------------------------------------------------
0458: 8E 44    JMP   USB_CB_d2h_std_dev_00(1093)     jmp     USB_CB_d2h_std_dev_00
045A: 8E 32    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1094)     jmp     USB_CB_d2h_std_dev_01
045C: 8E 30    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1095)     jmp     USB_CB_d2h_std_dev_02
045E: 8E 2E    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1096)     jmp     USB_CB_d2h_std_dev_03
0460: 8E 2C    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1097)     jmp     USB_CB_d2h_std_dev_04
0462: 8E 2A    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1098)     jmp     USB_CB_d2h_std_dev_05
0464: 8E 47    JMP   USB_CB_d2h_std_dev_06(1099)     jmp     USB_CB_d2h_std_dev_06
0466: 8E 26    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1100)     jmp     USB_CB_d2h_std_dev_07
0468: 8E A1    JMP   USB_CB_d2h_std_dev_08(1101)     jmp     USB_CB_d2h_std_dev_08
                                        (1102) 
                                        (1103) USB_DT_d2h_std_dev_End:
                                        (1104) USB_DT_d2h_std_dev_Size: equ (USB_DT_d2h_std_dev_End-USB_DT_d2h_std_dev) / 2
                                        (1105) USB_DT_d2h_std_dev_Dispatch::
046A: 5D 51    MOV   A,REG[0x51]        (1106)     MOV    A, REG[USB_EP0DATA + bRequest]
046C: 39 09    CMP   A,0x9              
046E: D0 04    JNC   0x0473             
0470: 64       ASL   A                  
0471: EF E6    JACC  0x0458             
0473: 8E 19    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...
                                        (1107)     DISPATCHER USB_DT_d2h_std_dev, USB_DT_d2h_std_dev_Size, USB_Not_Supported 
                                        (1108) ;-----------------------------------------------------------------------------
                                        (1109) USB_DT_h2d_std_dev:
                                        (1110) ;-----------------------------------------------------------------------------
0475: 8E 17    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1111)     jmp     USB_CB_h2d_std_dev_00
0477: 8E 9B    JMP   USB_CB_h2d_std_dev_01(1112)     jmp     USB_CB_h2d_std_dev_01
0479: 8E 13    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1113)     jmp     USB_CB_h2d_std_dev_02
047B: 8E A2    JMP   USB_CB_h2d_std_dev_03(1114)     jmp     USB_CB_h2d_std_dev_03
047D: 8E 0F    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1115)     jmp     USB_CB_h2d_std_dev_04
047F: 8E B3    JMP   USB_CB_h2d_std_dev_05(1116)     jmp     USB_CB_h2d_std_dev_05
0481: 8E 0B    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1117)     jmp     USB_CB_h2d_std_dev_06
0483: 8E 09    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1118)     jmp     USB_CB_h2d_std_dev_07
0485: 8E 07    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1119)     jmp     USB_CB_h2d_std_dev_08
0487: 8E B4    JMP   USB_CB_h2d_std_dev_09(1120)     jmp     USB_CB_h2d_std_dev_09
                                        (1121) 
                                        (1122) USB_DT_h2d_std_dev_End:
                                        (1123) USB_DT_h2d_std_dev_Size: equ (USB_DT_h2d_std_dev_End-USB_DT_h2d_std_dev) / 2
                                        (1124) USB_DT_h2d_std_dev_Dispatch::
                                        (1125) 
0489: 5D 51    MOV   A,REG[0x51]        (1126)     MOV     A, REG[USB_EP0DATA + bRequest]
048B: 39 0A    CMP   A,0xA              
048D: D0 04    JNC   0x0492             
048F: 64       ASL   A                  
0490: EF E4    JACC  0x0475             
0492: 8D FA    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...
                                        (1127)     DISPATCHER USB_DT_h2d_std_dev, USB_DT_h2d_std_dev_Size, USB_Not_Supported 
                                        (1128) 
                                        (1129) ;-----------------------------------------------------------------------------
                                        (1130) USB_DT_d2h_std_ifc:
                                        (1131) ;-----------------------------------------------------------------------------
0494: 8E FD    JMP   USB_CB_d2h_std_ifc_00(1132)     jmp     USB_CB_d2h_std_ifc_00
0496: 8D F6    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1133)     jmp     USB_CB_d2h_std_ifc_01
0498: 8D F4    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1134)     jmp     USB_CB_d2h_std_ifc_02
049A: 8D F2    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1135)     jmp     USB_CB_d2h_std_ifc_03
049C: 8D F0    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1136)     jmp     USB_CB_d2h_std_ifc_04
049E: 8D EE    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1137)     jmp     USB_CB_d2h_std_ifc_05
04A0: 8D EC    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1138)     jmp     USB_CB_d2h_std_ifc_06
04A2: 8D EA    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1139)     jmp     USB_CB_d2h_std_ifc_07
04A4: 8D E8    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1140)     jmp     USB_CB_d2h_std_ifc_08
04A6: 8D E6    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1141)     jmp     USB_CB_d2h_std_ifc_09
04A8: 8F 01    JMP   USB_CB_d2h_std_ifc_10(1142)     jmp     USB_CB_d2h_std_ifc_10
                                        (1143) USB_DT_d2h_std_ifc_End:
                                        (1144) USB_DT_d2h_std_ifc_Size: equ (USB_DT_d2h_std_ifc_End-USB_DT_d2h_std_ifc) / 2
                                        (1145) USB_DT_d2h_std_ifc_Dispatch::
04AA: 3C 0B 00 CMP   [USB_Configuration],0x0(1146)     CMP     [USB_Configuration], 0     ; Is the device configured?
04AD: B0 03    JNZ   0x04B1             (1147)     JNZ     .configured                ; Jump on configured
04AF: 8D DD    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1148)     JMP    _USB_Not_Supported          ; Stall the request if not configured
                                        (1149) ; Jump here if the device is configured
                                        (1150) .configured:
04B1: 5D 51    MOV   A,REG[0x51]        (1151)     MOV     A, REG[USB_EP0DATA + bRequest]
04B3: 39 0B    CMP   A,0xB              
04B5: D0 04    JNC   0x04BA             
04B7: 64       ASL   A                  
04B8: EF DB    JACC  0x0494             
04BA: 8D D2    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...
                                        (1152)     DISPATCHER USB_DT_d2h_std_ifc, USB_DT_d2h_std_ifc_Size, USB_Not_Supported 
                                        (1153) 
                                        (1154) ;-----------------------------------------------------------------------------
                                        (1155) USB_DT_h2d_std_ifc:
                                        (1156) ;-----------------------------------------------------------------------------
04BC: 8D D0    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1157)     jmp     USB_CB_h2d_std_ifc_00
                                        (1158) 
                                        (1159) USB_DT_h2d_std_ifc_End:
                                        (1160) USB_DT_h2d_std_ifc_Size: equ (USB_DT_h2d_std_ifc_End-USB_DT_h2d_std_ifc) / 2
                                        (1161) USB_DT_h2d_std_ifc_Dispatch::
04BE: 3C 0B 00 CMP   [USB_Configuration],0x0(1162)     CMP     [USB_Configuration], 0     ; Is the device configured?
04C1: B0 03    JNZ   0x04C5             (1163)     JNZ     .configured                ; Jump on configured
04C3: 8D C9    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1164)     JMP    _USB_Not_Supported          ; Stall the request if not configured
                                        (1165) ; Jump here if the device is configured
                                        (1166) .configured:
04C5: 5D 51    MOV   A,REG[0x51]        (1167)     MOV     A, REG[USB_EP0DATA + bRequest]
04C7: 39 01    CMP   A,0x1              
04C9: D0 04    JNC   0x04CE             
04CB: 64       ASL   A                  
04CC: EF EF    JACC  0x04BC             
04CE: 8D BE    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...
                                        (1168)     DISPATCHER USB_DT_h2d_std_ifc, USB_DT_h2d_std_ifc_Size, USB_Not_Supported 
                                        (1169) 
                                        (1170) ;-----------------------------------------------------------------------------
                                        (1171) USB_DT_d2h_std_ep:
                                        (1172) ;-----------------------------------------------------------------------------
04D0: 8E ED    JMP   USB_CB_d2h_std_ep_00(1173)     jmp     USB_CB_d2h_std_ep_00
                                        (1174) 
                                        (1175) USB_DT_d2h_std_ep_End:
                                        (1176) USB_DT_d2h_std_ep_Size: equ (USB_DT_d2h_std_ep_End-USB_DT_d2h_std_ep) / 2
                                        (1177) USB_DT_d2h_std_ep_Dispatch::
04D2: 3C 0B 00 CMP   [USB_Configuration],0x0(1178)     CMP     [USB_Configuration], 0     ; Is the device configured?
04D5: B0 0D    JNZ   0x04E3             (1179)     JNZ     .configured                ; Jump on configured
                                        (1180) 
04D7: 5D 55    MOV   A,REG[0x55]        (1181)     MOV     A, REG[USB_EP0DATA + wIndexHi] ; Is the request for EP0?
04D9: 53 26    MOV   [USB_t2],A         (1182)     MOV     [USB_t2], A                ; Use the UM temp var--Selector
04DB: 5D 54    MOV   A,REG[0x54]        (1183)     MOV     A, REG[USB_EP0DATA + wIndexLo] ;
04DD: 2C 26    OR    [USB_t2],A         (1184)     OR      [USB_t2], A                ; Use the UM temp var--Selector
04DF: A0 03    JZ    0x04E3             (1185)     JZ      .ep0_request
                                        (1186) 
04E1: 8D AB    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1187)     JMP    _USB_Not_Supported          ; Stall the request if not configured
                                        (1188) ; Jump here if the device is configured or EP0 request
                                        (1189) .configured:
                                        (1190) .ep0_request:
04E3: 5D 51    MOV   A,REG[0x51]        (1191)     MOV     A, REG[USB_EP0DATA + bRequest]
04E5: 39 01    CMP   A,0x1              
04E7: D0 04    JNC   0x04EC             
04E9: 64       ASL   A                  
04EA: EF E5    JACC  0x04D0             
04EC: 8D A0    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...
                                        (1192)     DISPATCHER USB_DT_d2h_std_ep, USB_DT_d2h_std_ep_Size, USB_Not_Supported 
                                        (1193) 
                                        (1194) ;-----------------------------------------------------------------------------
                                        (1195) USB_DT_h2d_std_ep:
                                        (1196) ;-----------------------------------------------------------------------------
04EE: 8D 9E    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1197)     jmp     USB_CB_h2d_std_ep_00
04F0: 8E E6    JMP   USB_CB_h2d_std_ep_01(1198)     jmp     USB_CB_h2d_std_ep_01
04F2: 8D 9A    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1199)     jmp     USB_CB_h2d_std_ep_02
04F4: 8F 07    JMP   USB_CB_h2d_std_ep_03(1200)     jmp     USB_CB_h2d_std_ep_03
                                        (1201) 
                                        (1202) USB_DT_h2d_std_ep_End:
                                        (1203) USB_DT_h2d_std_ep_Size: equ (USB_DT_h2d_std_ep_End-USB_DT_h2d_std_ep) / 2
                                        (1204) USB_DT_h2d_std_ep_Dispatch::
04F6: 3C 0B 00 CMP   [USB_Configuration],0x0(1205)     CMP     [USB_Configuration], 0     ; Is the device configured?
04F9: B0 0D    JNZ   0x0507             (1206)     JNZ     .configured                ; Jump on configured
                                        (1207) 
04FB: 5D 55    MOV   A,REG[0x55]        (1208)     MOV     A, REG[USB_EP0DATA + wIndexHi] ; Is the request for EP0?
04FD: 53 26    MOV   [USB_t2],A         (1209)     MOV     [USB_t2], A                ; Use the UM temp var--Selector
04FF: 5D 54    MOV   A,REG[0x54]        (1210)     MOV     A, REG[USB_EP0DATA + wIndexLo] ;
0501: 2C 26    OR    [USB_t2],A         (1211)     OR      [USB_t2], A                ; Use the UM temp var--Selector
0503: A0 03    JZ    0x0507             (1212)     JZ      .ep0_request
                                        (1213) 
0505: 8D 87    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(1214)     JMP    _USB_Not_Supported          ; Stall the request if not configured
                                        (1215) ; Jump here if the device is configured or EP0 request
                                        (1216) .configured:
                                        (1217) .ep0_request:
0507: 5D 51    MOV   A,REG[0x51]        (1218)     MOV     A, REG[USB_EP0DATA + bRequest]
0509: 39 04    CMP   A,0x4              
050B: D0 04    JNC   0x0510             
050D: 64       ASL   A                  
050E: EF DF    JACC  0x04EE             
0510: 8D 7C    JMP   __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...
                                        (1219)     DISPATCHER USB_DT_h2d_std_ep, USB_DT_h2d_std_ep_Size, USB_Not_Supported 
                                        (1220) 
                                        (1221) USB_GetTableEntry_Local_Std:
0512: 7D 06 DF LJMP  USB_GetTableEntry  (1222)     LJMP    USB_GetTableEntry
                                        (1223) 
                                        (1224) USB_NoDataStageControlTransfer_Local_Std:
0515: 7D 05 E1 LJMP  USB_InitNoDataStageControlTransfer|USB_NoDataStageControlTransfer(1225)     LJMP    USB_NoDataStageControlTransfer
                                        (1226) 
                                        (1227) ;-----------------------------------------------
                                        (1228) ; Add custom application code for routines 
                                        (1229) ; redefined by USB_APP_SUPPLIED in USB_HID.INC
                                        (1230) ;-----------------------------------------------
                                        (1231) 
                                        (1232)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                        (1233)    ;---------------------------------------------------
                                        (1234)    ; Insert your custom code below this banner
                                        (1235)    ;---------------------------------------------------
                                        (1236) 
                                        (1237)    ;---------------------------------------------------
                                        (1238)    ; Insert your custom code above this banner
                                        (1239)    ;---------------------------------------------------
                                        (1240)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (1241) 
                                        (1242) ; End of File USB_std.asm
FILE: lib\usb_drv.asm                   (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: USB_drv.asm
                                        (0004) ;;   Version: 1.90, Updated on 2015/3/4 at 22:20:18
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: USB Device User Module control endpoint driver
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API
                                        (0013) ;;        function returns. Even though these registers may be preserved now,
                                        (0014) ;;        there is no guarantee they will be preserved in future releases.
                                        (0015) ;;-----------------------------------------------------------------------------
                                        (0016) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0017) ;;*****************************************************************************
                                        (0018) ;;*****************************************************************************
                                        (0019) 
                                        (0020) include "m8c.inc"
                                        (0021) include "USB_macros.inc"
                                        (0022) include "USB.inc"
                                        (0023) 
                                        (0024) ;-----------------------------------------------
                                        (0025) ;  Global Symbols
                                        (0026) ;-----------------------------------------------
                                        (0027) export  _USB_EP0_ISR
                                        (0028) export  USB_InitControlRead
                                        (0029) export  USB_InitControlWrite
                                        (0030) export  USB_InitNoDataStageControlTransfer
                                        (0031) export  USB_NoDataStageControlTransfer
                                        (0032) 
                                        (0033) ;-----------------------------------------------
                                        (0034) ;  Macro Definitions
                                        (0035) ;-----------------------------------------------
                                        (0036) 
                                        (0037) ;-----------------------------------------------
                                        (0038) ;  Constant Definitions
                                        (0039) ;-----------------------------------------------
                                        (0040) 
                                        (0041) ;-----------------------------------------------
                                        (0042) ; Variable Allocation
                                        (0043) ;-----------------------------------------------
                                        (0044) AREA bss (RAM,REL)
                                        (0045) ;----------------------------------------------------------------------------
                                        (0046) ; Current Device
                                        (0047) ;----------------------------------------------------------------------------
                                        (0048) EXPORT USB_bCurrentDevice
                                        (0049) USB_bCurrentDevice:                     BLK   1    ;  Current Device
                                        (0050) ;----------------------------------------------------------------------------
                                        (0051) ; Current Configuration
                                        (0052) ;----------------------------------------------------------------------------
                                        (0053) EXPORT USB_Configuration, _USB_Configuration
                                        (0054) _USB_Configuration:
                                        (0055)  USB_Configuration:                     BLK   1    ;  Current Configuration
                                        (0056) ;----------------------------------------------------------------------------
                                        (0057) ; Current Device Status
                                        (0058) ;----------------------------------------------------------------------------
                                        (0059) EXPORT USB_DeviceStatus
                                        (0060)  USB_DeviceStatus:                      BLK   1    ;  Current Device Status
                                        (0061) ;----------------------------------------------------------------------------
                                        (0062) ; Interface Setting
                                        (0063) ;----------------------------------------------------------------------------
                                        (0064) EXPORT USB_InterfaceSetting
                                        (0065)  USB_InterfaceSetting:                  BLK   1h    ; Interface Setting
                                        (0066) ;----------------------------------------------------------------------------
                                        (0067) ; Endpoint Status--USB Status
                                        (0068) ;----------------------------------------------------------------------------
                                        (0069) EXPORT USB_EndpointStatus
                                        (0070)  USB_EndpointStatus:                    BLK   USB_NUM_ENDPOINTS    ; Endpoint Status
                                        (0071) ;----------------------------------------------------------------------------
                                        (0072) ; Last Packet Size
                                        (0073) ;----------------------------------------------------------------------------
                                        (0074) EXPORT USB_LastSize
                                        (0075)  USB_LastSize:                          BLK   1    ;  Last Packet Size
                                        (0076) ;----------------------------------------------------------------------------
                                        (0077) ; Control Transfer State Machine
                                        (0078) ; State values for Control Write
                                        (0079) ; State values for Control Read
                                        (0080) ;----------------------------------------------------------------------------
                                        (0081) EXPORT USB_TransferType
                                        (0082)  USB_TransferType:                      BLK   1    ; Control Transfer State Machine
                                        (0083) ;----------------------------------------------------------------------------
                                        (0084) ; Control Transfer Intermediate Buffer--Shared among the requests
                                        (0085) ;----------------------------------------------------------------------------
                                        (0086) EXPORT USB_TransferBuffer
                                        (0087)  USB_TransferBuffer:                    BLK   8
                                        (0088) ;----------------------------------------------------------------------------
                                        (0089) ; Transfer Descriptor Data for Control Transfer
                                        (0090) ;  --The following data have the same format as the first 5 bytes of the TD_ENTRY
                                        (0091) ;----------------------------------------------------------------------------
                                        (0092) ; Control Transfer Data Source
                                        (0093) ;   USB_DS_ROM
                                        (0094) ;   USB_DS_RAM
                                        (0095) ;   USB_DS_RAM_AS_NEEDED
                                        (0096) ;----------------------------------------------------------------------------
                                        (0097) EXPORT USB_CurrentTD, _USB_CurrentTD
                                        (0098)  USB_CurrentTD:
                                        (0099) _USB_CurrentTD:
                                        (0100) EXPORT USB_DataSource, _USB_DataSource
                                        (0101)  USB_DataSource:
                                        (0102) _USB_DataSource:                       BLK   1
                                        (0103) ;----------------------------------------------------------------------------
                                        (0104) ; Control Transfer Data Size
                                        (0105) ;----------------------------------------------------------------------------
                                        (0106) EXPORT USB_TransferSize, _USB_TransferSize
                                        (0107)  USB_TransferSize:
                                        (0108)  _USB_TransferSize:                    BLK   2
                                        (0109) ;----------------------------------------------------------------------------
                                        (0110) ; Control Transfer Data Pointer
                                        (0111) ;   Source for Control Read
                                        (0112) ;   Destination for Control Write
                                        (0113) ;----------------------------------------------------------------------------
                                        (0114) EXPORT USB_DataPtr, _USB_DataPtr
                                        (0115)  USB_DataPtr:
                                        (0116)  _USB_DataPtr:                         BLK   2
                                        (0117) ;----------------------------------------------------------------------------
                                        (0118) ; Transfer Completion Notification
                                        (0119) ;----------------------------------------------------------------------------
                                        (0120) EXPORT USB_StatusBlockPtr, _USB_StatusBlockPtr
                                        (0121)  USB_StatusBlockPtr:
                                        (0122)  _USB_StatusBlockPtr:                  BLK   2
                                        (0123) ;----------------------------------------------------------------------------
                                        (0124) ; Control Transfer _TransferByteCount (Actually transfered)
                                        (0125) ;----------------------------------------------------------------------------
                                        (0126)  USB_TransferByteCount:                 BLK   2
                                        (0127) ;----------------------------------------------------------------------------
                                        (0128) ; Control Endpoint Data toggle
                                        (0129) EXPORT USB_EPDataToggle
                                        (0130)  USB_EPDataToggle:
                                        (0131)  USB_EP0DataToggle:                     BLK   1
                                        (0132) ;----------------------------------------------------------------------------
                                        (0133) ; Control Endpoint Data Pending Flag
                                        (0134) EXPORT USB_fDataPending
                                        (0135)  USB_fDataPending:                      BLK   1
                                        (0136) ;----------------------------------------------------------------------------
                                        (0137) ; Control Endpoint Data Pending Flag
                                        (0138) ;EXPORT USB_PendingData
                                        (0139) ; USB_PendingData:                      BLK   1
                                        (0140) ;----------------------------------------------------------------------------
                                        (0141) ; Temporary Data registers
                                        (0142) EXPORT USB_t2, USB_t1, USB_t0
                                        (0143)  USB_t2:                                BLK   1    ; Temporary shared by the UM
                                        (0144)  USB_t1:                                BLK   1    ; Temporary shared by the UM
                                        (0145)  USB_t0:                                BLK   1    ; Temporary shared by the UM
                                        (0146) ;----------------------------------------------------------------------------
                                        (0147) ; Endpoint Transfer--API Status
                                        (0148) ;----------------------------------------------------------------------------
                                        (0149) EXPORT USB_EndpointAPIStatus, _USB_EndpointAPIStatus
                                        (0150)  USB_EndpointAPIStatus:
                                        (0151) _USB_EndpointAPIStatus:                 BLK   USB_NUM_ENDPOINTS    ; Endpoint Status
                                        (0152) 
                                        (0153) AREA UserModules (ROM, REL)
                                        (0154) ;-----------------------------------------------------------------------------
                                        (0155) ;  FUNCTION NAME: USB_EP0_ISR
                                        (0156) 
                                        (0157) ;
                                        (0158) ;  DESCRIPTION:   The EPO ISR serves the control endpoint interrupts and
                                        (0159) ;                 dispaches all SETUP, IN, and OUT transfers to the proper
                                        (0160) ;                 dispatch routines for all supported USB requests.
                                        (0161) ;
                                        (0162) ;-----------------------------------------------------------------------------
                                        (0163) ;
                                        (0164) ;  ARGUMENTS:   n/a
                                        (0165) ;
                                        (0166) ;  RETURNS:     n/a
                                        (0167) ;
                                        (0168) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0169) ;
                                        (0170) ;  THEORY of OPERATION or PROCEDURE:
                                        (0171) ;
                                        (0172) ;-----------------------------------------------------------------------------
                                        (0173)  USB_EP0_ISR:
                                        (0174) _USB_EP0_ISR:
0518: 08       PUSH  A                  (0175)     PUSH    A                          ; Save the context
0519: 10       PUSH  X                  (0176)     PUSH    X                          ;
                                        (0177)     ; Dispatch to setup/in/out handlers
                                        (0178) EXPORT  USB_mode_read
                                        (0179) USB_mode_read:
051A: 5D 44    MOV   A,REG[0x44]        (0180)    MOV    A, REG[USB_EP0MODE]           ; Get the mode reg
                                        (0181) 
051C: 5C       MOV   X,A                (0182)     MOV     X, A ; store for later
                                        (0183)     ; Check EP0_CR for the following cases:
                                        (0184)     ; bit 7 is set but ack is not set or mode is not 1 => invalid setup
                                        (0185)     ; bit 7 is not set, bit 5 or 6 is set, but bit 4 is not set => invalid in/out
051D: 21 9F    AND   A,0x9F             (0186)     AND     A, 9Fh
051F: 39 91    CMP   A,0x91             (0187)     CMP     A, 91h
0521: A0 3D    JZ    0x055F             (0188)     JZ      USB_EP0_Setup
                                        (0189)     ; Check if setup bit is set--if so then invalid EP0_CR reg read so exit
0523: 21 80    AND   A,0x80             (0190)     AND     A, 80h
                                        (0191)     ; Getting here means there is an invalid setup; exit without modifying the mode
0525: B0 36    JNZ   0x055C             (0192)     JNZ     USB_EP0_ISR_EXIT
                                        (0193)     ; Getting here means the setup bit is not set, now check in/out
0527: 5B       MOV   A,X                (0194)     MOV     A, X   ; restore EP0_CR reg as read
0528: 21 70    AND   A,0x70             (0195)     AND     A, 70h
052A: 39 50    CMP   A,0x50             (0196)     CMP     A, 50h
052C: A0 5C    JZ    0x0589             (0197)     JZ      USB_EP0_IN
052E: 39 30    CMP   A,0x30             (0198)     CMP     A, 30h
0530: A0 66    JZ    0x0597             (0199)     JZ      USB_EP0_OUT
                                        (0200)     ; Getting here means there is an invalid in/out; exit without modifying the mode
0532: 80 29    JMP   0x055C             (0201)     JMP     USB_EP0_ISR_EXIT  
                                        (0202) ; ISR Exit Point to update the mode register
                                        (0203) ;   mode and count have been pushed onto the stack
                                        (0204) EXPORT USB_EP0_UPD_MODE_EXIT
                                        (0205) USB_EP0_UPD_MODE_EXIT:
                                        (0206) 
0534: 53 28    MOV   [USB_t0],A         (0207)     MOV     [USB_t0], A                    ; store EP0_CNT reg value for later
0536: 5D 44    MOV   A,REG[0x44]        (0208)     MOV     A, reg[USB_EP0MODE]            ; unlock registers  
0538: 21 80    AND   A,0x80             (0209)     AND     A, 80h                                      ; Check if SETUP bit is set
053A: B0 21    JNZ   0x055C             (0210)     JNZ     USB_EP0_ISR_EXIT                ;          then EXIT from the ISR	
053C: 51 28    MOV   A,[USB_t0]         (0211)     MOV     A, [USB_t0]                    ; restore EP0_CNT reg value
053E: 60 41    MOV   REG[0x41],A        (0212)     MOV     reg[USB_EP0CNT], A             ; Update the count register
0540: 5D 41    MOV   A,REG[0x41]        (0213)     MOV     A, reg[USB_EP0CNT]             ; writing check
0542: 3A 28    CMP   A,[USB_t0]         (0214)     CMP     A, [USB_t0]                    ; if writing was not succesful,
0544: B0 17    JNZ   0x055C             (0215)     JNZ     USB_EP0_ISR_EXIT               ;         then abort the ISR    
                                        (0216) 
0546: 5A 28    MOV   [USB_t0],X         (0217)     MOV     [USB_t0], X                     ; store EP0_MODE reg value for later
                                        (0218) .ReWriteMODE:
0548: 5D 44    MOV   A,REG[0x44]        (0219)     MOV     A, reg[USB_EP0MODE]             ; unblock registers    
054A: 21 80    AND   A,0x80             (0220)     AND     A, 80h                                      ; Check if SETUP bit is set
054C: B0 0F    JNZ   0x055C             (0221)     JNZ     USB_EP0_ISR_EXIT                ;          then EXIT from the ISR
                                        (0222)     
054E: 51 28    MOV   A,[USB_t0]         (0223)     MOV     A, [USB_t0]                     ; restore the new MODE
0550: 60 44    MOV   REG[0x44],A        (0224)     MOV     reg[USB_EP0MODE], A             ; Update the mode regiter
                                        (0225)     
0552: 5D 44    MOV   A,REG[0x44]        (0226)     MOV     A, reg[USB_EP0MODE]             ; writing check
0554: 21 0F    AND   A,0xF              (0227)     AND     A,  0Fh                                     ; clear 7-4 bits
0556: 3A 28    CMP   A,[USB_t0]         (0228)     CMP     A, [USB_t0]                     ; if writing was succesful,
0558: A0 03    JZ    0x055C             (0229)     JZ      USB_EP0_ISR_EXIT                ;          then EXIT from the ISR
                                        (0230)                                                          ; if writing was not succesful,
055A: 8F ED    JMP   0x0548             (0231)     JMP      .ReWriteMODE                                 ;           then repeat write operation   
                                        (0232) 
                                        (0233) 
                                        (0234) USB_EP0_ISR_EXIT:
                                        (0235) 
055C: 20       POP   X                  (0236)     POP X                              ;
055D: 18       POP   A                  (0237)     POP A                              ; Restore Context
055E: 7E       RETI                     (0238)     RETI
                                        (0239) ;-----------------------------------------------------------------------------
                                        (0240) ;  FUNCTION NAME: USB_EP0_Setup
                                        (0241) ;
                                        (0242) ;  DESCRIPTION:   Dispatch a USB SETUP
                                        (0243) ;
                                        (0244) ;-----------------------------------------------------------------------------
                                        (0245)  USB_EP0_Setup:
                                        (0246) _USB_EP0_Setup:
                                        (0247) ; Check the byte count and validity.  All SETUP are 8 bytes and 0 toggle
055F: 5D 44    MOV   A,REG[0x44]        (0248)     MOV     A, reg[USB_EP0MODE]    ; unlock registers
0561: 60 44    MOV   REG[0x44],A        (0249)     MOV     reg[USB_EP0MODE], A ; clear setup bit 
0563: 5D 44    MOV   A,REG[0x44]        (0250)     MOV     A, reg[USB_EP0MODE]    ; (re)read register
0565: 21 80    AND   A,0x80             (0251)     AND     A, 80h                              ; Check if SETUP bit is set
0567: BF F4    JNZ   0x055C             (0252)     JNZ     USB_EP0_ISR_EXIT       ; if SETUP bit set -> exit without modifying the mode    
                                        (0253) 
0569: 08       PUSH  A                  (0254)     PUSH    A                          ; Save the mode register
056A: 50 02    MOV   A,0x2              (0255)     MOV     A, USB_XFER_PREMATURE      ; Return a Premature Completion?
056C: 91 DE    CALL  0x074C             (0256)     CALL    USB_UpdateStatusBlock
056E: 18       POP   A                  (0257)     POP     A                          ; Restore the mode register
056F: 5D 41    MOV   A,REG[0x41]        (0258)     MOV    A, REG[USB_EP0CNT]                ; Get the count reg
0571: 39 4A    CMP   A,0x4A             (0259)     CMP    A, (USB_CNT_VALID | 0x0A)
0573: A0 03    JZ    0x0577             (0260)     JZ      .dispatch
                                        (0261) 
0575: 82 46    JMP   0x07BC             (0262)     JMP    USB_Not_Supported_Local_Drv
                                        (0263) ;-----------------------------------------------------------------------------
                                        (0264) ; Jump here to dispatch the request
                                        (0265) ; The SETUP request is encoded in [bmRequestType]. Among the 8 bits in [bmRequestType], only bits
                                        (0266) ; 7,6,5,1,0 determine what the request is. Bits [2:4] are default to zero. The below code
                                        (0267) ; re-organizes [bmRequestType] to the following format:
                                        (0268) ; ( Zero, Zero, Bit7, Bit6, Bit5, Bit1, Bit0, Zero ), and depending on the value of this
                                        (0269) ; "re-organization", the firmware will jump to an appropriate table to handle the request.
                                        (0270) ;-----------------------------------------------------------------------------
                                        (0271) .dispatch:
0577: 5D 50    MOV   A,REG[0x50]        (0272)     MOV     A, REG[USB_EP0DATA+bmRequestType]   ; Get bmRequestType
0579: 21 E3    AND   A,0xE3             (0273)     AND     A, E3h                           ; clear bits 4-3-2, these unused for our purposes
057B: 08       PUSH  A                  (0274)     PUSH    A                                ; store value on the stack
057C: 67       ASR   A                  (0275)     ASR     A                                ; move bits 7-6-5 into 4-3-2's place
057D: 67       ASR   A                  (0276)     ASR     A                                ; "asr" instruction shift all bits one place to the right.
057E: 67       ASR   A                  (0277)     ASR     A                                ; Bit7 remains the same.
057F: 53 26    MOV   [USB_t2],A         (0278)     MOV     [USB_t2], A                      ; store shifted value
0581: 18       POP   A                  (0279)     POP     A                                ; get original value
0582: 2A 26    OR    A,[USB_t2]         (0280)     OR      A, [USB_t2]                      ; or the two to get the 5-bit field
0584: 21 1F    AND   A,0x1F             (0281)     AND     A, 1Fh                           ; clear bits 7-6-5 (asr wraps bit7)
                                        (0282)                                              ; Bit0 is loaded with a Zero. This results in multiplying
                                        (0283)                                              ; the accumulator by 2, and the reason to mutiply it by 2
                                        (0284)                                              ; is that each "jmp" instruction in the tables is two bytes long.
                                        (0285) 
0586: 7D 07 B3 LJMP  USB_bmRequestType_Dispatch(0286)     LJMP USB_bmRequestType_Dispatch
                                        (0287) ;-----------------------------------------------------------------------------
                                        (0288) ;  FUNCTION NAME: USB_EP0_IN
                                        (0289) ;
                                        (0290) ;  DESCRIPTION:   Dispatch a USB IN
                                        (0291) ;
                                        (0292) ;-----------------------------------------------------------------------------
                                        (0293)  USB_EP0_IN:
                                        (0294) _USB_EP0_IN:
0589: 5D 44    MOV   A,REG[0x44]        (0295)     MOV     A, reg[USB_EP0MODE]    ; unlock registers
                                        (0296) ;    MOV     reg[USB_EP0MODE], A ; clear setup bit 
                                        (0297) ;    MOV     A, reg[USB_EP0MODE]    ; (re)read register
                                        (0298) ;    AND     A, 80h                              ; Check if SETUP bit is set
                                        (0299) ;    JNZ     USB_EP0_ISR_EXIT       ; if SETUP bit set -> exit without modifying the mode    
                                        (0300) 
058B: 51 12    MOV   A,[USB_TransferType](0301)     MOV     A, [USB_TransferType]
                                        (0302) USB_ControlInDispatch:
058D: E0 01    JACC  0x058F             (0303)     JACC    USB_ControlInDispatchTable
                                        (0304) USB_ControlInDispatchTable:
058F: 82 2C    JMP   0x07BC             (0305)     JMP     USB_Not_Supported_Local_Drv  ; USB_TRANS_STATE_IDLE
0591: 80 39    JMP   0x05CB             (0306)     JMP     USB_ControlReadDataStage     ; USB_TRANS_STATE_CONTROL_READ
0593: 80 AF    JMP   0x0643             (0307)     JMP     USB_ControlWriteStatusStage  ; USB_TRANS_STATE_CONTROL_WRITE
0595: 80 BA    JMP   0x0650             (0308)     JMP     USB_NoDataControlStatusStage ; USB_TRANS_STATE_NO_DATA_CONTROL
                                        (0309) ;-----------------------------------------------------------------------------
                                        (0310) ;  FUNCTION NAME: USB_EP0_OUT
                                        (0311) ;
                                        (0312) ;  DESCRIPTION:   Dispatch a USB OUT
                                        (0313) ;
                                        (0314) ;-----------------------------------------------------------------------------
                                        (0315)  USB_EP0_OUT:
                                        (0316) _USB_EP0_OUT:
0597: 5D 44    MOV   A,REG[0x44]        (0317)     MOV     A, reg[USB_EP0MODE]    ; unlock registers
                                        (0318) ;    MOV     reg[USB_EP0MODE], A ; clear setup bit 
                                        (0319) ;    MOV     A, reg[USB_EP0MODE]    ; (re)read register
                                        (0320) ;    AND     A, 80h                              ; Check if SETUP bit is set
                                        (0321) ;    JNZ     USB_EP0_ISR_EXIT       ; if SETUP bit set -> exit without modifying the mode    
                                        (0322) 
0599: 51 12    MOV   A,[USB_TransferType](0323)     MOV     A, [USB_TransferType]
059B: E0 01    JACC  0x059D             (0324)     JACC    USB_ControlOutDispatchTable
                                        (0325) USB_ControlOutDispatchTable:
059D: 82 1E    JMP   0x07BC             (0326)     JMP     USB_Not_Supported_Local_Drv  ; USB_TRANS_STATE_IDLE
059F: 80 2D    JMP   0x05CD             (0327)     JMP     USB_ControlReadStatusStage   ; USB_TRANS_STATE_CONTROL_READ
05A1: 80 5E    JMP   0x0600             (0328)     JMP     USB_ControlWriteDataStage    ; USB_TRANS_STATE_CONTROL_WRITE
05A3: 80 C6    JMP   0x066A             (0329)     JMP     USB_NoDataControlError       ; USB_TRANS_STATE_NO_DATA_CONTROL
                                        (0330) ;-----------------------------------------------------------------------------
                                        (0331) ;  FUNCTION NAME: USB_InitControlRead
                                        (0332) ;
                                        (0333) ;  DESCRIPTION:   This routine initializes a control read.  It must be JUMPed to,
                                        (0334) ;                 not called.  It assumes a tranfer descriptor has been loaded
                                        (0335) ;                 into the driver USB_CurrentTD data structure.
                                        (0336) ;
                                        (0337) ;-----------------------------------------------------------------------------
                                        (0338)  USB_InitControlRead:
05A5: 53 11    MOV   [USB_LastSize],A   (0339)     MOV     [USB_LastSize], A          ; Save the packet size?
05A7: 91 B9    CALL  0x0762             (0340)     CALL    USB_InitializeStatusBlock
05A9: 55 12 02 MOV   [USB_TransferType],0x2(0341)     MOV     [USB_TransferType], USB_TRANS_STATE_CONTROL_READ
                                        (0342) 
                                        (0343)     ; Check the transfer size against the request size
05AC: 5D 57    MOV   A,REG[0x57]        (0344)     MOV    A, REG[USB_EP0DATA+wLengthHi] ; MSB of wLength
05AE: 3A 1C    CMP   A,[USB_TransferSize](0345)     CMP    A, [USB_TransferSize]
05B0: B0 07    JNZ   0x05B8             (0346)     JNZ    .L1
                                        (0347) 
05B2: 5D 56    MOV   A,REG[0x56]        (0348)     MOV    A, REG[USB_EP0DATA+wLengthLo] ; LSB of wLength
05B4: 3A 1D    CMP   A,[USB_TransferSize+1](0349)     CMP    A, [USB_TransferSize+1]
05B6: A0 09    JZ    0x05C0             (0350)     JZ     .L9
                                        (0351) .L1:
05B8: D0 07    JNC   0x05C0             (0352)     JNC    .L9
                                        (0353) ;
05BA: 53 1D    MOV   [USB_TransferSize+1],A(0354)     MOV    [USB_TransferSize+1], A     ;
05BC: 5D 57    MOV   A,REG[0x57]        (0355)     MOV    A, REG[USB_EP0DATA+wLengthHi] ;
05BE: 53 1C    MOV   [USB_TransferSize],A(0356)     MOV    [USB_TransferSize], A       ;
                                        (0357) .L9:
05C0: 55 22 00 MOV   [USB_StatusBlockPtr+2],0x0(0358)     MOV    [USB_TransferByteCount], 0  ;
05C3: 55 23 00 MOV   [USB_StatusBlockPtr+3],0x0(0359)     MOV    [USB_TransferByteCount+1], 0;
                                        (0360) 
05C6: 2E 24 01 OR    [USB_EPDataToggle],0x1(0361)     OR     [USB_EP0DataToggle], 1 ; setup EP0 data toggle
05C9: 80 AA    JMP   0x0674             (0362)     JMP    USB_LoadEndpoint            ;
                                        (0363) ;-----------------------------------------------------------------------------
                                        (0364) ;  FUNCTION NAME: USB_ControlReadDataStage
                                        (0365) ;
                                        (0366) ;  DESCRIPTION:   This routine processes the data stage of a control read.  It
                                        (0367) ;                 must be JUMPed to, not called.  It assumes a tranfer descriptor
                                        (0368) ;                 has been loaded into the driver USB_CurrentTD
                                        (0369) ;                 data structure.
                                        (0370) ;
                                        (0371) ;-----------------------------------------------------------------------------
                                        (0372)  USB_ControlReadDataStage:
05CB: 80 A8    JMP   0x0674             (0373)     JMP     USB_LoadEndpoint
                                        (0374) 
                                        (0375) ;-----------------------------------------------------------------------------
                                        (0376) ;  FUNCTION NAME: USB_ControlReadStatusStage
                                        (0377) ;
                                        (0378) ;  DESCRIPTION:   This routine processes the status stage of a control read.  It
                                        (0379) ;                 must be JUMPed to, not called.  It handles short or 0 packet
                                        (0380) ;                 It assumes a tranfer descriptor has been loaded into the
                                        (0381) ;                 driver USB_CurrentTD data structure.
                                        (0382) ;
                                        (0383) ;-----------------------------------------------------------------------------
                                        (0384)  USB_ControlReadStatusStage:
05CD: 51 11    MOV   A,[USB_LastSize]   (0385)     MOV    A, [USB_LastSize]           ; Get the number of bytes from the last transfer
05CF: 04 23    ADD   [USB_StatusBlockPtr+3],A(0386)     ADD    [USB_TransferByteCount + 1], A ; Update the transfer byte count
05D1: 0E 22 00 ADC   [USB_StatusBlockPtr+2],0x0(0387)     ADC    [USB_TransferByteCount], 0  ;
05D4: 50 01    MOV   A,0x1              (0388)     MOV    A, USB_XFER_STATUS_ACK      ; Return a Status ACK Completion
05D6: 91 74    CALL  0x074C             (0389)     CALL   USB_UpdateStatusBlock
05D8: 55 12 00 MOV   [USB_TransferType],0x0(0390)     MOV    [USB_TransferType], USB_TRANS_STATE_IDLE
05DB: 50 00    MOV   A,0x0              (0391)     MOV    A, 0                        ; Count Register
05DD: 57 03    MOV   X,0x3              (0392)     MOV    X, USB_MODE_STALL_IN_OUT
05DF: 8F 54    JMP   USB_EP0_UPD_MODE_EXIT(0393)     JMP    USB_EP0_UPD_MODE_EXIT
                                        (0394) ;-----------------------------------------------------------------------------
                                        (0395) ;  FUNCTION NAME: USB_NoDataStageControlTransfer
                                        (0396) ;                 USB_InitNoDataStageControlTransfer
                                        (0397) ;
                                        (0398) ;  DESCRIPTION:   This routine processes the status stage of a no data control
                                        (0399) ;                 write.  It must be JUMPed to, not called.
                                        (0400) ;
                                        (0401) ;-----------------------------------------------------------------------------
                                        (0402)  USB_NoDataStageControlTransfer:
                                        (0403)  USB_InitNoDataStageControlTransfer:
05E1: 91 7F    CALL  0x0762             (0404)     CALL    USB_InitializeStatusBlock
                                        (0405) 
05E3: 55 12 06 MOV   [USB_TransferType],0x6(0406)     MOV    [USB_TransferType], USB_TRANS_STATE_NO_DATA_CONTROL
                                        (0407) 
05E6: 50 00    MOV   A,0x0              (0408)     MOV    A, 0                        ; Count Register
05E8: 57 06    MOV   X,0x6              (0409)     MOV    X, USB_MODE_STATUS_IN_ONLY
05EA: 8F 49    JMP   USB_EP0_UPD_MODE_EXIT(0410)     JMP    USB_EP0_UPD_MODE_EXIT
                                        (0411) ;-----------------------------------------------------------------------------
                                        (0412) ;  FUNCTION NAME: USB_InitControlWrite
                                        (0413) ;
                                        (0414) ;  DESCRIPTION:   This routine initializes control write.  It must be JUMPed
                                        (0415) ;                 to, not called.  It assumes a tranfer descriptor has been loaded
                                        (0416) ;                 into the driver USB_CurrentTD data structure.
                                        (0417) ;
                                        (0418) ;-----------------------------------------------------------------------------
                                        (0419)  USB_InitControlWrite:
05EC: 51 1B    MOV   A,[USB_CurrentTD|USB_DataSource|USB_DataSource](0420)     MOV     A, [USB_DataSource]        ; Need to make sure the destination is not ROM
05EE: 39 00    CMP   A,0x0              (0421)     CMP     A, USB_DS_ROM
05F0: A1 CB    JZ    0x07BC             (0422)     JZ      USB_Not_Supported_Local_Drv
                                        (0423) 
05F2: 91 6E    CALL  0x0762             (0424)     CALL    USB_InitializeStatusBlock
                                        (0425) 
05F4: 55 12 04 MOV   [USB_TransferType],0x4(0426)     MOV    [USB_TransferType], USB_TRANS_STATE_CONTROL_WRITE
                                        (0427) 
05F7: 2E 24 01 OR    [USB_EPDataToggle],0x1(0428)     OR     [USB_EP0DataToggle], 1 ; setup EP0 data toggle
                                        (0429) 
05FA: 50 00    MOV   A,0x0              (0430)     MOV    A, 0                        ; Count Register
05FC: 57 0B    MOV   X,0xB              (0431)     MOV    X, USB_MODE_ACK_OUT_STATUS_IN
05FE: 8F 35    JMP   USB_EP0_UPD_MODE_EXIT(0432)     JMP    USB_EP0_UPD_MODE_EXIT
                                        (0433) ;-----------------------------------------------------------------------------
                                        (0434) ;  FUNCTION NAME: USB_ControlWriteDataStage
                                        (0435) ;
                                        (0436) ;  DESCRIPTION:   This routine processes the data stage of a control
                                        (0437) ;                 write.  It must be JUMPed to, not called.  It assumes a
                                        (0438) ;                 tranfer descriptor has been loaded into the driver
                                        (0439) ;                 USB_CurrentTD data structure.
                                        (0440) ;
                                        (0441) ;-----------------------------------------------------------------------------
                                        (0442)  USB_ControlWriteDataStage:
0600: 36 24 01 XOR   [USB_EPDataToggle],0x1(0443)     XOR    [USB_EP0DataToggle], 1      ; Update data toggle
                                        (0444) 
0603: 5D 41    MOV   A,REG[0x41]        (0445)     MOV    A,REG[USB_EP0CNT]           ; Get the count
                                        (0446) 
0605: 21 0F    AND   A,0xF              (0447)     AND     A, 0x0F
0607: 11 02    SUB   A,0x2              (0448)     SUB     A, 2                       ; Count include the two byte checksum
                                        (0449) 
0609: 53 26    MOV   [USB_t2],A         (0450)     MOV     [USB_t2], A                ; Assume we have room to receive the whole packet
                                        (0451) 
060B: 50 00    MOV   A,0x0              (0452)     MOV     A, 0
060D: 3A 1C    CMP   A,[USB_TransferSize](0453)     CMP     A, [USB_TransferSize]      ; If the MSB has anything just use the count
060F: B0 07    JNZ   0x0617             (0454)     JNZ     .L1
                                        (0455) 
0611: 51 26    MOV   A,[USB_t2]         (0456)     MOV     A, [USB_t2]
0613: 3A 1D    CMP   A,[USB_TransferSize+1](0457)     CMP     A, [USB_TransferSize+1]    ;
0615: A0 06    JZ    0x061C             (0458)     JZ      .L6
                                        (0459) .L1:
0617: C0 04    JC    0x061C             (0460)     JC      .L6
0619: 5F 26 1D MOV   [USB_t2],[USB_TransferSize+1](0461)     MOV     [USB_t2], [USB_TransferSize+1]
                                        (0462) 
                                        (0463) .L6:
061C: 51 26    MOV   A,[USB_t2]         (0464)     MOV     A, [USB_t2]
061E: 14 1D    SUB   [USB_TransferSize+1],A(0465)     SUB     [USB_TransferSize+1],A     ; Update the bytes remaining
0620: 1E 1C 00 SBB   [USB_TransferSize],0x0(0466)     SBB     [USB_TransferSize], 0      ;
                                        (0467) 
0623: 04 23    ADD   [USB_StatusBlockPtr+3],A(0468)     ADD     [USB_TransferByteCount + 1], A ; Update the transfer byte count
0625: 0E 22 00 ADC   [USB_StatusBlockPtr+2],0x0(0469)     ADC     [USB_TransferByteCount], 0 ;
                                        (0470) 
0628: 57 00    MOV   X,0x0              (0471)     MOV     X,0                        ; Start the index at 0
                                        (0472) 
                                        (0473) .RAM_COPY:
062A: 5E 50    MOV   A,REG[X+0x50]      (0474)     MOV     A, REG[X+USB_EP0DATA]      ; Get the data
062C: 3F 1F    MVI   [USB_DataPtr+1],A  (0475)     MVI     [USB_DataPtr+1], A         ; Store the data, bump the destination
                                        (0476) 
062E: 75       INC   X                  (0477)     INC     X                          ; Bump the destination offset
062F: 5B       MOV   A,X                (0478)     MOV     A,X                        ; Are we done?
0630: 3A 26    CMP   A,[USB_t2]         (0479)     CMP     A, [USB_t2]
0632: CF F7    JC    0x062A             (0480)     JC      .RAM_COPY                  ; Not done
                                        (0481) 
0634: 50 00    MOV   A,0x0              (0482)     MOV    A, 0                        ; Count Register
0636: 57 0B    MOV   X,0xB              (0483)     MOV    X, USB_MODE_ACK_OUT_STATUS_IN
0638: 8E FB    JMP   USB_EP0_UPD_MODE_EXIT(0484)     JMP    USB_EP0_UPD_MODE_EXIT
                                        (0485) 
                                        (0486) ; Jump here on data toggle error
                                        (0487) .error:
063A: 55 12 00 MOV   [USB_TransferType],0x0(0488)     MOV    [USB_TransferType], USB_TRANS_STATE_IDLE  ; This simply aborts the transfer
063D: 50 00    MOV   A,0x0              (0489)     MOV    A, 0                        ; Count Register
063F: 57 03    MOV   X,0x3              (0490)     MOV    X, USB_MODE_STALL_IN_OUT
0641: 8E F2    JMP   USB_EP0_UPD_MODE_EXIT(0491)     JMP    USB_EP0_UPD_MODE_EXIT
                                        (0492) ;-----------------------------------------------------------------------------
                                        (0493) ;  FUNCTION NAME: USB_ControlWriteStatusStage
                                        (0494) ;
                                        (0495) ;  DESCRIPTION:   This routine processes the status stage of a control
                                        (0496) ;                 write.  It must be JUMPed to, not called.  It assumes a
                                        (0497) ;                 tranfer descriptor has been loaded into the driver
                                        (0498) ;                 USB_CurrentTD data structure.
                                        (0499) ;
                                        (0500) ;-----------------------------------------------------------------------------
                                        (0501)  USB_ControlWriteStatusStage:
0643: 50 01    MOV   A,0x1              (0502)     MOV    A, USB_XFER_STATUS_ACK      ; Return a Status ACK Completion
0645: 91 05    CALL  0x074C             (0503)     CALL   USB_UpdateStatusBlock
0647: 55 12 00 MOV   [USB_TransferType],0x0(0504)     MOV    [USB_TransferType], USB_TRANS_STATE_IDLE  ; The packet is done
064A: 50 00    MOV   A,0x0              (0505)     MOV    A, 0                        ; Count Register
064C: 57 03    MOV   X,0x3              (0506)     MOV    X, USB_MODE_STALL_IN_OUT
064E: 8E E5    JMP   USB_EP0_UPD_MODE_EXIT(0507)     JMP    USB_EP0_UPD_MODE_EXIT
                                        (0508) ;-----------------------------------------------------------------------------
                                        (0509) ;  FUNCTION NAME: USB_NoDataControlStatusStage
                                        (0510) ;
                                        (0511) ;  DESCRIPTION:   This routine processes the status stage of a control
                                        (0512) ;                 write.  It must be JUMPed to, not called.  It assumes a
                                        (0513) ;                 tranfer descriptor has been loaded into the driver
                                        (0514) ;                 USB_CurrentTD data structure.
                                        (0515) ;
                                        (0516) ;                 USB Device Addressing happens here because we can't change
                                        (0517) ;                 the SIE Address before the Status IN is received.
                                        (0518) ;
                                        (0519) ;-----------------------------------------------------------------------------
                                        (0520)  USB_NoDataControlStatusStage:
0650: 50 01    MOV   A,0x1              (0521)     MOV     A, USB_XFER_STATUS_ACK     ; Return a Status ACK Completion
0652: 90 F8    CALL  0x074C             (0522)     CALL    USB_UpdateStatusBlock
                                        (0523)     ; Dispatch to the proper handler
0654: 3C 25 01 CMP   [USB_fDataPending],0x1(0524)     CMP     [USB_fDataPending], USB_ADDRESS_CHANGE_PENDING
0657: B0 09    JNZ   0x0661             (0525)     JNZ     .L1
                                        (0526) 
                                        (0527)     ; USB ADDRESS CHANGE
0659: 51 13    MOV   A,[USB_TransferBuffer](0528)     MOV     A, [USB_TransferBuffer]    ; Get the pending data
                                        (0529) 
065B: 29 80    OR    A,0x80             (0530)     OR      A, USB_ADDR_ENABLE         ; Set the enable bit
065D: 60 40    MOV   REG[0x40],A        (0531)     MOV     REG[USB_ADDR], A           ; Update the SIE address
065F: 80 01    JMP   0x0661             (0532)     JMP     .EXIT
                                        (0533) .L1:
                                        (0534) 
                                        (0535) .EXIT:
0661: 55 25 00 MOV   [USB_fDataPending],0x0(0536)     MOV     [USB_fDataPending], 0      ; Clear data pending
                                        (0537) 
0664: 50 00    MOV   A,0x0              (0538)     MOV    A, 0                        ; Count Register
0666: 57 06    MOV   X,0x6              (0539)     MOV    X, USB_MODE_STATUS_IN_ONLY  ; Wait for the next SETUP
0668: 8E CB    JMP   USB_EP0_UPD_MODE_EXIT(0540)     JMP    USB_EP0_UPD_MODE_EXIT
                                        (0541) ;-----------------------------------------------------------------------------
                                        (0542) ;  FUNCTION NAME: USB_NoDataControlError
                                        (0543) ;
                                        (0544) ;  DESCRIPTION:   This routine handles the condition when we expected a
                                        (0545) ;                 status IN, but receive an OUT
                                        (0546) ;
                                        (0547) ;-----------------------------------------------------------------------------
                                        (0548)  USB_NoDataControlError:
066A: 50 03    MOV   A,0x3              (0549)     MOV    A, USB_XFER_ERROR           ; Return Transaction Error
066C: 90 DE    CALL  0x074C             (0550)     CALL   USB_UpdateStatusBlock
066E: 50 00    MOV   A,0x0              (0551)     MOV    A, 0                        ; Count Register
0670: 57 03    MOV   X,0x3              (0552)     MOV    X, USB_MODE_STALL_IN_OUT    ; Set the mode register
0672: 8E C1    JMP   USB_EP0_UPD_MODE_EXIT(0553)     JMP    USB_EP0_UPD_MODE_EXIT
                                        (0554) ;-----------------------------------------------------------------------------
                                        (0555) ;  FUNCTION NAME: USB_LoadEndpoint
                                        (0556) ;
                                        (0557) ;  DESCRIPTION:  Load the endpoint buffer with the next data for the control
                                        (0558) ;                transfer.  It assumes a tranfer descriptor has been loaded
                                        (0559) ;                into the driver USB_CurrentTD data structure.
                                        (0560) ;
                                        (0561) ;-----------------------------------------------------------------------------
                                        (0562) USB_LoadEndpoint:
0674: 51 11    MOV   A,[USB_LastSize]   (0563)     MOV     A, [USB_LastSize]          ; Get the number of bytes from the last transfer
0676: 04 23    ADD   [USB_StatusBlockPtr+3],A(0564)     ADD     [USB_TransferByteCount + 1], A ; Update the transfer byte count
0678: 0E 22 00 ADC   [USB_StatusBlockPtr+2],0x0(0565)     ADC     [USB_TransferByteCount], 0 ;
067B: 51 1C    MOV   A,[USB_TransferSize](0566)     MOV     A,  [USB_TransferSize]     ; Check to see if we have any
067D: 2A 1D    OR    A,[USB_TransferSize+1](0567)     OR      A,  [USB_TransferSize+1]   ;  more data to send
067F: B0 0E    JNZ   0x068E             (0568)     JNZ     .cont                      ; Jump if we have to send more data
                                        (0569) 
                                        (0570) ; Flow here if there is no more data to send
0681: 3C 11 08 CMP   [USB_LastSize],0x8 (0571)     CMP     [USB_LastSize], 8          ; Was it a full packet?
0684: A0 47    JZ    0x06CC             (0572)     JZ      .START_TRANSFER            ; Jump if it was full (need to send a zero length)
                                        (0573) 
                                        (0574) ; Flow here if we are entering the status stage
0686: 50 00    MOV   A,0x0              (0575)     MOV    A, 0                        ; Count Register
0688: 53 11    MOV   [USB_LastSize],A   (0576)     MOV    [USB_LastSize], A           ; Clear the byte count
068A: 57 02    MOV   X,0x2              (0577)     MOV    X, USB_MODE_STATUS_OUT_ONLY ; Only ACK the Status Out
068C: 8E A7    JMP   USB_EP0_UPD_MODE_EXIT(0578)     JMP    USB_EP0_UPD_MODE_EXIT
                                        (0579) 
                                        (0580) ; Jump here to determine how many bytes should we transfer
                                        (0581) .cont:
068E: 3C 1C 00 CMP   [USB_TransferSize],0x0(0582)     CMP     [USB_TransferSize], 0      ; Check the MSB
0691: B0 0A    JNZ   0x069C             (0583)     JNZ     .L1
                                        (0584) 
0693: 3C 1D 08 CMP   [USB_TransferSize+1],0x8(0585)     CMP     [USB_TransferSize+1], 8    ; Check the LSB
0696: D0 05    JNC   0x069C             (0586)     JNC     .L1
                                        (0587) 
0698: 51 1D    MOV   A,[USB_TransferSize+1](0588)     MOV     A,[USB_TransferSize+1]     ; Transfer all the remaing data
069A: 80 03    JMP   0x069E             (0589)     JMP     .L3
                                        (0590) 
                                        (0591) .L1:
069C: 50 08    MOV   A,0x8              (0592)     MOV     A, 8                       ; Just transfer the next 8 bytes
                                        (0593) 
                                        (0594) .L3:
                                        (0595) 
069E: 14 1D    SUB   [USB_TransferSize+1],A(0596)     SUB     [USB_TransferSize+1],A     ; Update the bytes remaining
06A0: 1E 1C 00 SBB   [USB_TransferSize],0x0(0597)     SBB     [USB_TransferSize],0
                                        (0598) 
06A3: 53 26    MOV   [USB_t2],A         (0599)     MOV     [USB_t2],A                 ; Save the count
06A5: 57 00    MOV   X,0x0              (0600)     MOV     X,0
                                        (0601) 
06A7: 3C 1B 00 CMP   [USB_CurrentTD|USB_DataSource|USB_DataSource],0x0(0602)     CMP     [USB_DataSource],USB_DS_ROM  ; RAM or ROM copy?
06AA: B0 17    JNZ   0x06C2             (0603)     JNZ     .RAM_COPY
                                        (0604) 
                                        (0605) ; Copy data from a ROM source
                                        (0606) .ROM_COPY:
06AC: 10       PUSH  X                  (0607)     PUSH    X                          ; Save the destination offset
06AD: 51 1E    MOV   A,[USB_DataPtr]    (0608)     MOV     A,[USB_DataPtr]            ; Get the transfer source MSB
06AF: 58 1F    MOV   X,[USB_DataPtr+1]  (0609)     MOV     X,[USB_DataPtr+1]          ; Set the transfer source LSB
06B1: 76 1F    INC   [USB_DataPtr+1]    (0610)     INC     [USB_DataPtr+1]            ; Increment the data pointer
06B3: 0E 1E 00 ADC   [USB_DataPtr],0x0  (0611)     ADC     [USB_DataPtr], 0           ;   MSB if necessary
                                        (0612) 
06B6: 28       ROMX                     (0613)     ROMX                               ; Get the data byte
                                        (0614) 
06B7: 20       POP   X                  (0615)     POP     X                          ; Get the destination offset
06B8: 61 50    MOV   REG[X+0x50],A      (0616)     MOV     REG[X + USB_EP0DATA], A    ; Load the data
06BA: 75       INC   X                  (0617)     INC     X                          ; Bump the destination offset
06BB: 5B       MOV   A,X                (0618)     MOV     A,X                        ; Are we done?
06BC: 3A 26    CMP   A,[USB_t2]         (0619)     CMP     A, [USB_t2]
06BE: CF ED    JC    0x06AC             (0620)     JC      .ROM_COPY                  ; Not done
06C0: 80 0B    JMP   0x06CC             (0621)     JMP     .START_TRANSFER            ; Otherwise go start the transfer
                                        (0622) 
                                        (0623) ; Copy data from a RAM source
                                        (0624) .RAM_COPY:
06C2: 3E 1F    MVI   A,[USB_DataPtr+1]  (0625)     MVI     A, [USB_DataPtr+1]         ; Get the data, bump the source
                                        (0626) 
06C4: 61 50    MOV   REG[X+0x50],A      (0627)     MOV     REG[X +USB_EP0DATA], A     ; Load the data
06C6: 75       INC   X                  (0628)     INC     X                          ; Bump the destination offset
06C7: 5B       MOV   A,X                (0629)     MOV     A,X                        ; Are we done?
06C8: 3A 26    CMP   A,[USB_t2]         (0630)     CMP     A, [USB_t2]
06CA: CF F7    JC    0x06C2             (0631)     JC      .RAM_COPY                  ; Not done
                                        (0632) 
                                        (0633) ;; Set up the IN transfer count/mode/etc
                                        (0634) ;    A contains the byte count
                                        (0635) .START_TRANSFER:
06CC: 53 11    MOV   [USB_LastSize],A   (0636)     MOV     [USB_LastSize], A          ; Save the packet size
                                        (0637) 
06CE: 50 01    MOV   A,0x1              (0638)     MOV     A, 1
06D0: 22 24    AND   A,[USB_EPDataToggle](0639)     AND     A, [USB_EP0DataToggle]
06D2: A0 03    JZ    0x06D6             (0640)     JZ      .BYPASS_T1
06D4: 50 80    MOV   A,0x80             (0641)     MOV     A, USB_CNT_TOGGLE          ; Or T1 in the data toggle
                                        (0642) 
                                        (0643) .BYPASS_T1:
06D6: 2A 11    OR    A,[USB_LastSize]   (0644)     OR      A, [USB_LastSize]
06D8: 36 24 01 XOR   [USB_EPDataToggle],0x1(0645)     XOR     [USB_EP0DataToggle], 1     ; Update the data toggle for next time
                                        (0646) 
06DB: 57 0F    MOV   X,0xF              (0647)     MOV    X, USB_MODE_ACK_IN_STATUS_OUT  ; Set the mode register
06DD: 8E 56    JMP   USB_EP0_UPD_MODE_EXIT(0648)     JMP    USB_EP0_UPD_MODE_EXIT
                                        (0649) ;-----------------------------------------------------------------------------
                                        (0650) ;  FUNCTION NAME: USB_GetTableEntry
                                        (0651) ;
                                        (0652) ;  DESCRIPTION:   Copies a TD to the USB_CurrentTD data structure.
                                        (0653) ;
                                        (0654) ;-----------------------------------------------------------------------------
                                        (0655) EXPORT USB_GetTableEntry
                                        (0656) USB_GetTableEntry:
                                        (0657) 
06DF: 75       INC   X                  (0658)     INC     X                          ; Point to the first table entry
06E0: 09 00    ADC   A,0x0              (0659)     ADC     A, 0                       ;
06E2: 08       PUSH  A                  
06E3: 65 26    ASL   [USB_t2]           
06E5: 65 26    ASL   [USB_t2]           
06E7: 65 26    ASL   [USB_t2]           
06E9: 18       POP   A                  
                                        (0660) 
                                        (0661)     TD_INDEX_TO_OFFSET USB_t2 ; Convert the index
                                        (0662) 
06EA: 4B       SWAP  A,X                (0663)     SWAP    A, X
06EB: 02 26    ADD   A,[USB_t2]         (0664)     ADD     A, [USB_t2]
06ED: 4B       SWAP  A,X                (0665)     SWAP    A, X
06EE: 09 00    ADC   A,0x0              (0666)     ADC     A, 0                       ; A:X now points to the descriptor table entry we want
                                        (0667) 
                                        (0668) ; Flow here to load the Transfer Descriptor (TD_ENTRY)
06F0: 55 26 1B MOV   [USB_t2],0x1B      (0669)     MOV     [USB_t2], USB_CurrentTD    ; Use Temp as MVI pointer
06F3: 90 26    CALL  USB_GETBYTE        (0670)     CALL     USB_GETBYTE               ; Get the descriptor data source
06F5: 90 1C    CALL  USB_GETWORD        (0671)     CALL     USB_GETWORD               ; Get the descriptor size
06F7: 90 1A    CALL  USB_GETWORD        (0672)     CALL     USB_GETWORD               ; Get the descriptor address
06F9: 90 18    CALL  USB_GETWORD        (0673)     CALL     USB_GETWORD               ; Get the Status Pointer
                                        (0674) ; Dispatch to InitControlRead or InitControlWrite based on d2h/h2d in the request
06FB: 5D 50    MOV   A,REG[0x50]        (0675)     MOV    A, REG[USB_EP0DATA+bmRequestType]; Get bmRequestType
06FD: 21 80    AND   A,0x80             (0676)     AND     A,0x80                          ; Control Read or Write
06FF: A0 03    JZ    0x0703             (0677)     JZ      .control_write
                                        (0678) 
0701: 8E A3    JMP   USB_InitControlRead(0679)     JMP     USB_InitControlRead
                                        (0680) 
                                        (0681) .control_write:
0703: 8E E8    JMP   USB_InitControlWrite(0682)     JMP     USB_InitControlWrite
                                        (0683) 
                                        (0684) ;-----------------------------------------------------------------------------
                                        (0685) ;  FUNCTION NAME: USB_LOOKUP
                                        (0686) ;
                                        (0687) ;  DESCRIPTION:    Returns the address of an entry in a lookup table (LT_ENTRY)
                                        (0688) ;
                                        (0689) ;-----------------------------------------------------------------------------
                                        (0690) ;
                                        (0691) ;  ARGUMENTS:    A:X Point to the lookup table
                                        (0692) ;                USB_t2 contain the table index
                                        (0693) ;
                                        (0694) ;  RETURNS:      Address of the LT_ENTRY in A:X
                                        (0695) ;
                                        (0696) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0697) ;
                                        (0698) ;  THEORY of OPERATION or PROCEDURE:
                                        (0699) ;
                                        (0700) ;-----------------------------------------------------------------------------
                                        (0701) EXPORT USB_LOOKUP
                                        (0702) USB_LOOKUP:
0705: 75       INC   X                  (0703)     INC     X                          ; Point to the first table entry
0706: 09 00    ADC   A,0x0              (0704)     ADC     A, 0                       ;
0708: 65 26    ASL   [USB_t2]           
070A: 65 26    ASL   [USB_t2]           
                                        (0705) 
                                        (0706)     LT_INDEX_TO_OFFSET USB_t2          ; Convert the index
070C: 4B       SWAP  A,X                (0707)     SWAP    A, X
070D: 02 26    ADD   A,[USB_t2]         (0708)     ADD     A, [USB_t2]                ;
070F: 4B       SWAP  A,X                (0709)     SWAP    A, X
0710: 09 00    ADC   A,0x0              (0710)     ADC     A, 0
0712: 7F       RET                      (0711)     RET
                                        (0712) ;-----------------------------------------------------------------------------
                                        (0713) ;  FUNCTION NAME: USB_GETWORD/USB_GETBYTE
                                        (0714) ;
                                        (0715) ;  DESCRIPTION:    Get a word value from ROM
                                        (0716) ;
                                        (0717) ;-----------------------------------------------------------------------------
                                        (0718) ;
                                        (0719) ;  ARGUMENTS:    A:X is the ROM Address
                                        (0720) ;                USB_t2 is the destination address
                                        (0721) ;
                                        (0722) ;  RETURNS:      USB_t1
                                        (0723) ;
                                        (0724) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0725) ;                USES USB_t2
                                        (0726) ;                A:X points to the subsequent locaction ROM location
                                        (0727) ;  THEORY of OPERATION or PROCEDURE:
                                        (0728) ;
                                        (0729) ;-----------------------------------------------------------------------------
                                        (0730) EXPORT USB_GETWORD
                                        (0731) USB_GETWORD:
                                        (0732) 
0713: 08       PUSH  A                  (0733)     PUSH    A                          ; Don't loose the pointer MSB
0714: 28       ROMX                     (0734)     ROMX                               ; Data source flag
0715: 3F 26    MVI   [USB_t2],A         (0735)     MVI     [USB_t2], A                ; Save the data source
0717: 18       POP   A                  (0736)     POP     A                          ; Get the MSB back
0718: 75       INC   X                  (0737)     INC     X                          ; Point to the next  entry
0719: 09 00    ADC   A,0x0              (0738)     ADC     A, 0                       ;
                                        (0739) 
                                        (0740) EXPORT USB_GETBYTE
                                        (0741) USB_GETBYTE:
                                        (0742) 
071B: 08       PUSH  A                  (0743)     PUSH    A                          ; Don't loose the pointer MSB
071C: 28       ROMX                     (0744)     ROMX                               ; Data source flag
071D: 3F 26    MVI   [USB_t2],A         (0745)     MVI     [USB_t2], A                ; Save the data source
071F: 18       POP   A                  (0746)     POP     A                          ; Get the MSB back
0720: 75       INC   X                  (0747)     INC     X                          ; Point to the next  entry
0721: 09 00    ADC   A,0x0              (0748)     ADC     A, 0                       ;
0723: 7F       RET                      (0749)     RET
                                        (0750) ;-----------------------------------------------------------------------------
                                        (0751) ;  FUNCTION NAME: USB_GET_DEVICE_TABLE_ENTRY
                                        (0752) ;
                                        (0753) ;  DESCRIPTION:    Get the address of the current DEVICE_TABLE entry
                                        (0754) ;                  Not intended for use by C fucntions
                                        (0755) ;
                                        (0756) ;-----------------------------------------------------------------------------
                                        (0757) ;
                                        (0758) ;  ARGUMENTS:
                                        (0759) ;
                                        (0760) ;  RETURNS:        A:X points the the current DEVICE_TABLE entry
                                        (0761) ;                  Carry flag is set if the current device index is out of range
                                        (0762) ;
                                        (0763) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0764) ;
                                        (0765) ;  THEORY of OPERATION or PROCEDURE:
                                        (0766) ;
                                        (0767) ;-----------------------------------------------------------------------------
                                        (0768) EXPORT USB_GET_DEVICE_TABLE_ENTRY
                                        (0769) USB_GET_DEVICE_TABLE_ENTRY:
0724: 5F 26 0A MOV   [USB_t2],[USB_bCurrentDevice](0770)     MOV     [USB_t2], [USB_bCurrentDevice]  ; Use the UM temp var--Selector
                                        (0771) 
0727: 50 01    MOV   A,0x1              (0772)     MOV     A,>USB_DEVICE_LOOKUP       ; Get the ROM Address MSB
0729: 57 50    MOV   X,0x50             (0773)     MOV     X,<USB_DEVICE_LOOKUP       ; Get the ROM Address LSB
072B: 28       ROMX                     (0774)     ROMX                               ; First entry is the table size (only a byte)
072C: 3A 26    CMP   A,[USB_t2]         (0775)     CMP     A, [USB_t2]                ; Range check
072E: 50 01    MOV   A,0x1              (0776)     MOV     A,>USB_DEVICE_LOOKUP       ; Get the ROM Address MSB
0730: C0 03    JC    0x0734             (0777)     JC      .exit
                                        (0778) ; Flow here if the index is valid
0732: 9F D1    CALL  USB_LOOKUP         (0779)     CALL    USB_LOOKUP                 ; Look up the configuration
                                        (0780) ; Jump or flow here on exit
                                        (0781) .exit:
0734: 7F       RET                      (0782)     RET
                                        (0783) ;-----------------------------------------------------------------------------
                                        (0784) ;  FUNCTION NAME: USB_GET_CONFIG_TABLE_ENTRY
                                        (0785) ;
                                        (0786) ;  DESCRIPTION:    Get the address of the current DEVICE_TABLE entry
                                        (0787) ;                  Not intended for use by C fucntions
                                        (0788) ;                  Does not do range checking on
                                        (0789) ;
                                        (0790) ;-----------------------------------------------------------------------------
                                        (0791) ;
                                        (0792) ;  ARGUMENTS:
                                        (0793) ;
                                        (0794) ;  RETURNS:        A:X points the the current CONFIG_TABLE entry
                                        (0795) ;                  Carry flag is set if the current device index is out of range
                                        (0796) ;
                                        (0797) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0798) ;
                                        (0799) ;  THEORY of OPERATION or PROCEDURE:
                                        (0800) ;
                                        (0801) ;-----------------------------------------------------------------------------
                                        (0802) EXPORT USB_GET_CONFIG_TABLE_ENTRY
                                        (0803) USB_GET_CONFIG_TABLE_ENTRY:
0735: 9F ED    CALL  USB_GET_DEVICE_TABLE_ENTRY(0804)     CALL    USB_GET_DEVICE_TABLE_ENTRY ; Get the selected device
0737: 55 26 27 MOV   [USB_t2],0x27      (0805)     MOV     [USB_t2],USB_t1            ; Set the GETWORD destination
073A: 9F D7    CALL  USB_GETWORD        (0806)     CALL    USB_GETWORD                ; Get the pointer to the CONFIG_LOOKUP table
                                        (0807)                                        ; ITempW has the address
073C: 5D 52    MOV   A,REG[0x52]        (0808)     MOV     A, REG[USB_EP0DATA+wValueLo]  ; Get the configuration number
073E: 53 26    MOV   [USB_t2],A         (0809)     MOV     [USB_t2],A                 ; Save it
0740: 51 27    MOV   A,[USB_t1]         (0810)     MOV     A, [USB_t1]                ; Get the CONFIG_LOOKUP ROM Address MSB
0742: 58 28    MOV   X,[USB_t0]         (0811)     MOV     X, [USB_t1+1]              ; Get the CONFIG_LOOKUP ROM Address LSB
                                        (0812) 
                                        (0813) ; A:X Points to the CONFIG_LOOKUP, so get the current entry
0744: 5F 26 0B MOV   [USB_t2],[USB_Configuration](0814)     MOV     [USB_t2], [USB_Configuration] ; Get the configuration number
0747: 7A 26    DEC   [USB_t2]           (0815)     DEC     [USB_t2]                   ; We don't populate the 0th entry
0749: 9F BA    CALL  USB_LOOKUP         (0816)     CALL    USB_LOOKUP                 ; Look up the configuration
074B: 7F       RET                      (0817)     RET
                                        (0818) ;-----------------------------------------------------------------------------
                                        (0819) ;  FUNCTION NAME: USB_UpdateStatusBlock
                                        (0820) ;
                                        (0821) ;  DESCRIPTION:    Update the Completion Status Block for a Request.  The
                                        (0822) ;                  block is updated with the completion code from the
                                        (0823) ;                  argument (A) and the _TransferByteCount.
                                        (0824) ;
                                        (0825) ;                  The StatusBlock Pointer (_StatusBlockPtr) is set to NULL (0)
                                        (0826) ;                  to make sure no other updates are made to the StatusBlock by
                                        (0827) ;                  the USB User Module.
                                        (0828) ;
                                        (0829) ;-----------------------------------------------------------------------------
                                        (0830) ;
                                        (0831) ;  ARGUMENTS:      A contains the Completion Status Code
                                        (0832) ;
                                        (0833) ;  RETURNS:        None
                                        (0834) ;
                                        (0835) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0836) ;
                                        (0837) ;  THEORY of OPERATION or PROCEDURE:
                                        (0838) ;
                                        (0839) ;-----------------------------------------------------------------------------
                                        (0840) USB_UpdateStatusBlock:
074C: 58 21    MOV   X,[USB_StatusBlockPtr+1](0841)     MOV     X, [USB_StatusBlockPtr + 1];
074E: 4B       SWAP  A,X                (0842)     SWAP    A, X                       ; Don't loose the completion code
074F: 39 00    CMP   A,0x0              (0843)     CMP     A, 0                       ; NULL?
0751: A0 0F    JZ    0x0761             (0844)     JZ      .done                      ; No update on NULL
                                        (0845) ; Flow here to update the VSR Completion Status Block
0753: 4B       SWAP  A,X                (0846)     SWAP    A, X                       ; Completion code A, Pointer in X
0754: 54 00    MOV   [X+0],A            (0847)     MOV     [X + 0], A                 ; Update the completion Code
0756: 51 22    MOV   A,[USB_StatusBlockPtr+2](0848)     MOV     A, [USB_TransferByteCount] ; Actual Byte Count MSB
0758: 54 01    MOV   [X+1],A            (0849)     MOV     [X + 1], A
075A: 51 23    MOV   A,[USB_StatusBlockPtr+3](0850)     MOV     A, [USB_TransferByteCount + 1] ; Actual Byte Count LSB
075C: 54 02    MOV   [X+2],A            (0851)     MOV     [X + 2], A
075E: 55 21 00 MOV   [USB_StatusBlockPtr+1],0x0(0852)     MOV     [USB_StatusBlockPtr + 1], 0; Clear the Block Pointer
                                        (0853) .done:
0761: 7F       RET                      (0854)     RET                                ; All done
                                        (0855) ;-----------------------------------------------------------------------------
                                        (0856) ;  FUNCTION NAME: USB_InitializeStatusBlock
                                        (0857) ;
                                        (0858) ;  DESCRIPTION:    Initialize the Completion Status Block for a Request.
                                        (0859) ;                  The completion code is set to USB_XFER_IDLE.
                                        (0860) ;
                                        (0861) ;-----------------------------------------------------------------------------
                                        (0862) ;
                                        (0863) ;  ARGUMENTS:      None
                                        (0864) ;
                                        (0865) ;  RETURNS:        None
                                        (0866) ;
                                        (0867) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0868) ;
                                        (0869) ;  THEORY of OPERATION or PROCEDURE:
                                        (0870) ;
                                        (0871) ;-----------------------------------------------------------------------------
                                        (0872) USB_InitializeStatusBlock:
0762: 51 21    MOV   A,[USB_StatusBlockPtr+1](0873)     MOV     A, [USB_StatusBlockPtr + 1];
0764: 39 00    CMP   A,0x0              (0874)     CMP     A, 0                       ; NULL?
0766: A0 0B    JZ    0x0772             (0875)     JZ      .done                      ; No update on NULL
                                        (0876) ; Flow here to initialize the Completion Status Block
0768: 4B       SWAP  A,X                (0877)     SWAP    A, X                       ; Pointer in X
0769: 56 00 00 MOV   [X+0],0x0          (0878)     MOV     [X + 0], USB_XFER_IDLE     ; Initialize the completion code (0)
076C: 55 22 00 MOV   [USB_StatusBlockPtr+2],0x0(0879)     MOV     [USB_TransferByteCount], 0 ; Clear the byte count
076F: 55 23 00 MOV   [USB_StatusBlockPtr+3],0x0(0880)     MOV     [USB_TransferByteCount + 1], 0 ;
                                        (0881) .done:
0772: 7F       RET                      (0882)     RET                                ; All done
0773: 8D 15    JMP   USB_DT_h2d_std_dev_Dispatch
0775: 8D 48    JMP   USB_DT_h2d_std_ifc_Dispatch
0777: 8D 7E    JMP   USB_DT_h2d_std_ep_Dispatch
0779: 80 42    JMP   0x07BC             
077B: 80 40    JMP   0x07BC             
077D: 80 3E    JMP   0x07BC             
077F: 80 3C    JMP   0x07BC             
0781: 80 3A    JMP   0x07BC             
0783: 80 38    JMP   0x07BC             
0785: 80 36    JMP   0x07BC             
0787: 80 34    JMP   0x07BC             
0789: 80 32    JMP   0x07BC             
078B: 80 30    JMP   0x07BC             
078D: 80 2E    JMP   0x07BC             
078F: 80 2C    JMP   0x07BC             
0791: 80 2A    JMP   0x07BC             
0793: 8C D6    JMP   USB_DT_d2h_std_dev_Dispatch
0795: 8D 14    JMP   USB_DT_d2h_std_ifc_Dispatch
0797: 8D 3A    JMP   USB_DT_d2h_std_ep_Dispatch
0799: 80 22    JMP   0x07BC             
079B: 80 20    JMP   0x07BC             
079D: 80 1E    JMP   0x07BC             
079F: 80 1C    JMP   0x07BC             
07A1: 80 1A    JMP   0x07BC             
07A3: 80 18    JMP   0x07BC             
07A5: 80 16    JMP   0x07BC             
07A7: 80 14    JMP   0x07BC             
07A9: 80 12    JMP   0x07BC             
07AB: 80 10    JMP   0x07BC             
07AD: 80 0E    JMP   0x07BC             
07AF: 80 0C    JMP   0x07BC             
07B1: 80 0A    JMP   0x07BC             
07B3: 39 20    CMP   A,0x20             
07B5: D0 04    JNC   0x07BA             
07B7: 64       ASL   A                  
07B8: EF BA    JACC  USB_DT_bmRequestType
07BA: 80 01    JMP   0x07BC             
                                        (0883) ;-----------------------------------------------------------------------------
                                        (0884) ;  FUNCTION NAME: ;  USB 1st Tier Dispactch Jump Table (based on bmRequestType)
                                        (0885) ;
                                        (0886) ;  DESCRIPTION:
                                        (0887) ;
                                        (0888) ;-----------------------------------------------------------------------------
                                        (0889) ;
                                        (0890) ;  ARGUMENTS:
                                        (0891) ;
                                        (0892) ;  RETURNS:
                                        (0893) ;
                                        (0894) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0895) ;
                                        (0896) ;  THEORY of OPERATION or PROCEDURE:
                                        (0897) ;
                                        (0898) ;-----------------------------------------------------------------------------
                                        (0899) MACRO BMREQUEST_DISPATCH
                                        (0900) IF (USB_CB_@0_@1_@2 & 1)
                                        (0901)     jmp     USB_DT_@0_@1_@2_Dispatch
                                        (0902) ELSE
                                        (0903)     jmp     USB_Not_Supported_Local_Drv
                                        (0904) ENDIF
                                        (0905) ENDM
                                        (0906) USB_DT_bmRequestType::
                                        (0907)     BMREQUEST_DISPATCH    h2d,std,dev
                                        (0908)     BMREQUEST_DISPATCH    h2d,std,ifc
                                        (0909)     BMREQUEST_DISPATCH    h2d,std,ep
                                        (0910)     BMREQUEST_DISPATCH    h2d,std,oth
                                        (0911)     BMREQUEST_DISPATCH    h2d,cls,dev
                                        (0912)     BMREQUEST_DISPATCH    h2d,cls,ifc
                                        (0913)     BMREQUEST_DISPATCH    h2d,cls,ep
                                        (0914)     BMREQUEST_DISPATCH    h2d,cls,oth
                                        (0915)     BMREQUEST_DISPATCH    h2d,vnd,dev
                                        (0916)     BMREQUEST_DISPATCH    h2d,vnd,ifc
                                        (0917)     BMREQUEST_DISPATCH    h2d,vnd,ep
                                        (0918)     BMREQUEST_DISPATCH    h2d,vnd,oth
                                        (0919)     BMREQUEST_DISPATCH    h2d,rsv,dev
                                        (0920)     BMREQUEST_DISPATCH    h2d,rsv,ifc
                                        (0921)     BMREQUEST_DISPATCH    h2d,rsv,ep
                                        (0922)     BMREQUEST_DISPATCH    h2d,rsv,oth
                                        (0923)     BMREQUEST_DISPATCH    d2h,std,dev
                                        (0924)     BMREQUEST_DISPATCH    d2h,std,ifc
                                        (0925)     BMREQUEST_DISPATCH    d2h,std,ep
                                        (0926)     BMREQUEST_DISPATCH    d2h,std,oth
                                        (0927)     BMREQUEST_DISPATCH    d2h,cls,dev
                                        (0928)     BMREQUEST_DISPATCH    d2h,cls,ifc
                                        (0929)     BMREQUEST_DISPATCH    d2h,cls,ep
                                        (0930)     BMREQUEST_DISPATCH    d2h,cls,oth
                                        (0931)     BMREQUEST_DISPATCH    d2h,vnd,dev
                                        (0932)     BMREQUEST_DISPATCH    d2h,vnd,ifc
                                        (0933)     BMREQUEST_DISPATCH    d2h,vnd,ep
                                        (0934)     BMREQUEST_DISPATCH    d2h,vnd,oth
                                        (0935)     BMREQUEST_DISPATCH    d2h,rsv,dev
                                        (0936)     BMREQUEST_DISPATCH    d2h,rsv,ifc
                                        (0937)     BMREQUEST_DISPATCH    d2h,rsv,ep
                                        (0938)     BMREQUEST_DISPATCH    d2h,rsv,oth
                                        (0939) USB_DT_End:
                                        (0940) USB_DT_Size: equ (USB_DT_End-USB_DT_bmRequestType) / 2
                                        (0941) USB_bmRequestType_Dispatch::
                                        (0942)     DISPATCHER USB_DT_bmRequestType, USB_DT_Size, USB_Not_Supported_Local_Drv
                                        (0943) 
                                        (0944) USB_Not_Supported_Local_Drv:
07BC: 7D 02 8D LJMP  __usermodules_start|USB_CB_h2d_std_dev_08|USB_CB_h2d_std_dev_07|USB_CB_d2h_std_dev_07|USB_CB_h2d_std_dev_06|USB_CB_d2h_std_dev_05|USB_CB_h2d_std_dev_04|USB_CB_d2h_std_dev_04|USB_CB_d2h_std_dev_03|USB_CB_h2d_std_dev_02|USB_CB_d2h_std_dev_02|...(0945)         LJMP     USB_Not_Supported
                                        (0946) 
                                        (0947) 
                                        (0948) ;-----------------------------------------------
                                        (0949) ; Add custom application code for routines
                                        (0950) ;-----------------------------------------------
                                        (0951) 
                                        (0952)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                        (0953)    ;---------------------------------------------------
                                        (0954)    ; Insert your custom code below this banner
                                        (0955)    ;---------------------------------------------------
                                        (0956) 
                                        (0957)    ;---------------------------------------------------
                                        (0958)    ; Insert your custom code above this banner
                                        (0959)    ;---------------------------------------------------
                                        (0960)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0961) 
                                        (0962) ; End of File USB_drv.asm
FILE: lib\usb.asm                       (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: USB.asm
                                        (0004) ;;   Version: 1.90, Updated on 2015/3/4 at 22:20:18
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: USB Device User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API
                                        (0013) ;;        function returns. Even though these registers may be preserved now,
                                        (0014) ;;        there is no guarantee they will be preserved in future releases.
                                        (0015) ;;-----------------------------------------------------------------------------
                                        (0016) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0017) ;;*****************************************************************************
                                        (0018) ;;*****************************************************************************
                                        (0019) 
                                        (0020) include "m8c.inc"
                                        (0021) include "USB_macros.inc"
                                        (0022) include "USB.inc"
                                        (0023) IF 0x2 & 0x10000000
                                        (0024) PSOC_ERROR Please run the USB Setup Wizard.  Device Editor, Right Click the USB User Module
                                        (0025) ; This message will only appear if the USB Setup Wizard has not be run and the descriptors
                                        (0026) ; and associated data structures have been created.
                                        (0027) ; After running the USB Setup Wizard, you must also select the Config/Generate Application
                                        (0028) ; menu item from PSoC Designer in order to generate USB User Module data structures and
                                        (0029) ; descriptors.
                                        (0030) ENDIF
                                        (0031) ;-----------------------------------------------
                                        (0032) ;  Global Symbols
                                        (0033) ;-----------------------------------------------
                                        (0034) EXPORT USB_Start
                                        (0035) EXPORT _USB_Start
                                        (0036) EXPORT USB_Stop
                                        (0037) EXPORT _USB_Stop
                                        (0038) EXPORT USB_bCheckActivity
                                        (0039) EXPORT _USB_bCheckActivity
                                        (0040) EXPORT USB_bGetConfiguration
                                        (0041) EXPORT _USB_bGetConfiguration
                                        (0042) EXPORT USB_bGetEPState
                                        (0043) EXPORT _USB_bGetEPState
                                        (0044) EXPORT USB_bGetEPCount
                                        (0045) EXPORT _USB_bGetEPCount
                                        (0046) EXPORT USB_XLoadEP
                                        (0047) EXPORT _USB_XLoadEP
                                        (0048) EXPORT  USB_bReadOutEP
                                        (0049) EXPORT _USB_bReadOutEP
                                        (0050) EXPORT  USB_bGetEPAckState
                                        (0051) EXPORT _USB_bGetEPAckState
                                        (0052) EXPORT  USB_SetPowerStatus
                                        (0053) EXPORT _USB_SetPowerStatus
                                        (0054) EXPORT USB_EnableOutEP
                                        (0055) EXPORT _USB_EnableOutEP
                                        (0056) EXPORT USB_DisableOutEP
                                        (0057) EXPORT _USB_DisableOutEP
                                        (0058) EXPORT USB_EnableEP
                                        (0059) EXPORT _USB_EnableEP
                                        (0060) EXPORT USB_DisableEP
                                        (0061) EXPORT _USB_DisableEP
                                        (0062) EXPORT USB_Force
                                        (0063) EXPORT _USB_Force
                                        (0064) EXPORT USB_Suspend
                                        (0065) EXPORT _USB_Suspend
                                        (0066) EXPORT USB_Resume
                                        (0067) EXPORT _USB_Resume
                                        (0068) EXPORT USB_bRWUEnabled
                                        (0069) EXPORT _USB_bRWUEnabled
                                        (0070) 
                                        (0071) AREA bss (RAM,REL)
                                        (0072) ;-----------------------------------------------
                                        (0073) ;  Variable Allocation
                                        (0074) ;-----------------------------------------------
                                        (0075) ;----------------------------------------------------------------------------
                                        (0076) EXPORT USB_APITemp
                                        (0077)  USB_APITemp:                          BLK   2 ; Two bytes of temporary
                                        (0078)                                                 ; storage shared by the API
                                        (0079)                                                 ; functions
                                        (0080) EXPORT USB_APIEPNumber, _USB_APIEPNumber
                                        (0081) _USB_APIEPNumber:
                                        (0082)  USB_APIEPNumber:                      BLK   1 ; API storage for speed
                                        (0083) EXPORT USB_APICount, _USB_APICount
                                        (0084) _USB_APICount:
                                        (0085)  USB_APICount:                         BLK   1 ; API storage for speed
                                        (0086) 
                                        (0087) EXPORT USB_bActivity
                                        (0088)  USB_bActivity:                        BLK   1 ; Activity flag (Shared between the ISR and API)
                                        (0089) ;-----------------------------------------------
                                        (0090) ;  Constant Data Allocation
                                        (0091) ;-----------------------------------------------
                                        (0092) AREA UserModules (ROM, REL)
                                        (0093) EXPORT USB_USB_EP_BIT_LOOKUP
                                        (0094) .LITERAL
                                        (0095) USB_USB_EP_BIT_LOOKUP:  ;
                                        (0096)     DB     01H                       ; EP0
                                        (0097)     DB     02H                       ; EP1
                                        (0098)     DB     04H                       ; EP2
                                        (0099) .ENDLITERAL
                                        (0100) 
                                        (0101) AREA UserModules (ROM, REL)
                                        (0102) 
                                        (0103) ;-----------------------------------------------------------------------------
                                        (0104) ;  FUNCTION NAME: USB_Start
                                        (0105) ;
                                        (0106) ;  DESCRIPTION:    Starts the USB User Module
                                        (0107) ;                    Sets the device selection
                                        (0108) ;                    Set the configuration to unconfigured
                                        (0109) ;                    Enables the SIE for Address 0
                                        (0110) ;                    Enables the USB pullup (D- for low speed, D+ for full speed)
                                        (0111) ;
                                        (0112) ;-----------------------------------------------------------------------------
                                        (0113) ;
                                        (0114) ;  ARGUMENTS:    A is the desired device setting
                                        (0115) ;
                                        (0116) ;  RETURNS:
                                        (0117) ;
                                        (0118) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0119) ;
                                        (0120) ;  THEORY of OPERATION or PROCEDURE:
                                        (0121) ;
                                        (0122) ;-----------------------------------------------------------------------------
                                        (0123) .SECTION
                                        (0124)  USB_Start:
                                        (0125) _USB_Start:
07C2: 62 0D 00 MOV   REG[0xD],0x0       (0126)     MOV    REG[P10CR], 0x00            ; Disable the states
07C5: 62 0E 00 MOV   REG[0xE],0x0       (0127)     MOV    REG[P11CR], 0x00            ; 
                                        (0128) 
07C8: 53 0A    MOV   [USB_bCurrentDevice],A(0129)     MOV     [USB_bCurrentDevice], A    ; The app selects the desired device
                                        (0130) 
07CA: 55 12 00 MOV   [USB_TransferType],0x0(0131)     MOV     [USB_TransferType], USB_TRANS_STATE_IDLE ; Transaction Idle State
07CD: 55 0B 00 MOV   [USB_Configuration],0x0(0132)     MOV     [USB_Configuration], 0     ; Unconfigured
07D0: 55 0C 00 MOV   [USB_DeviceStatus],0x0(0133)     MOV     [USB_DeviceStatus], 0      ; Clears device status
                                        (0134) 
07D3: 55 24 00 MOV   [USB_EPDataToggle],0x0(0135)     MOV     [USB_EPDataToggle], 0      ; Clear all EP data toggles
                                        (0136) 
                                        (0137) IF (USB_CLASS & USB_CLASS_HID)
                                        (0138)     ; Initialize USB_Protocol variable to comply with HID 7.2.6 Set_Protocol Request: 
                                        (0139)     ; "When initialized, all devices default to report protocol." 
                                        (0140)     mov     X, 1-1                     ;number of interfaces -1 
                                        (0141) .loop:
                                        (0142)     mov     [X + USB_Protocol], 1      ; Protocol = Report
                                        (0143)     dec     X                                ;Are we done?
                                        (0144)     jnc     .loop                            ;Jump to do another interface
                                        (0145) ENDIF
                                        (0146)     
                                        (0147) ; Flow here to enable the SIE
07D6: 62 40 80 MOV   REG[0x40],0x80     (0148)     MOV     REG[USB_ADDR], USB_ADDR_ENABLE ; Enable Address 0
07D9: 43 74 80 OR    REG[0x74],0x80     (0149)     OR      REG[USB_USBXCR], USB_PULLUP_ENABLE ; Pullup D-
07DC: 62 44 03 MOV   REG[0x44],0x3      (0150)     MOV     REG[USB_EP0MODE], USB_MODE_STALL_IN_OUT ; ACK Setup/Stall IN/OUT
07DF: 40       NOP                      (0151)     NOP
07E0: 5D 44    MOV   A,REG[0x44]        (0152)     MOV     A, REG[USB_EP0MODE]        ; Read the mode register as a debug marker
07E2: 43 E1 19 OR    REG[0xE1],0x19     
                                        (0153) 
                                        (0154)     M8C_EnableIntMask INT_MSK1, (INT_MSK1_USB_ACTIVITY | INT_MSK1_USB_BUS_RESET | INT_MSK1_USB_EP0)
07E5: 7F       RET                      (0155)     RET
                                        (0156) .ENDSECTION
                                        (0157) ;-----------------------------------------------------------------------------
                                        (0158) ;  FUNCTION NAME: USB_Stop
                                        (0159) ;
                                        (0160) ;  DESCRIPTION:
                                        (0161) ;
                                        (0162) ;-----------------------------------------------------------------------------
                                        (0163) ;
                                        (0164) ;  ARGUMENTS:
                                        (0165) ;
                                        (0166) ;  RETURNS:
                                        (0167) ;
                                        (0168) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0169) ;
                                        (0170) ;  THEORY of OPERATION or PROCEDURE:
                                        (0171) ;
                                        (0172) ;-----------------------------------------------------------------------------
                                        (0173) .SECTION
                                        (0174)  USB_Stop:
                                        (0175) _USB_Stop:
07E6: 55 0A 00 MOV   [USB_bCurrentDevice],0x0(0176)     MOV     [USB_bCurrentDevice], 0    ; The app selects the desired device
                                        (0177) 
07E9: 55 12 00 MOV   [USB_TransferType],0x0(0178)     MOV     [USB_TransferType], USB_TRANS_STATE_IDLE ; Transaction Idle State
07EC: 55 0B 00 MOV   [USB_Configuration],0x0(0179)     MOV     [USB_Configuration], 0     ; Unconfigured
07EF: 55 0C 00 MOV   [USB_DeviceStatus],0x0(0180)     MOV     [USB_DeviceStatus], 0      ; Clear the  device status
07F2: 55 30 00 MOV   [USB_bActivity],0x0(0181)     MOV     [USB_bActivity], 0         ; Clear the activity flag
07F5: 62 40 00 MOV   REG[0x40],0x0      (0182)     MOV     REG[USB_ADDR], 0           ; Clear the addfress and Address 0
07F8: 41 74 7F AND   REG[0x74],0x7F     (0183)     AND     REG[USB_USBXCR], ~USB_PULLUP_ENABLE ; Release D-
07FB: 41 E1 E0 AND   REG[0xE1],0xE0     
                                        (0184)     M8C_DisableIntMask    INT_MSK1, (INT_MSK1_USB_ACTIVITY | INT_MSK1_USB_BUS_RESET | INT_MSK1_USB_EP0 | INT_MSK1_USB_EP1 | INT_MSK1_USB_EP2) ; Enable the interrupt
                                        (0185) 
07FE: 7F       RET                      (0186)     RET
                                        (0187) .ENDSECTION
                                        (0188) ;-----------------------------------------------------------------------------
                                        (0189) ;  FUNCTION NAME: USB_bCheckActivity
                                        (0190) ;
                                        (0191) ;  DESCRIPTION:
                                        (0192) ;
                                        (0193) ;-----------------------------------------------------------------------------
                                        (0194) ;
                                        (0195) ;  ARGUMENTS:
                                        (0196) ;
                                        (0197) ;  RETURNS:
                                        (0198) ;
                                        (0199) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0200) ;
                                        (0201) ;  THEORY of OPERATION or PROCEDURE:
                                        (0202) ;
                                        (0203) ;   The activity interrupt sets a RAM flag indicating activity and disables the
                                        (0204) ;   interrupt.  Disabling the interrupt keeps the bus activity from creating too
                                        (0205) ;   many interrupts.  bCheckActivity checks and clears the flag, the enables
                                        (0206) ;   interrupts for the next interval.
                                        (0207) ;
                                        (0208) ;-----------------------------------------------------------------------------
                                        (0209) .SECTION
                                        (0210)  USB_bCheckActivity:
                                        (0211) _USB_bCheckActivity:
07FF: 51 30    MOV   A,[USB_bActivity]  (0212)     MOV    A, [USB_bActivity]          ; Activity?
0801: 39 01    CMP   A,0x1              (0213)     CMP    A, 1                        ; 
0803: A0 02    JZ    0x0806             (0214)     JZ     .active                     ; Jump on Activity
                                        (0215) ; Flow here on no activity
0805: 7F       RET                      (0216)     RET
                                        (0217) ; Jump here if activity was detected
                                        (0218) .active:
0806: 55 30 00 MOV   [USB_bActivity],0x0(0219)     MOV    [USB_bActivity], 0          ; Clear the activity flag for next time
0809: 43 E1 10 OR    REG[0xE1],0x10     
                                        (0220)     M8C_EnableIntMask INT_MSK1, INT_MSK1_USB_ACTIVITY ; Enable the activity interupt
080C: 7F       RET                      (0221)     RET
                                        (0222) .ENDSECTION
                                        (0223) ;-----------------------------------------------------------------------------
                                        (0224) ;  FUNCTION NAME: USB_bGetConfiguration
                                        (0225) ;
                                        (0226) ;  DESCRIPTION:   Returns the current configuration number
                                        (0227) ;
                                        (0228) ;-----------------------------------------------------------------------------
                                        (0229) ;
                                        (0230) ;  ARGUMENTS:    None
                                        (0231) ;
                                        (0232) ;  RETURNS:      A contains the current configuration number
                                        (0233) ;
                                        (0234) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0235) ;
                                        (0236) ;  THEORY of OPERATION or PROCEDURE:
                                        (0237) ;
                                        (0238) ;-----------------------------------------------------------------------------
                                        (0239) .SECTION
                                        (0240)  USB_bGetConfiguration:
                                        (0241) _USB_bGetConfiguration:
080D: 51 0B    MOV   A,[USB_Configuration](0242)     MOV     A,[USB_Configuration]
080F: 7F       RET                      (0243)     RET
                                        (0244) .ENDSECTION
                                        (0245) ;-----------------------------------------------------------------------------
                                        (0246) ;  FUNCTION NAME: USB_bGetEPState
                                        (0247) ;
                                        (0248) ;  DESCRIPTION:   Returns the current endpoint state
                                        (0249) ;
                                        (0250) ;-----------------------------------------------------------------------------
                                        (0251) ;
                                        (0252) ;  ARGUMENTS:   A: Endpoint Number
                                        (0253) ;
                                        (0254) ;  RETURNS:     A: NO_EVENT_ALLOWED
                                        (0255) ;                  EVENT_PENDING
                                        (0256) ;                  NO_EVENT_PENDING
                                        (0257) ;
                                        (0258) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0259) ;
                                        (0260) ;  THEORY of OPERATION or PROCEDURE:
                                        (0261) ;
                                        (0262) ;-----------------------------------------------------------------------------
                                        (0263) .SECTION
                                        (0264)  USB_bGetEPState:
                                        (0265) _USB_bGetEPState:
0810: 39 03    CMP   A,0x3              (0266)     CMP     A, (USB_MAX_EP_NUMBER + 1) ; Range check
0812: D0 06    JNC   0x0819             (0267)     JNC     .invalid_ep                ; Bail out
                                        (0268) ; Flow here to enable an endpoint        
0814: 5C       MOV   X,A                (0269)     MOV     X, A                       ; Endpoint number is the index
0815: 52 29    MOV   A,[X+41]           (0270)     MOV     A, [X+USB_EndpointAPIStatus]; Get the state
0817: 80 03    JMP   0x081B             (0271)     JMP     .exit                      ; Go to the common exit
                                        (0272) ; Jump here for an invalid endpoint
                                        (0273) .invalid_ep:
0819: 50 00    MOV   A,0x0              (0274)     MOV     A, 0                       ; Return 0 for an invalid ep
                                        (0275) ; Jump or flow here for a common exit
                                        (0276) .exit:
081B: 7F       RET                      (0277)     RET                                ; All done
                                        (0278) .ENDSECTION
                                        (0279) ;-----------------------------------------------------------------------------
                                        (0280) ;  FUNCTION NAME: USB_bRWUEnabled
                                        (0281) ;
                                        (0282) ;  DESCRIPTION:   Returns 1 if Remote Wake Up is enabled, otherwise 0
                                        (0283) ;
                                        (0284) ;-----------------------------------------------------------------------------
                                        (0285) ;
                                        (0286) ;  ARGUMENTS:   None
                                        (0287) ;
                                        (0288) ;  RETURNS:     A: 1--Remote Wake Up Enabled
                                        (0289) ;                  0--Remote Wake Up Disabled
                                        (0290) ;
                                        (0291) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0292) ;
                                        (0293) ;  THEORY of OPERATION or PROCEDURE:
                                        (0294) ;
                                        (0295) ;-----------------------------------------------------------------------------
                                        (0296) .SECTION
                                        (0297)  USB_bRWUEnabled:
                                        (0298) _USB_bRWUEnabled:
081C: 47 0C 02 TST   [USB_DeviceStatus],0x2(0299)     TST     [USB_DeviceStatus], USB_DEVICE_STATUS_REMOTE_WAKEUP
081F: B0 05    JNZ   0x0825             (0300)     JNZ     .enabled                   ; Jump if enabled
                                        (0301) ; Flow here if RWU is disabled        
0821: 50 00    MOV   A,0x0              (0302)     MOV     A, 0                       ; Return disabled
0823: 80 03    JMP   0x0827             (0303)     JMP     .exit                      ; Go to the common exit
                                        (0304) ; Jump when RWU is enabled
                                        (0305) .enabled:
0825: 50 01    MOV   A,0x1              (0306)     MOV     A, 1                       ; Return enabled
                                        (0307) ; Jump or flow here for a common exit
                                        (0308) .exit:
0827: 7F       RET                      (0309)     RET                                ; All done
                                        (0310) .ENDSECTION
                                        (0311) ;-----------------------------------------------------------------------------
                                        (0312) ;  FUNCTION NAME: USB_bGetEPCount
                                        (0313) ;
                                        (0314) ;  DESCRIPTION:
                                        (0315) ;
                                        (0316) ;-----------------------------------------------------------------------------
                                        (0317) ;
                                        (0318) ;  ARGUMENTS:
                                        (0319) ;
                                        (0320) ;  RETURNS:
                                        (0321) ;
                                        (0322) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0323) ;
                                        (0324) ;  THEORY of OPERATION or PROCEDURE:
                                        (0325) ;
                                        (0326) ;-----------------------------------------------------------------------------
                                        (0327) .SECTION
                                        (0328)  USB_bGetEPCount:
                                        (0329) _USB_bGetEPCount:
0828: 39 03    CMP   A,0x3              (0330)     CMP     A, (USB_MAX_EP_NUMBER + 1) ; Range check
082A: D0 0A    JNC   0x0835             (0331)     JNC     .invalid_ep                ; Bail out
                                        (0332) ; Flow here to get the endpoint count
082C: 5C       MOV   X,A                (0333)     MOV     X, A                       ; Endpoint number is the index
082D: 5E 41    MOV   A,REG[X+0x41]      (0334)     MOV     A, REG[X+EP0CNT]           ; Here is the count
082F: 21 1F    AND   A,0x1F             (0335)     AND     A, 0x1F                    ; Mask off the count
0831: 11 02    SUB   A,0x2              (0336)     SUB     A, 2                       ; Ours includes the two byte checksum
0833: 80 03    JMP   0x0837             (0337)     JMP     .exit                      ; Go to the common exit
                                        (0338) ; Jump here for an invalid endpoint
                                        (0339) .invalid_ep:
0835: 50 00    MOV   A,0x0              (0340)     MOV     A, 0                       ; Return 0 for an invalid ep
                                        (0341) ; Jump or flow here for a common exit
                                        (0342) .exit:
0837: 7F       RET                      (0343)     RET
                                        (0344) .ENDSECTION
                                        (0345) ;-----------------------------------------------------------------------------
                                        (0346) ;  FUNCTION NAME: USB_LoadEP
                                        (0347) ;
                                        (0348) ;  DESCRIPTION:    This function loads the specified endpoint buffer
                                        (0349) ;                  with the number of bytes previously set in the count
                                        (0350) ;                  register.
                                        (0351) ;
                                        (0352) ;-----------------------------------------------------------------------------
                                        (0353) ;
                                        (0354) ;  ARGUMENTS:  A:X Pointer to the ram buffer containing the data to transfer
                                        (0355) ;              USB_APIEPNumber loaded with the endpoint number
                                        (0356) ;              USB_APICount loaded with the number of bytes to load
                                        (0357) ;
                                        (0358) ;  RETURNS:    NONE
                                        (0359) ;
                                        (0360) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0361) ;
                                        (0362) ;  THEORY of OPERATION or PROCEDURE:
                                        (0363) ;
                                        (0364) ;-----------------------------------------------------------------------------
                                        (0365) .SECTION
                                        (0366)  USB_XLoadEP:
                                        (0367) _USB_XLoadEP:
                                        (0368) ; extern void USB_LoadEP(BYTE, BYTE*);
0838: 3C 2E 03 CMP   [USB_APIEPNumber],0x3(0369)     CMP     [USB_APIEPNumber], (USB_MAX_EP_NUMBER + 1) ; Range check
083B: D0 3F    JNC   0x087B             (0370)     JNC     .exit                      ; Bail out
                                        (0371) ; Flow here to get the endpoint count
083D: 5A 2C    MOV   [USB_APITemp],X    (0372)     MOV     [USB_APITemp], X           ; Use this temp as the MVI pointer
                                        (0373) 
083F: 51 2E    MOV   A,[USB_APIEPNumber](0374)     MOV     A, [USB_APIEPNumber]       ; Get the endpoint number
0841: F0 39    INDEX 0x087C             (0375)     INDEX   EPREGPTR                   ; Get the address of the endpoint data register array
0843: 5C       MOV   X,A                (0376)     MOV     X, A                       ; We are going to use index access to the register array
                                        (0377)     
0844: 51 2F    MOV   A,[USB_APICount]   (0378)     MOV     A, [USB_APICount]          ; Get the count
0846: 53 2D    MOV   [USB_APITemp+1],A  (0379)     MOV     [USB_APITemp+1], A         ; Use this temp as the count
                                        (0380) ; Copy loop
                                        (0381) .loop:
0848: 7A 2D    DEC   [USB_APITemp+1]    (0382)     DEC     [USB_APITemp+1]            ; Are we done?
084A: C0 08    JC    0x0853             (0383)     JC      .done                      ; Jump if we are
084C: 3E 2C    MVI   A,[USB_APITemp]    (0384)     MVI     A, [USB_APITemp]           ; Get the data, inc the pointer
084E: 61 00    MOV   REG[X+0x0],A       (0385)     MOV     REG[X + 0], A              ; Store the data
0850: 75       INC   X                  (0386)     INC     X                          ; Index the next data register
0851: 8F F6    JMP   0x0848             (0387)     JMP     .loop                      ; Copy the next byte or finish
                                        (0388) 
                                        (0389) ; Jump here when the copy is finished
                                        (0390) .done:
0853: 58 2E    MOV   X,[USB_APIEPNumber](0391)     MOV     X, [USB_APIEPNumber]       ; Get the endpoint number
0855: 5B       MOV   A,X                (0392)     MOV     A, X
0856: FF 67    INDEX USB_USB_EP_BIT_LOOKUP(0393)     INDEX   USB_USB_EP_BIT_LOOKUP
0858: 22 24    AND   A,[USB_EPDataToggle](0394)     AND     A, [USB_EPDataToggle]
085A: A0 03    JZ    0x085E             (0395)     JZ      .addcount
085C: 50 80    MOV   A,0x80             (0396)     MOV     A, USB_CNT_TOGGLE
                                        (0397) 
                                        (0398) .addcount:     
085E: 2A 2F    OR    A,[USB_APICount]   (0399)     OR      A, [USB_APICount]          ; Get the count
0860: 61 41    MOV   REG[X+0x41],A      (0400)     MOV     REG[X + EP0CNT], A         ; Update the count register
                                        (0401) 
0862: 56 29 00 MOV   [X+41],0x0         (0402)     MOV     [X + USB_EndpointAPIStatus], NO_EVENT_PENDING ; Set the state
                                        (0403) 
0865: 5D F7    MOV   A,REG[0xF7]        (0404)     MOV     A, REG[0xF7]  ; save GIE state
0867: 53 2C    MOV   [USB_APITemp],A    (0405)     MOV     [USB_APITemp], A  ; save GIE state
0869: 70 FE    AND   F,0xFE             
                                        (0406)     M8C_DisableGInt
                                        (0407) .write_again:
086B: 63 44 0D MOV   REG[X+0x44],0xD    (0408)     MOV     REG[X + EP0MODE], USB_MODE_ACK_IN ; Enable the endpoint
086E: 5E 44    MOV   A,REG[X+0x44]      (0409)     MOV     A, REG[X + EP0MODE]
0870: 39 0D    CMP   A,0xD              (0410)     CMP     A, USB_MODE_ACK_IN
0872: BF F8    JNZ   0x086B             (0411)     JNZ     .write_again
0874: 47 2C 01 TST   [USB_APITemp],0x1  (0412)     TST     [USB_APITemp], 0x01
0877: A0 03    JZ    0x087B             (0413)     JZ      .exit
0879: 71 01    OR    F,0x1              
                                        (0414)     M8C_EnableGInt
                                        (0415) 
                                        (0416) ; Jump or flow here for a common exit
                                        (0417) .exit:
087B: 7F       RET                      (0418)     RET
                                        (0419) .LITERAL
                                        (0420) EPREGPTR:    DB    EP0DATA, EP1DATA, EP2DATA
                                        (0421) .ENDLITERAL
                                        (0422) .ENDSECTION
                                        (0423) ;-----------------------------------------------------------------------------
                                        (0424) ;  FUNCTION NAME: USB_EnableEP
                                        (0425) ;
                                        (0426) ;  DESCRIPTION:    This function enables an OUT endpoint.  It should not be
                                        (0427) ;                  called for an IN endpoint.
                                        (0428) ;
                                        (0429) ;-----------------------------------------------------------------------------
                                        (0430) ;
                                        (0431) ;  ARGUMENTS:      A contains the endpoint number
                                        (0432) ;
                                        (0433) ;  RETURNS:        None
                                        (0434) ;
                                        (0435) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0436) ;
                                        (0437) ;  THEORY of OPERATION or PROCEDURE:
                                        (0438) ;
                                        (0439) ;-----------------------------------------------------------------------------
                                        (0440) .SECTION
                                        (0441)  USB_EnableOutEP:
                                        (0442) _USB_EnableOutEP:
                                        (0443)  USB_EnableEP:
                                        (0444) _USB_EnableEP:
087F: 39 00    CMP   A,0x0              (0445)     CMP     A, 0                       ; Can't enable EP0
0881: A0 0E    JZ    0x0890             (0446)     JZ      .exit                      ; Bail out
0883: 39 03    CMP   A,0x3              (0447)     CMP     A, (USB_MAX_EP_NUMBER + 1) ; Range check
0885: D0 0A    JNC   0x0890             (0448)     JNC     .exit                      ; Bail out
                                        (0449) ; Flow here to enable an endpoint        
0887: 5C       MOV   X,A                (0450)     MOV     X, A                       ; Endpoint number is the index
0888: 56 29 00 MOV   [X+41],0x0         (0451)     MOV     [X+USB_EndpointAPIStatus], NO_EVENT_PENDING ; For the API
088B: 5E 44    MOV   A,REG[X+0x44]      (0452)     MOV     A, REG[X+EP0MODE]          ; Unlock the mode register
088D: 63 44 09 MOV   REG[X+0x44],0x9    (0453)     MOV     REG[X+EP0MODE], USB_MODE_ACK_OUT ; Enable the endpoint
                                        (0454) ; Jump or flow here for a common exit
                                        (0455) .exit:
0890: 7F       RET                      (0456)     RET                                ; All done
                                        (0457) .ENDSECTION
                                        (0458) ;-----------------------------------------------------------------------------
                                        (0459) ;  FUNCTION NAME: USB_DisableEP
                                        (0460) ;
                                        (0461) ;  DESCRIPTION:    This function disables an OUT endpoint.  It should not be
                                        (0462) ;                  called for an IN endpoint.
                                        (0463) ;
                                        (0464) ;-----------------------------------------------------------------------------
                                        (0465) ;
                                        (0466) ;  ARGUMENTS:
                                        (0467) ;
                                        (0468) ;  RETURNS:
                                        (0469) ;
                                        (0470) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0471) ;
                                        (0472) ;  THEORY of OPERATION or PROCEDURE:
                                        (0473) ;
                                        (0474) ;-----------------------------------------------------------------------------
                                        (0475) .SECTION
                                        (0476)  USB_DisableOutEP:
                                        (0477) _USB_DisableOutEP:
                                        (0478)  USB_DisableEP:
                                        (0479) _USB_DisableEP:
0891: 39 00    CMP   A,0x0              (0480)     CMP     A, 0                       ; Can't disable EP0
0893: A0 0B    JZ    0x089F             (0481)     JZ      .exit                      ; Bail out
0895: 39 03    CMP   A,0x3              (0482)     CMP     A, (USB_MAX_EP_NUMBER + 1) ; Range check
0897: D0 07    JNC   0x089F             (0483)     JNC     .exit                      ; Bail out
                                        (0484) ; Flow here to disable an endpoint        
0899: 5C       MOV   X,A                (0485)     MOV     X, A                       ; Endpoint number is the index
089A: 5E 44    MOV   A,REG[X+0x44]      (0486)     MOV     A, REG[X+EP0MODE]          ; Unlock the mode register
089C: 63 44 08 MOV   REG[X+0x44],0x8    (0487)     MOV     REG[X+EP0MODE], USB_MODE_NAK_OUT ; Disable the endpoint
                                        (0488) ; Jump or flow here for a common exit
                                        (0489) .exit:
089F: 7F       RET                      (0490)     RET                                ; All done
                                        (0491) .ENDSECTION
                                        (0492) ;-----------------------------------------------------------------------------
                                        (0493) ;  FUNCTION NAME: USB_Force
                                        (0494) ;
                                        (0495) ;  DESCRIPTION:    Force the J/K/SE0 State of D+/D-
                                        (0496) ;
                                        (0497) ;-----------------------------------------------------------------------------
                                        (0498) ;
                                        (0499) ;  ARGUMENTS:     A: USB_FORCE_J
                                        (0500) ;                    USB_FORCE_K
                                        (0501) ;                    USB_FORCE_SE0
                                        (0502) ;                    USB_FORCE_NONE
                                        (0503) ;
                                        (0504) ;  RETURNS:       Nothing
                                        (0505) ;
                                        (0506) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0507) ;
                                        (0508) ;  THEORY of OPERATION or PROCEDURE:
                                        (0509) ;
                                        (0510) ;-----------------------------------------------------------------------------
                                        (0511) .SECTION
                                        (0512)  USB_Force:
                                        (0513) _USB_Force:
08A0: 39 FF    CMP   A,0xFF             (0514)     CMP    A, USB_FORCE_NONE           ; Are we done forcing D+/D-?
08A2: A0 28    JZ    0x08CB             (0515)     JZ     .none                       ; Jump if we are done
                                        (0516) ; Flow here to start checking 
08A4: 39 02    CMP   A,0x2              (0517)     CMP    A, USB_FORCE_J              ; Force J?
08A6: B0 09    JNZ   0x08B0             (0518)     JNZ    .check_k                    ; Jump if not J
                                        (0519) ; Flow here to force J
08A8: 2E 03 02 OR    [0x3],0x2          (0520)     OR     [Port_1_Data_SHADE], 0x02   ; D- = 1
08AB: 26 03 FE AND   [0x3],0xFE         (0521)     AND    [Port_1_Data_SHADE], ~(0x01); D+ = 0
08AE: 80 14    JMP   0x08C3             (0522)     JMP    .force                      ; Go set the force register
                                        (0523) ; Jump here to check Force K
                                        (0524) .check_k:
08B0: 39 01    CMP   A,0x1              (0525)     CMP    A, USB_FORCE_K              ; Force K?
08B2: B0 09    JNZ   0x08BC             (0526)     JNZ    .check_se0                  ; Jump if not K
                                        (0527) ; Flow here to force K
08B4: 2E 03 01 OR    [0x3],0x1          (0528)     OR     [Port_1_Data_SHADE], 0x01   ; D+ = 1
08B7: 26 03 FD AND   [0x3],0xFD         (0529)     AND    [Port_1_Data_SHADE], ~(0x02); D- = 0
08BA: 80 08    JMP   0x08C3             (0530)     JMP    .force                      ; Go set the force register
                                        (0531) ; Jump here to check Force SE0
                                        (0532) .check_se0:
08BC: 39 00    CMP   A,0x0              (0533)     CMP    A, USB_FORCE_SE0            ; Force SE0?
08BE: A0 0F    JZ    0x08CE             (0534)     JZ     .invalid                    ; Jump if not SE0
                                        (0535) ; Flow here to force SE0
08C0: 26 03 FC AND   [0x3],0xFC         (0536)     AND    [Port_1_Data_SHADE], ~(0x03); D- = 0,  D+ = 0
                                        (0537) ; Jump or flow here to enable forcing (Port bits are set in the shadow register)
                                        (0538) .force:
08C3: 51 03    MOV   A,[0x3]            (0539)     MOV    A, [Port_1_Data_SHADE]      ; Get the shadow
08C5: 60 01    MOV   REG[0x1],A         (0540)     MOV    REG[P1DATA], A              ; Update the port
08C7: 43 74 01 OR    REG[0x74],0x1      (0541)     OR     REG[USBXCR], USB_FORCE_STATE; Enable FORCING D+/D-
08CA: 7F       RET                      (0542)     RET                                ; Exit
                                        (0543) ; Jump here to clear forcing
                                        (0544) .none:
08CB: 41 74 FE AND   REG[0x74],0xFE     (0545)     AND    REG[USBXCR], ~(USB_FORCE_STATE) ; Disable FORCING D+/D-
                                        (0546) ; Jump or flow here to exit on end forcing or an invalid parameter
                                        (0547) .invalid:
08CE: 7F       RET                      (0548)     RET                                ; Exit
                                        (0549) .ENDSECTION
                                        (0550) ;-----------------------------------------------------------------------------
                                        (0551) ;  FUNCTION NAME: USB_Suspend
                                        (0552) ;
                                        (0553) ;  DESCRIPTION:    Puts the USB Transceiver into power-down mode, while
                                        (0554) ;                  maintaining the USB address assigned by the USB host. 
                                        (0555) ;                  To restore the USB Transceiver to normal operation, the
                                        (0556) ;                  USB_Resume function should be called.
                                        (0557) ;
                                        (0558) ;-----------------------------------------------------------------------------
                                        (0559) ;
                                        (0560) ;  ARGUMENTS:     None
                                        (0561) ;
                                        (0562) ;  RETURNS:       Nothing
                                        (0563) ;
                                        (0564) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0565) ;
                                        (0566) ;  THEORY of OPERATION or PROCEDURE:
                                        (0567) ;
                                        (0568) ;-----------------------------------------------------------------------------
                                        (0569) .SECTION
                                        (0570)  USB_Suspend:
                                        (0571) _USB_Suspend:
08CF: 41 40 7F AND   REG[0x40],0x7F     (0572)     AND     REG[USB_ADDR], ~(USB_ADDR_ENABLE) ; Disable transceiver
08D2: 7F       RET                      (0573)     RET                                ; Exit
                                        (0574) .ENDSECTION
                                        (0575) ;-----------------------------------------------------------------------------
                                        (0576) ;  FUNCTION NAME: USB_Resume
                                        (0577) ;
                                        (0578) ;  DESCRIPTION:    Puts the USB Transceiver into normal operation, following
                                        (0579) ;                  a call to USB_Suspend. It retains the USB address that had
                                        (0580) ;                  been assigned by the USB host.
                                        (0581) ;
                                        (0582) ;-----------------------------------------------------------------------------
                                        (0583) ;
                                        (0584) ;  ARGUMENTS:     None
                                        (0585) ;
                                        (0586) ;  RETURNS:       Nothing
                                        (0587) ;
                                        (0588) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0589) ;
                                        (0590) ;  THEORY of OPERATION or PROCEDURE:
                                        (0591) ;
                                        (0592) ;-----------------------------------------------------------------------------
                                        (0593) .SECTION
                                        (0594)  USB_Resume:
                                        (0595) _USB_Resume:
08D3: 43 40 80 OR    REG[0x40],0x80     (0596)     OR     REG[USB_ADDR], (USB_ADDR_ENABLE) ; Enable transceiver
08D6: 7F       RET                      (0597)     RET                                ; Exit
                                        (0598) .ENDSECTION
                                        (0599) 
                                        (0600) ;-----------------------------------------------------------------------------
                                        (0601) ;  FUNCTION NAME: USB_bReadOutEP
                                        (0602) ;
                                        (0603) ;  DESCRIPTION:    This function reads the data from the USB Out endpoint
                                        (0604) ;                  and loads it into the specified buffer.
                                        (0605) ;
                                        (0606) ;-----------------------------------------------------------------------------
                                        (0607) ;
                                        (0608) ;  ARGUMENTS:
                                        (0609) ;     [SP-6] Count to read
                                        (0610) ;     [SP-5] MSB of data array address to put data in
                                        (0611) ;     [SP-4] LSB of data array address to put data in
                                        (0612) ;     [SP-3] Endpoint Number
                                        (0613) ;
                                        (0614) ;  RETURNS:   The number of bytes sent by the host
                                        (0615) ;
                                        (0616) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0617) ;
                                        (0618) .SECTION
                                        (0619) 
                                        (0620) EP_NUMR:     equ -3           ; Endpoint Number
                                        (0621) DATA_LSBR:   equ -4           ; MSB pointer of data
                                        (0622) DATA_MSBR:   equ -5           ; LSB pointer of data
                                        (0623) CNT_LENR:    equ -6           ; Length of data to send
                                        (0624) 
                                        (0625) BYTE_CNT_BITMASK:   equ 0x0F
                                        (0626) BYTE_CNT_CHKSUM:    equ 0x02
                                        (0627)  USB_bReadOutEP:
                                        (0628) _USB_bReadOutEP:
                                        (0629) 
08D7: 4F       MOV   X,SP               (0630)     MOV     X, SP
08D8: 52 FD    MOV   A,[X-3]            (0631)     MOV     A, [X+EP_NUMR]
08DA: 39 03    CMP   A,0x3              (0632)     CMP     A, USB_MAX_EP_NUMBER+1     ; Range check
08DC: D0 2F    JNC   0x090C             (0633)     JNC     .exit                      ; Bail out
                                        (0634) 
                                        (0635)     ;Get the count value passed
08DE: 52 FA    MOV   A,[X-6]            (0636)     MOV     A, [X+CNT_LENR]            ; Get the Count
08E0: 53 2C    MOV   [USB_APITemp],A    (0637)     MOV     [USB_APITemp], A           ; Save the count
                                        (0638) 
                                        (0639)     ;Determine which is smaller the requested data or the available data
08E2: 52 FD    MOV   A,[X-3]            (0640)     MOV     A, [X+EP_NUMR]              ; Get the Endpoint number
08E4: 5C       MOV   X,A                (0641)     MOV     X, A                        ; Make it into an index
08E5: 5E 41    MOV   A,REG[X+0x41]      (0642)     MOV     A, reg[X+USB_EP0CNT]        ; Get the Real count
08E7: 21 0F    AND   A,0xF              (0643)     AND     A, BYTE_CNT_BITMASK         ; Mask off the count bits
08E9: 11 02    SUB   A,0x2              (0644)     SUB     A, BYTE_CNT_CHKSUM         ; Count includes the two byte checksum    
08EB: 53 2F    MOV   [USB_APICount],A   (0645)     MOV     [USB_APICount], A           ; Save the Real count of bytes sent by the host
08ED: 3A 2C    CMP   A,[USB_APITemp]    (0646)     CMP     A, [USB_APITemp]            ; Are they equal
08EF: D0 03    JNC   0x08F3             (0647)     JNC     .CountDetermined            ;If the requested count is smaller use it
08F1: 53 2C    MOV   [USB_APITemp],A    (0648)     MOV     [USB_APITemp], A            ; Else use the actual
                                        (0649) 
                                        (0650) .CountDetermined:
                                        (0651)     ; Now we are ready to start moving data
08F3: 51 2C    MOV   A,[USB_APITemp]    (0652)     MOV     A, [USB_APITemp]            ; Check the Count
08F5: A0 16    JZ    0x090C             (0653)     JZ      .done                       ; If it is 0 then we have a 0 length packet
                                        (0654) 
08F7: 4F       MOV   X,SP               (0655)     MOV     X, SP                       ; Get the Stack Pointer
08F8: 52 FC    MOV   A,[X-4]            (0656)     MOV     A, [X+DATA_LSBR]            ; Get the LSB of the pointer
08FA: 53 2D    MOV   [USB_APITemp+1],A  (0657)     MOV     [USB_APITemp+1], A          ; Save the LSB of the pointer
                                        (0658)     
08FC: 52 FD    MOV   A,[X-3]            (0659)     MOV     A, [X+EP_NUMR]              ; Get the Endpoint number
08FE: FF 7C    INDEX 0x087C             (0660)     INDEX   EPREGPTR                      ; Get the address of the endpoint data register array
0900: 5C       MOV   X,A                (0661)     MOV     X, A                          ; We are going to use index access to the register array    
                                        (0662)     
                                        (0663) .loop:
0901: 5E 00    MOV   A,REG[X+0x0]       (0664)     MOV     A, reg[X]                   ; Get the data from the EP Data Buffer
0903: 3F 2D    MVI   [USB_APITemp+1],A  (0665)     MVI     [USB_APITemp+1], A          ; save it in data array
0905: 75       INC   X                  (0666)     INC     X                           ; increment the pointer
0906: 7A 2C    DEC   [USB_APITemp]      (0667)     DEC     [USB_APITemp]               ; decrement the counter
0908: BF F8    JNZ   0x0901             (0668)     JNZ     .loop                       ; wait for count to zero out
                                        (0669) 
                                        (0670) 
090A: 51 2F    MOV   A,[USB_APICount]   (0671)     MOV     A, [USB_APICount]           ; Get the Real count LSB
                                        (0672) .done:
                                        (0673) .exit:
090C: 7F       RET                      (0674)     RET
                                        (0675) .ENDSECTION
                                        (0676) 
                                        (0677) ;-----------------------------------------------------------------------------
                                        (0678) ;  FUNCTION NAME: USB_bGetEPAckState
                                        (0679) ;
                                        (0680) ;  DESCRIPTION:   Returns whether the ACK bit of EP has been set for
                                        (0681) ;                 an endpoint
                                        (0682) ;
                                        (0683) ;-----------------------------------------------------------------------------
                                        (0684) ;
                                        (0685) ;  ARGUMENTS:     A is the Endpoint Number
                                        (0686) ;
                                        (0687) ;  RETURNS:       A is 0 if ACK bit is not set and non-zero if it is
                                        (0688) ;
                                        (0689) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0690) ;
                                        (0691) .SECTION
                                        (0692) ACK_BITMASK:    equ 0x10
                                        (0693)  USB_bGetEPAckState:
                                        (0694) _USB_bGetEPAckState:
090D: 5C       MOV   X,A                (0695)     mov    X, A
090E: 5E 44    MOV   A,REG[X+0x44]      (0696)     mov    A, reg[X + USB_EP0MODE]
0910: 21 10    AND   A,0x10             (0697)     and    A, ACK_BITMASK ; Get ACK bit
0912: 7F       RET                      (0698)     ret                                ; Exit
                                        (0699) .ENDSECTION
                                        (0700) 
                                        (0701) ;-----------------------------------------------------------------------------
                                        (0702) ;  FUNCTION NAME: USB_SetPowerStatus
                                        (0703) ;
                                        (0704) ;  DESCRIPTION:    Set The Current Power status.
                                        (0705) ;
                                        (0706) ;-----------------------------------------------------------------------------
                                        (0707) ;
                                        (0708) ;  ARGUMENTS:      A contains the power status
                                        (0709) ;
                                        (0710) ;  RETURNS:        None
                                        (0711) ;
                                        (0712) ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                        (0713) ;
                                        (0714) .SECTION
                                        (0715)  USB_SetPowerStatus:
                                        (0716) _USB_SetPowerStatus:
0913: 39 00    CMP   A,0x0              (0717)     cmp     A, USB_DEVICE_STATUS_BUS_POWERED     
0915: A0 06    JZ    0x091C             (0718)     jz      .bus_powered
0917: 2E 0C 01 OR    [USB_DeviceStatus],0x1(0719)     or      [USB_DeviceStatus], USB_DEVICE_STATUS_SELF_POWERED
091A: 80 04    JMP   0x091F             (0720)     jmp     .done
                                        (0721) .bus_powered:
091C: 26 0C FE AND   [USB_DeviceStatus],0xFE(0722)     and     [USB_DeviceStatus], ~USB_DEVICE_STATUS_SELF_POWERED
                                        (0723) .done:
091F: 7F       RET                      (0724)     ret                                ; All done
                                        (0725) .ENDSECTION
                                        (0726) 
                                        (0727) ;-----------------------------------------------
                                        (0728) ; Add custom application code for routines 
                                        (0729) ;-----------------------------------------------
                                        (0730) 
                                        (0731)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
                                        (0732)    ;---------------------------------------------------
                                        (0733)    ; Insert your custom code below this banner
                                        (0734)    ;---------------------------------------------------
                                        (0735) 
                                        (0736)    ;---------------------------------------------------
                                        (0737)    ; Insert your custom code above this banner
                                        (0738)    ;---------------------------------------------------
                                        (0739)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0740) 
                                        (0741) ; End of File USB.asm
FILE: .\boot.asm
0920: 7E       RETI                     (0390)    RETI
                                        (0391) ;-----------------------------------------------------------------------------
                                        (0392) ;  FUNCTION NAME: INT1_ISR
                                        (0393) ;
                                        (0394) ;  DESCRIPTION:   This is the ISR for the the INT1 GPIO interrupt
                                        (0395) ;
                                        (0396) ;-----------------------------------------------------------------------------
                                        (0397) INT1_ISR:
                                        (0398)    ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
                                        (0399)    ;---------------------------------------------------
                                        (0400)    ; Insert your custom code below this banner
                                        (0401)    ;---------------------------------------------------
                                        (0402)    ;   NOTE: interrupt service routines must preserve
                                        (0403)    ;   the values of the A and X CPU registers.
                                        (0404) 
                                        (0405)    ;---------------------------------------------------
                                        (0406)    ; Insert your custom code above this banner
                                        (0407)    ;---------------------------------------------------
                                        (0408)    ;@PSoC_UserCode_END@ (Do not change this line.)
0921: 7E       RETI                     (0409)    RETI
                                        (0410) ;-----------------------------------------------------------------------------
                                        (0411) ;  FUNCTION NAME: INT2_ISR
                                        (0412) ;
                                        (0413) ;  DESCRIPTION:   This is the ISR for the the INT2 GPIO interrupt
                                        (0414) ;
                                        (0415) ;-----------------------------------------------------------------------------
                                        (0416) INT2_ISR:
                                        (0417)    ;@PSoC_UserCode_BODY_3@ (Do not change this line.)
                                        (0418)    ;---------------------------------------------------
                                        (0419)    ; Insert your custom code below this banner
                                        (0420)    ;---------------------------------------------------
                                        (0421)    ;   NOTE: interrupt service routines must preserve
                                        (0422)    ;   the values of the A and X CPU registers.
                                        (0423) 
                                        (0424)    ;---------------------------------------------------
                                        (0425)    ; Insert your custom code above this banner
                                        (0426)    ;---------------------------------------------------
                                        (0427)    ;@PSoC_UserCode_END@ (Do not change this line.)
0922: 7E       RETI                     (0428)    RETI
                                        (0429) ;-----------------------------------------------------------------------------
                                        (0430) ;  FUNCTION NAME: PORT0_ISR
                                        (0431) ;
                                        (0432) ;  DESCRIPTION:   This is the ISR for the the PORT0 GPIO interrupt
                                        (0433) ;                 Note: Interrupts for GPIO P0.2, P0.3, and P0.4 are
                                        (0434) ;                 not dispatched through this ISR.  Those interrupts
                                        (0435) ;                 are dipatched through INT0, INT1 and INT2 respectively.
                                        (0436) ;
                                        (0437) ;-----------------------------------------------------------------------------
                                        (0438) PORT0_ISR:
                                        (0439)    ;@PSoC_UserCode_BODY_4@ (Do not change this line.)
                                        (0440)    ;---------------------------------------------------
                                        (0441)    ; Insert your custom code below this banner
                                        (0442)    ;---------------------------------------------------
                                        (0443)    ;   NOTE: interrupt service routines must preserve
                                        (0444)    ;   the values of the A and X CPU registers.
                                        (0445) 
                                        (0446)    ;---------------------------------------------------
                                        (0447)    ; Insert your custom code above this banner
                                        (0448)    ;---------------------------------------------------
                                        (0449)    ;@PSoC_UserCode_END@ (Do not change this line.)
0923: 7E       RETI                     (0450)    RETI
                                        (0451) ;-----------------------------------------------------------------------------
                                        (0452) ;  FUNCTION NAME: PORT1_ISR
                                        (0453) ;
                                        (0454) ;  DESCRIPTION:   This is the ISR for the the PORT1 GPIO interrupt
                                        (0455) ;
                                        (0456) ;-----------------------------------------------------------------------------
                                        (0457) PORT1_ISR:
                                        (0458)    ;@PSoC_UserCode_BODY_5@ (Do not change this line.)
                                        (0459)    ;---------------------------------------------------
                                        (0460)    ; Insert your custom code below this banner
                                        (0461)    ;---------------------------------------------------
                                        (0462)    ;   NOTE: interrupt service routines must preserve
                                        (0463)    ;   the values of the A and X CPU registers.
                                        (0464) 
                                        (0465)    ;---------------------------------------------------
                                        (0466)    ; Insert your custom code above this banner
                                        (0467)    ;---------------------------------------------------
                                        (0468)    ;@PSoC_UserCode_END@ (Do not change this line.)
0924: 7E       RETI                     (0469)    RETI
                                        (0470) ;-----------------------------------------------------------------------------
                                        (0471) ;  FUNCTION NAME: PORT2_ISR
                                        (0472) ;
                                        (0473) ;  DESCRIPTION:   This is the ISR for the the PORT2 GPIO interrupt
                                        (0474) ;
                                        (0475) ;-----------------------------------------------------------------------------
                                        (0476) PORT2_ISR:
                                        (0477)    ;@PSoC_UserCode_BODY_5@ (Do not change this line.)
                                        (0478)    ;---------------------------------------------------
                                        (0479)    ; Insert your custom code below this banner
                                        (0480)    ;---------------------------------------------------
                                        (0481)    ;   NOTE: interrupt service routines must preserve
                                        (0482)    ;   the values of the A and X CPU registers.
                                        (0483) 
                                        (0484)    ;---------------------------------------------------
                                        (0485)    ; Insert your custom code above this banner
                                        (0486)    ;---------------------------------------------------
                                        (0487)    ;@PSoC_UserCode_END@ (Do not change this line.)
0925: 7E       RETI                     (0488)    RETI
                                        (0489) ;-----------------------------------------------------------------------------
                                        (0490) ;  FUNCTION NAME: PORT3_ISR
                                        (0491) ;
                                        (0492) ;  DESCRIPTION:   This is the ISR for the the PORT3 GPIO interrupt
                                        (0493) ;
                                        (0494) ;-----------------------------------------------------------------------------
                                        (0495) PORT3_ISR:
                                        (0496)    ;@PSoC_UserCode_BODY_6@ (Do not change this line.)
                                        (0497)    ;---------------------------------------------------
                                        (0498)    ; Insert your custom code below this banner
                                        (0499)    ;---------------------------------------------------
                                        (0500)    ;   NOTE: interrupt service routines must preserve
                                        (0501)    ;   the values of the A and X CPU registers.
                                        (0502) 
                                        (0503)    ;---------------------------------------------------
                                        (0504)    ; Insert your custom code above this banner
                                        (0505)    ;---------------------------------------------------
                                        (0506)    ;@PSoC_UserCode_END@ (Do not change this line.)
0926: 7E       RETI                     (0507)    RETI
                                        (0508) ;-----------------------------------------------------------------------------
                                        (0509) ; End GPIO Interrupt Service Routines
                                        (0510) ;-----------------------------------------------------------------------------
                                        (0511) ;end of file
FILE: C:\Users\IEUser\DOCUME~1\PSOCDE~1.4PR\PDPROJ~1\PDPROJ~1\main.c
(0001) //----------------------------------------------------------------------------
(0002) // C main line
(0003) //----------------------------------------------------------------------------
(0004) 
(0005) #include <m8c.h>        // part specific constants and macros
(0006) #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
(0007) #include <string.h>
(0008) 
(0009) // Port_0_0 - Port_0_5 are the 6 led pins
(0010) #define TOP_BLUE (1 << 4)
(0011) #define TOP_RED (1 << 2)
(0012) #define TOP_GREEN (1 << 0)
(0013) 
(0014) #define BOT_BLUE (1 << 5)
(0015) #define BOT_RED (1 << 3)
(0016) #define BOT_GREEN (1 << 1)
(0017) 
(0018) // intensities
(0019) unsigned char inten[6];
(0020) 
(0021) #pragma  ioport   EP1DATA_0:    0x058
(0022) BYTE              EP1DATA_0;
(0023) #pragma  ioport   EP1DATA_1:    0x059
(0024) BYTE              EP1DATA_1;
(0025) #pragma  ioport   EP1DATA_2:    0x05A
(0026) BYTE              EP1DATA_2;
(0027) #pragma  ioport   EP1DATA_3:    0x05B
(0028) BYTE              EP1DATA_3;
(0029) #pragma  ioport   EP1DATA_4:    0x05C
(0030) BYTE              EP1DATA_4;
(0031) #pragma  ioport   EP1DATA_5:    0x05D
(0032) BYTE              EP1DATA_5;
(0033) 
(0034) void main(void) {
__text_start|_main|_main:
  dat                  --> X+1
  cnt                  --> X+0
    0927: 10       PUSH  X
    0928: 4F       MOV   X,SP
    0929: 38 02    ADD   SP,0x2
(0035) 	unsigned char cnt, dat;
(0036) 	
(0037) 	// init intensities
(0038) 	memset(inten, 0, 6);
    092B: 50 00    MOV   A,0x0
    092D: 08       PUSH  A
    092E: 50 06    MOV   A,0x6
    0930: 08       PUSH  A
    0931: 50 00    MOV   A,0x0
    0933: 08       PUSH  A
    0934: 08       PUSH  A
    0935: 50 00    MOV   A,0x0
    0937: 08       PUSH  A
    0938: 50 04    MOV   A,0x4
    093A: 08       PUSH  A
    093B: 7C 09 F9 LCALL _memset
    093E: 38 FA    ADD   SP,0xFA
(0039) 	
(0040) 	// testing
(0041) 	//inten[0] = 10;
(0042) 	
(0043) 	// enable sleep timer
(0044) 	//INT_MSK0 |= INT_MSK0_SLEEP;
(0045) 	
(0046) 	// enable all interrupts
(0047) 	M8C_EnableGInt;
    0940: 71 01    OR    F,0x1
(0048) 	
(0049) 	// wait for enumeration
(0050) 	USB_Start(0);
    0942: 10       PUSH  X
    0943: 50 00    MOV   A,0x0
    0945: 7C 07 C2 LCALL _USB_Start
    0948: 20       POP   X
(0051) 	while (!USB_bGetConfiguration()){}
    0949: 10       PUSH  X
    094A: 7C 08 0D LCALL _USB_bGetConfiguration
    094D: 20       POP   X
    094E: 39 00    CMP   A,0x0
    0950: AF F8    JZ    0x0949
(0052) 	USB_EnableEP(1);
    0952: 10       PUSH  X
    0953: 50 01    MOV   A,0x1
    0955: 7C 08 7F LCALL _USB_EnableOutEP|_USB_EnableEP|USB_EnableEP
    0958: 20       POP   X
(0053) 	
(0054) 	//USB_bReadOutEP
(0055) 	
(0056) 	cnt = 0;
    0959: 56 00 00 MOV   [X+0],0x0
    095C: 80 63    JMP   0x09C0
(0057) 	while (1) {
(0058) 		dat = 0;
    095E: 56 01 00 MOV   [X+1],0x0
(0059) 		
(0060) 		if (USB_bGetEPCount(1) == 6) {
    0961: 10       PUSH  X
    0962: 50 01    MOV   A,0x1
    0964: 7C 08 28 LCALL _USB_bGetEPCount
    0967: 20       POP   X
    0968: 39 06    CMP   A,0x6
    096A: B0 19    JNZ   0x0984
(0061) 			USB_bReadOutEP(1, inten, 6);
    096C: 10       PUSH  X
    096D: 50 06    MOV   A,0x6
    096F: 08       PUSH  A
    0970: 50 00    MOV   A,0x0
    0972: 08       PUSH  A
    0973: 50 04    MOV   A,0x4
    0975: 08       PUSH  A
    0976: 50 01    MOV   A,0x1
    0978: 08       PUSH  A
    0979: 7C 08 D7 LCALL _USB_bReadOutEP
    097C: 38 FC    ADD   SP,0xFC
(0062) 			USB_EnableEP(1);
    097E: 50 01    MOV   A,0x1
    0980: 7C 08 7F LCALL _USB_EnableOutEP|_USB_EnableEP|USB_EnableEP
    0983: 20       POP   X
(0063) 		}
(0064) 		
(0065) 		// 100% isn't possible...err
(0066) 		if (cnt < inten[0]) dat |= TOP_BLUE;
    0984: 52 00    MOV   A,[X+0]
    0986: 3A 04    CMP   A,[inten]
    0988: D0 04    JNC   0x098D
    098A: 2F 01 10 OR    [X+1],0x10
(0067) 		if (cnt < inten[1]) dat |= TOP_RED;
    098D: 52 00    MOV   A,[X+0]
    098F: 3A 05    CMP   A,[inten+1]
    0991: D0 04    JNC   0x0996
    0993: 2F 01 04 OR    [X+1],0x4
(0068) 		if (cnt < inten[2]) dat |= TOP_GREEN;
    0996: 52 00    MOV   A,[X+0]
    0998: 3A 06    CMP   A,[inten+2]
    099A: D0 04    JNC   0x099F
    099C: 2F 01 01 OR    [X+1],0x1
(0069) 		if (cnt < inten[3]) dat |= BOT_BLUE;
    099F: 52 00    MOV   A,[X+0]
    09A1: 3A 07    CMP   A,[inten+3]
    09A3: D0 04    JNC   0x09A8
    09A5: 2F 01 20 OR    [X+1],0x20
(0070) 		if (cnt < inten[4]) dat |= BOT_RED;
    09A8: 52 00    MOV   A,[X+0]
    09AA: 3A 08    CMP   A,[inten+4]
    09AC: D0 04    JNC   0x09B1
    09AE: 2F 01 08 OR    [X+1],0x8
(0071) 		if (cnt < inten[5]) dat |= BOT_GREEN;
    09B1: 52 00    MOV   A,[X+0]
    09B3: 3A 09    CMP   A,[inten+5]
    09B5: D0 04    JNC   0x09BA
    09B7: 2F 01 02 OR    [X+1],0x2
(0072) 		
(0073) 		P0DATA = dat;
    09BA: 52 01    MOV   A,[X+1]
    09BC: 60 00    MOV   REG[0x0],A
(0074) 		
(0075) 		// will rollover
(0076) 		cnt += 1;
    09BE: 77 00    INC   [X+0]
(0077) 	}
    09C0: 8F 9D    JMP   0x095E
(0078) }
FILE: lib\usbint.asm                    (0001) ;;*****************************************************************************
                                        (0002) ;;*****************************************************************************
                                        (0003) ;;  FILENAME: USBINT.asm
                                        (0004) ;;   Version: 1.90, Updated on 2015/3/4 at 22:20:18
                                        (0005) ;;  Generated by PSoC Designer 5.4.3191
                                        (0006) ;;
                                        (0007) ;;  DESCRIPTION: USB Device User Module software implementation file
                                        (0008) ;;
                                        (0009) ;;  NOTE: User Module APIs conform to the fastcall convention for marshalling
                                        (0010) ;;        arguments and observe the associated "Registers are volatile" policy.
                                        (0011) ;;        This means it is the caller's responsibility to preserve any values
                                        (0012) ;;        in the X and A registers that are still needed after the API
                                        (0013) ;;        function returns. Even though these registers may be preserved now,
                                        (0014) ;;        there is no guarantee they will be preserved in future releases.
                                        (0015) ;;-----------------------------------------------------------------------------
                                        (0016) ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0017) ;;*****************************************************************************
                                        (0018) ;;*****************************************************************************
                                        (0019) 
                                        (0020) include "m8c.inc"
                                        (0021) include "USB_macros.inc"
                                        (0022) include "USB.inc"
                                        (0023) 
                                        (0024) ;-----------------------------------------------
                                        (0025) ;  Global Symbols
                                        (0026) ;-----------------------------------------------
                                        (0027) 
                                        (0028) AREA bss (RAM,REL)
                                        (0029) 
                                        (0030) ;-----------------------------------------------
                                        (0031) ;  Constant Definitions
                                        (0032) ;-----------------------------------------------
                                        (0033) ;-----------------------------------------------
                                        (0034) ; Variable Allocation
                                        (0035) ;-----------------------------------------------
                                        (0036) 
                                        (0037) AREA text (ROM, REL)
                                        (0038) ;-----------------------------------------------------------------------------
                                        (0039) ;  FUNCTION NAME: USB_EP1_ISR
                                        (0040) ;
                                        (0041) ;  DESCRIPTION:    Handle the Endpoint 1 event by updating the data toggle
                                        (0042) ;                  and setting the endpoint state to EVENT_PENDING.  The SIE
                                        (0043) ;                  automatically set the mode to NAK both IN and out transfers
                                        (0044) ;-----------------------------------------------------------------------------
                                        (0045) export  USB_EP1_ISR
                                        (0046) export _USB_EP1_ISR
                                        (0047)  USB_EP1_ISR:
                                        (0048) _USB_EP1_ISR:
                                        (0049)    ;@PSoC_UserCode_BODY_EP1@ (Do not change this line.)
                                        (0050)    ;---------------------------------------------------
                                        (0051)    ; Insert your custom code below this banner
                                        (0052)    ;---------------------------------------------------
                                        (0053)    ;   NOTE: interrupt service routines must preserve
                                        (0054)    ;   the values of the A and X CPU registers.
                                        (0055) STD_EP1:    EQU     1   ; Set this equate to 0 to remove the standard
                                        (0056)                         ; endpoint handling code
                                        (0057)    ;---------------------------------------------------
                                        (0058)    ; Insert your custom code above this banner
                                        (0059)    ;---------------------------------------------------
                                        (0060)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0061) 
                                        (0062) IF  STD_EP1
09C7: 08       PUSH  A                  (0063)     PUSH A
09C8: 36 24 02 XOR   [USB_EPDataToggle],0x2(0064)     XOR     [USB_EPDataToggle], 2 ; Update EP1 data toggle
09CB: 5D 45    MOV   A,REG[0x45]        (0065)     MOV     A, REG[EP1MODE]            ; Get the mode
09CD: 55 2A 01 MOV   [USB_EndpointAPIStatus+1],0x1(0066)     MOV     [USB_EndpointAPIStatus+1], EVENT_PENDING ; For the API
09D0: 18       POP   A                  (0067)     POP A
09D1: 7E       RETI                     (0068)     RETI
                                        (0069) ENDIF
                                        (0070) ;-----------------------------------------------------------------------------
                                        (0071) ;  FUNCTION NAME: USB_EP2_ISR
                                        (0072) ;
                                        (0073) ;  DESCRIPTION:    Handle the Endpoint 2 event by updating the data toggle
                                        (0074) ;                  and setting the endpoint state to EVENT_PENDING.  The SIE
                                        (0075) ;                  automatically set the mode to NAK both IN and out transfers
                                        (0076) ;-----------------------------------------------------------------------------
                                        (0077) export  USB_EP2_ISR
                                        (0078) export _USB_EP2_ISR
                                        (0079)  USB_EP2_ISR:
                                        (0080) _USB_EP2_ISR:
                                        (0081)    ;@PSoC_UserCode_BODY_EP2@ (Do not change this line.)
                                        (0082)    ;---------------------------------------------------
                                        (0083)    ; Insert your custom code below this banner
                                        (0084)    ;---------------------------------------------------
                                        (0085)    ;   NOTE: interrupt service routines must preserve
                                        (0086)    ;   the values of the A and X CPU registers.
                                        (0087) STD_EP2:    EQU     1   ; Set this equate to 0 to remove the standard
                                        (0088)                         ; endpoint handling code
                                        (0089)    ;---------------------------------------------------
                                        (0090)    ; Insert your custom code above this banner
                                        (0091)    ;---------------------------------------------------
                                        (0092)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0093) 
                                        (0094) IF  STD_EP2
09D2: 08       PUSH  A                  (0095)     PUSH A
09D3: 36 24 04 XOR   [USB_EPDataToggle],0x4(0096)     XOR     [USB_EPDataToggle], 4 ; Update EP2 data toggle
09D6: 5D 46    MOV   A,REG[0x46]        (0097)     MOV     A, REG[EP2MODE]            ; Get the mode
09D8: 55 2B 01 MOV   [USB_EndpointAPIStatus+2],0x1(0098)     MOV     [USB_EndpointAPIStatus + 2], EVENT_PENDING ; For the API
09DB: 18       POP   A                  (0099)     POP A
09DC: 7E       RETI                     (0100)     RETI
                                        (0101) ENDIF
                                        (0102) ;-----------------------------------------------------------------------------
                                        (0103) ;  FUNCTION NAME: USB_RESET_ISR
                                        (0104) ;
                                        (0105) ;  DESCRIPTION:    Handle the USB Bus Reset Interrupt
                                        (0106) ;-----------------------------------------------------------------------------
                                        (0107) export  USB_RESET_ISR
                                        (0108) export _USB_RESET_ISR
                                        (0109)  USB_RESET_ISR:
                                        (0110) _USB_RESET_ISR:
                                        (0111) 
                                        (0112)    ;@PSoC_UserCode_BODY_USB_RESET@ (Do not change this line.)
                                        (0113)    ;---------------------------------------------------
                                        (0114)    ; Insert your custom code below this banner
                                        (0115)    ;---------------------------------------------------
                                        (0116)    ;   NOTE: interrupt service routines must preserve
                                        (0117)    ;   the values of the A and X CPU registers.
                                        (0118) 
                                        (0119) STD_USB_RESET:    EQU     1 ; Set this equate to 0 to remove the standard
                                        (0120)                             ; USB reset handling code below
                                        (0121) 
                                        (0122)    ;---------------------------------------------------
                                        (0123)    ; Insert your custom code above this banner
                                        (0124)    ;---------------------------------------------------
                                        (0125)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                        (0126) 
                                        (0127) IF  STD_USB_RESET
09DD: 08       PUSH  A                  (0128)     PUSH A
09DE: 10       PUSH  X                  (0129)     PUSH X
09DF: 51 0A    MOV   A,[USB_bCurrentDevice](0130)     MOV     A, [USB_bCurrentDevice]     ; Select the current device
09E1: 7C 07 C2 LCALL _USB_Start         (0131)     LCALL   _USB_Start     ; Restart USB
09E4: 20       POP   X                  (0132)     POP X
09E5: 18       POP   A                  (0133)     POP A
                                        (0134) ENDIF
                                        (0135) 
09E6: 7E       RETI                     (0136)     RETI
                                        (0137) ;-----------------------------------------------------------------------------
                                        (0138) ;  FUNCTION NAME: USB_ACT_ISR
                                        (0139) ;
                                        (0140) ;  DESCRIPTION:    Handle the activity ISR
                                        (0141) ;
                                        (0142) ;  THEORY of OPERATION or PROCEDURE:
                                        (0143) ;
                                        (0144) ;   The activity interrupt sets a RAM flag indicating activity and disables the
                                        (0145) ;   interrupt.  Disabling the interrupt keeps the bus activity from creating too
                                        (0146) ;   many interrupts.  bCheckActivity checks and clears the flag, the enables
                                        (0147) ;   interrupts for the next interval.
                                        (0148) ;
                                        (0149) ;-----------------------------------------------------------------------------
                                        (0150) export  USB_ACT_ISR
                                        (0151) export _USB_ACT_ISR
                                        (0152)  USB_ACT_ISR:
                                        (0153) _USB_ACT_ISR:
09E7: 55 30 01 MOV   [USB_bActivity],0x1(0154)     MOV    [USB_bActivity], 1          ; Set the activity flag
09EA: 41 E1 EF AND   REG[0xE1],0xEF     
                                        (0155)     M8C_DisableIntMask INT_MSK1, INT_MSK1_USB_ACTIVITY
09ED: 7E       RETI                     (0156)     RETI
