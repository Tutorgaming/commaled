 0000           ;;*****************************************************************************
 0000           ;;*****************************************************************************
 0000           ;;  FILENAME: USB_drv.asm
 0000           ;;   Version: 1.90, Updated on 2015/3/4 at 22:20:18
 0000           ;;  Generated by PSoC Designer 5.4.3191
 0000           ;;
 0000           ;;  DESCRIPTION: USB Device User Module control endpoint driver
 0000           ;;
 0000           ;;  NOTE: User Module APIs conform to the fastcall convention for marshalling
 0000           ;;        arguments and observe the associated "Registers are volatile" policy.
 0000           ;;        This means it is the caller's responsibility to preserve any values
 0000           ;;        in the X and A registers that are still needed after the API
 0000           ;;        function returns. Even though these registers may be preserved now,
 0000           ;;        there is no guarantee they will be preserved in future releases.
 0000           ;;-----------------------------------------------------------------------------
 0000           ;;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
 0000           ;;*****************************************************************************
 0000           ;;*****************************************************************************
 0000           
 0010           FLAG_XIO_MASK:  equ 10h
 0008           FLAG_SUPER:     equ 08h
 0004           FLAG_CARRY:     equ 04h
 0002           FLAG_ZERO:      equ 02h
 0001           FLAG_GLOBAL_IE: equ 01h
 0000           
 0000           ;;=============================================================================
 0000           ;;      Register Space, Bank 0
 0000           ;;=============================================================================
 0000           
 0000           ;------------------------------------------------
 0000           ;  Port Registers
 0000           ;------------------------------------------------
 0000           ; Port Data Registers
 0000           P0DATA:       equ 00h          ; Port 0 Data Register                     (RW)
 0001           P1DATA:       equ 01h          ; Port 1 Data Register                     (RW)
 0002           P2DATA:       equ 02h          ; Port 2 Data Register                     (RW)
 0003           P3DATA:       equ 03h          ; Port 3 Data Register                     (RW)
 0004           P4DATA:       equ 04h          ; Port 4 Data Register                     (RW)
 0000           ; PSoC Compatability
 0000           PRT0DR:       equ 00h          ; Port 0 Data Register                     (RW)(PSoC)
 0001           PRT1DR:       equ 01h          ; Port 1 Data Register                     (RW)(PSoC)
 0002           PRT2DR:       equ 02h          ; Port 2 Data Register                     (RW)(PSoC)
 0003           PRT3DR:       equ 03h          ; Port 3 Data Register                     (RW)(PSoC)
 0004           PRT4DR:       equ 04h          ; Port 4 Data Register                     (RW)(PSoC)
 0000           
 0000           ; Port/Pin Configuration Registers
 0005           P00CR:        equ 05h          ; P0.0 Configuration Register              (RW)
 0006           P01CR:        equ 06h          ; P0.1 Configuration Register              (RW)
 0007           P02CR:        equ 07h          ; P0.2 Configuration Register              (RW)
 0008           P03CR:        equ 08h          ; P0.3 Configuration Register              (RW)
 0009           P04CR:        equ 09h          ; P0.4 Configuration Register              (RW)
 000A           P05CR:        equ 0Ah          ; P0.5 Configuration Register              (RW)
 000B           P06CR:        equ 0Bh          ; P0.6 Configuration Register              (RW)
 000C           P07CR:        equ 0Ch          ; P0.7 Configuration Register              (RW)
 000D           P10CR:        equ 0Dh          ; P1.0 Configuration Register              (RW)
 000E           P11CR:        equ 0Eh          ; P1.1 Configuration Register              (RW)
 000F           P12CR:        equ 0Fh          ; P1.2 Configuration Register              (RW)
 0010           P13CR:        equ 10h          ; P1.3 Configuration Register              (RW)
 0011           P14CR:        equ 11h          ; P1.4 Configuration Register              (RW)
 0012           P15CR:        equ 12h          ; P1.5 Configuration Register              (RW)
 0013           P16CR:        equ 13h          ; P1.6 Configuration Register              (RW)
 0014           P17CR:        equ 14h          ; P1.7 Configuration Register              (RW)
 0015           P2CR:         equ 15h          ; P2.0-P2.7 Configuration Register         (RW)
 0016           P3CR:         equ 16h          ; P3.0-P3.7 Configuration Register         (RW)
 0017           P4CR:         equ 17h          ; P4.0-P4.7 Configuration Register         (RW)
 0000           
 0000           ; Timer Registers
 0020           FRTMRL:       equ 20h          ; Free Running Timer Low                   (RW)
 0021           FRTMRH:       equ 21h          ; Free Running Timer High                  (RW)
 0022           TCAP0R:       equ 22h          ; Capture 0 Rising                         (R)             
 0023           TCAP1R:       equ 23h          ; Capture 1 Rising                         (R)             
 0024           TCAP0F:       equ 24h          ; Capture 0 Falling                        (R)             
 0025           TCAP1F:       equ 25h          ; Capture 1 Falling                        (R)             
 0026           PITMRL:       equ 26h          ; Programmable Interval Timer Low          (RW)
 0027           PITMRH:       equ 27h          ; Programmable Interval Timer High         (RW)
 0028           PIRL:         equ 28h          ; Programmable Interval Timer Reload Low   (RW)
 0029           PIRH:         equ 29h          ; Programmable Interval Timer Reload High  (RW)
 002A           TMRCR:        equ 2Ah          ; Timer Configuration Register             (RW)
 002B           TCAPINTE:     equ 2Bh          ; Capture Timer Interrupt Enable           (RW)
 002C           TCAPINTS:     equ 2Ch          ; Capture Timer Interrupt Status           (RW)
 0000           
 0000           ; Clock Configuration Registers
 0030           CPUCLKCR:     equ 30h          ; CPU Clock Configuration Register         (RW)
 0000           CPUCLK_SEL_INT:         equ 00h ; CPU Clock Select Internal Oscillator
 0001           CPUCLK_SEL_EXT:         equ 01h ; CPU Clock Select External Clock
 0000           CPUCLK_USBCLK_SEL_INT:  equ 00h ; USB Clock Select Internal Clock
 0040           CPUCLK_USBCLK_SEL_EXT:  equ 40h ; USB Clock Select External Clock
 0000           CPUCLK_USBCLK_DIV2_DIS: equ 00h ; USB Clock Divide by 2 disable
 0080           CPUCLK_USBCLK_DIV2_ENA: equ 80h ; USB Clock Divide by 2 enable
 0000           
 0031           TMRCLKCR:     equ 31h          ; Timer Clock Configuration Register       (RW)
 0000           TMRCLKCR_ITMRCLK_IOSC:     equ 00h ; MASK: ITMRCLK Source--Internal Oscillator
 0001           TMRCLKCR_ITMRCLK_XOSC:     equ 01h ; MASK: ITMRCLK Source--External Oscillator or CLKIN
 0002           TMRCLKCR_ITMRCLK_LPO:      equ 02h ; MASK: ITMRCLK Source--Low Power Oscillator (32 Khz)
 0003           TMRCLKCR_ITMRCLK_TCAPCLK:  equ 03h ; MASK: ITMRCLK Source--TCAPCLK
 0000           TMRCLKCR_ITMRCLK_DIV_1:    equ 00h ; MASK: ITMRCLK Divider Value 1
 0004           TMRCLKCR_ITMRCLK_DIV_2:    equ 04h ; MASK: ITMRCLK Divider Value 2
 0008           TMRCLKCR_ITMRCLK_DIV_3:    equ 08h ; MASK: ITMRCLK Divider Value 3
 000C           TMRCLKCR_ITMRCLK_DIV_4:    equ 0Ch ; MASK: ITMRCLK Divider Value 4
 0002           TMRCLKCR_ITMRCLK_LPO:      equ 02h ; MASK: ITMRCLK Source--Low Power Oscillator (32 Khz)
 0000           TMRCLKCR_TCAPCLK_IOSC:     equ 00h ; MASK: TCAPCLK Source--Internal Oscillator
 0010           TMRCLKCR_TCAPCLK_XOSC:     equ 10h ; MASK: TCAPCLK Source--External Oscillator or CLKIN
 0020           TMRCLKCR_TCAPCLK_LPO:      equ 20h ; MASK: TCAPCLK Source--Low Power Oscillator (32 Khz)
 0030           TMRCLKCR_TCAPCLK_DISABLED: equ 30h ; MASK: TCAPCLK Source--DISABLED
 0000           TMRCLKCR_TCAPCLK_DIV_2:    equ 00h ; MASK: TCAPCLK Divider Value 2
 0040           TMRCLKCR_TCAPCLK_DIV_4:    equ 40h ; MASK: TCAPCLK Divider Value 4
 0080           TMRCLKCR_TCAPCLK_DIV_6:    equ 80h ; MASK: TCAPCLK Divider Value 6
 00C0           TMRCLKCR_TCAPCLK_DIV_8:    equ 0C0h ; MASK: TCAPCLK Divider Value 8
 0000           
 0032           CLKIOCR:      equ 32h          ; Clock I/O Configuration Register         (RW)
 0000           CLKIOCR_CLKOUT_IOSC:       equ 00h ; MASK: Clock Source--Internal Oscillator
 0001           CLKIOCR_CLKOUT_XOSC:       equ 01h ; MASK: Clock Source--External Oscillator or CLKIN
 0002           CLKIOCR_CLKOUT_LPO:        equ 02h ; MASK: Clock Source--Low Power Oscillator (32 Khz)
 0003           CLKIOCR_CLKOUT_CPUCLK:     equ 03h ; MASK: Clock Source--CPUCLK
 0000           
 0000           ; Oscillator Configuration Registers
 0034           IOSCTR:       equ 34h          ; Internal Oscillator Trim Register        (R)
 0035           XOSCTR:       equ 35h          ; Crystal Oscillator Trim Register         (R)
 0036           LPOSCTR:      equ 36h          ; Low Power Oscillator Trim Register       (RW)
 0000           
 0000           ; SPI Configuration/Data Registers
 003C           SPIDATA:      equ 3Ch          ; SPI Data Register                        (RW)
 003D           SPICR:        equ 3Dh          ; SPI Configuration Register               (RW)
 0000           
 0000           ; USB SIE Configuration/Data Registers
 0040           USBCR:        equ 40h          ; USB Configuration Register               (RW)
 0041           EP0CNT:       equ 41h          ; Endpoint 0 Count Register                (RW)
 0042           EP1CNT:       equ 42h          ; Endpoint 1 Count Register                (RW)
 0043           EP2CNT:       equ 43h          ; Endpoint 2 Count Register                (RW)
 0044           EP0MODE:      equ 44h          ; Endpoint 0 Mode  Register                (RW)
 0045           EP1MODE:      equ 45h          ; Endpoint 1 Mode  Register                (RW)
 0046           EP2MODE:      equ 46h          ; Endpoint 2 Mode  Register                (RW)
 0050           EP0DATA:      equ 50h          ; Endpoint 0 Data  Register (50h-57h)      (RW)
 0058           EP1DATA:      equ 58h          ; Endpoint 1 Data  Register (58h-5Fh)      (RW)
 0060           EP2DATA:      equ 60h          ; Endpoint 2 Data  Register (60h-67h)      (RW)
 0000           
 0000           ; Band-gap/TRIMBUF Configuration Registers
 0070           BGAPTR:       equ 70h          ; Band-gap Trim Register                   (R)
 0071           TRIM0:        equ 71h          ; TRIMBUF Trim Register 0                  (R)
 0072           TRIM1:        equ 72h          ; TRIMBUF Trim Register 1                  (R)
 0000           
 0000           ; VREG Configuration Register
 0073           VREGCR:       equ 73h          ; VREG Configuration Register              (RW)
 0000           
 0000           ; USB Transceiver Configuration Registers
 0074           USBXCR:       equ 74h          ; USB Transceiver Configuration Register   (RW)
 0080           USBXCR_ENABLE:    equ 80h      ; USB Transceiver Enable
 0001           USBXCR_FORCE:     equ 01h      ; USB Transceiver Force
 0000           
 0000           ; Data Pointer Registers--Listed for compatability with other M8C based parts.
 00D0           CPPDR:        equ 0D0h          ; Current Page Pointer Data Register       (RW)
 00D4           DPRDR:        equ 0D4h          ; Data Page Read Register                  (RW)
 00D5           DPWDR:        equ 0D5h          ; Data Page Write Register                 (RW)
 0000           
 0000           ; Watchdog Timer Reset
 00E3           RESWDT:       equ 0E3h          ; Watchdog Timer Reset                     (W)
 00E3           RES_WDT:      equ 0E3h          ; WatchDog Timer Register                  (W) (PSoC)
 0000           
 0000           ;------------------------------------------------
 0000           ;  System and Global Resource Registers
 0000           ;------------------------------------------------
 00DA           INT_CLR0:     equ 0DAh          ; Interrupt Clear Register 0               (RW)
 0000                                          ; Use INT_MSK0 bit field masks
 00DB           INT_CLR1:     equ 0DBh          ; Interrupt Clear Register 1               (RW)
 0000                                          ; Use INT_MSK1 bit field masks
 00DC           INT_CLR2:     equ 0DCh          ; Interrupt Clear Register 2               (RW)
 0000                                          ; Use INT_MSK2 bit field masks
 0000           
 00DE           INT_MSK3:     equ 0DEh          ; Interrupt Mask Register                  (RW)
 0080           INT_MSK3_ENSWINT:          equ 80h ; MASK: enable/disable SW interrupt
 0000           
 00DF           INT_MSK2:     equ 0DFh          ; Interrupt Mask Register                  (RW)
 0040           INT_MSK2_GPIO_PORT4:       equ 40h ; MASK: enable/disable GPIO Port 4 interrupt
 0020           INT_MSK2_GPIO_PORT3:       equ 20h ; MASK: enable/disable GPIO Port 3 interrupt
 0010           INT_MSK2_GPIO_PORT2:       equ 10h ; MASK: enable/disable GPIO Port 2 interrupt
 0008           INT_MSK2_PS2_DATA_LOW:     equ 08h ; MASK: enable/disable PS/2 Data Low
 0004           INT_MSK2_GPIO_INT2:        equ 04h ; MASK: enable/disable GPIO INT2 interrupt
 0002           INT_MSK2_CTR_16_WRAP:      equ 02h ; MASK: enable/disable 16 bit counter wrap
 0001           INT_MSK2_TCAP1:            equ 01h ; MASK: enable/disable Timer/Capture 0 interrupt
 0000           
 00E0           INT_MSK0:     equ 0E0h          ; Interrupt Mask Register                 (RW)
 0080           INT_MSK0_GPIO_PORT1:       equ 80h ; MASK: enable/disable GPIO Port 1 interrupt
 0040           INT_MSK0_SLEEP:            equ 40h ; MASK: enable/disable sleep interrupt
 0020           INT_MSK0_GPIO_INT1:        equ 20h ; MASK: enable/disable GPIO INT1 interrupt
 0010           INT_MSK0_GPIO_PORT0:       equ 10h ; MASK: enable/disable GPIO Port 0 interrupt
 0008           INT_MSK0_SPI_RX:           equ 08h ; MASK: enable/disable SPI Receive interrupt
 0004           INT_MSK0_SPI_TX:           equ 04h ; MASK: enable/disable SPI Transmit interrupt
 0002           INT_MSK0_GPIO_INT0:        equ 02h ; MASK: enable/disable GPIO INT0 interrupt
 0001           INT_MSK0_POR_LVD:          equ 01h ; MASK: enable/disable POR/LVD interrupt
 0000           
 00E1           INT_MSK1:     equ 0E1h          ; Interrupt Mask Register                 (RW)
 0080           INT_MSK1_TCAP0:            equ 80h ; MASK: enable/disable Timer/Capture 0 interrupt
 0040           INT_MSK1_PIT:              equ 40h ; MASK: enable/disable Progrmmable Interval Timer
 0020           INT_MSK1_MS_TIMER:         equ 20h ; MASK: enable/disable One Millisecond Timer interrupt
 0010           INT_MSK1_USB_ACTIVITY:     equ 10h ; MASK: enable/disable USB Bus Activity interrupt
 0008           INT_MSK1_USB_BUS_RESET:    equ 08h ; MASK: enable/disable USB Bus Reset interrupt
 0004           INT_MSK1_USB_EP2:          equ 04h ; MASK: enable/disable USB Endpoint 2 interrupt
 0002           INT_MSK1_USB_EP1:          equ 02h ; MASK: enable/disable USB Endpoint 1 interrupt
 0001           INT_MSK1_USB_EP0:          equ 01h ; MASK: enable/disable USB Endpoint 0 interrupt
 0000           
 00E2           INT_VC:       equ 0E2h          ; Interrupt vector register                (RC)
 0000           
 0000           ;------------------------------------------------------
 0000           ;        Register bank 1.
 0000           ;------------------------------------------------------
 00E0           OSC_CR0:                   equ 0E0h  ; System Oscillator Control Register 0     (RW)
 0020           OSC_CR0_NO_BUZZ:           equ 20h    ; MASK: Bandgap always powered/BUZZ bandgap
 0018           OSC_CR0_SLEEP:             equ 18h    ; MASK: Set Sleep timer freq/period
 0000           OSC_CR0_SLEEP_512Hz:       equ 00h    ;     Set sleep bits for 1.95ms period
 0008           OSC_CR0_SLEEP_64Hz:        equ 08h    ;     Set sleep bits for 15.6ms period
 0010           OSC_CR0_SLEEP_8Hz:         equ 10h    ;     Set sleep bits for 125ms period
 0018           OSC_CR0_SLEEP_1Hz:         equ 18h    ;     Set sleep bits for 1 sec period
 0000           
 0007           OSC_CR0_CPU:               equ 07h    ; MASK: Set CPU Frequency
 0000           OSC_CR0_CPU_3MHz:          equ 00h    ;     set CPU Freq bits for 3MHz Operation
 0001           OSC_CR0_CPU_6MHz:          equ 01h    ;     set CPU Freq bits for 6MHz Operation
 0002           OSC_CR0_CPU_12MHz:         equ 02h    ;     set CPU Freq bits for 12MHz Operation
 0003           OSC_CR0_CPU_24MHz:         equ 03h    ;     set CPU Freq bits for 24MHz Operation
 0004           OSC_CR0_CPU_1d5MHz:        equ 04h    ;     set CPU Freq bits for 1.5MHz Operation
 0005           OSC_CR0_CPU_750kHz:        equ 05h    ;     set CPU Freq bits for 750kHz Operation
 0006           OSC_CR0_CPU_187d5kHz:      equ 06h    ;     set CPU Freq bits for 187.5kHz Operation
 0000           
 0000           ;------------------------------------------------------
 0000           ;  Note: The following registers are mapped into both
 0000           ;        register bank 0 AND register bank 1.
 0000           ;------------------------------------------------------
 00F7           CPU_F:        equ 0F7h          ; CPU Flag Register Access                 (RO)
 0000                                              ; Use FLAG_ masks defined at top of file
 00FF           CPU_SCR:     equ 0FFh          ; CPU Status and Control Register          (#)
 0080           CPU_SCR_GIE_MASK:      equ 80h    ; MASK: Global Interrupt Enable shadow
 0020           CPU_SCR_WDRS_MASK:     equ 20h    ; MASK: Watch Dog Timer Reset
 0010           CPU_SCR_PORS_MASK:     equ 10h    ; MASK: power-on reset bit PORS
 0008           CPU_SCR_SLEEP_MASK:    equ 08h    ; MASK: Enable Sleep
 0001           CPU_SCR_STOP_MASK:     equ 01h    ; MASK: Halt CPU bit
 0000           
 0000           ;;=============================================================================
 0000           ;;      Register Space, Bank 1
 0000           ;;=============================================================================
 0000           
 0000           ;------------------------------------------------
 0000           ;  Clock and System Control Registers
 0000           ;------------------------------------------------
 0000           
 0000           ;;=============================================================================
 0000           ;;      M8C System Macros
 0000           ;;  These macros should be used when their functions are needed.
 0000           ;;=============================================================================
 0000           
 0000           ;----------------------------------------------------
 0000           ;  Swapping Register Banks
 0000           ;----------------------------------------------------
 0000               macro M8C_SetBank0
 0000               and   F, ~FLAG_XIO_MASK
 0000               macro M8C_SetBank1
 0000               or    F, FLAG_XIO_MASK
 0000               macro M8C_EnableGInt
 0000               or    F, FLAG_GLOBAL_IE
 0000               macro M8C_DisableGInt
 0000               and   F, ~FLAG_GLOBAL_IE
 0000               macro M8C_DisableIntMask
 0000               and   reg[@0], ~@1              ; disable specified interrupt enable bit
 0000               macro M8C_EnableIntMask
 0000               or    reg[@0], @1               ; enable specified interrupt enable bit
 0000               macro M8C_ClearIntFlag
 0000               mov   reg[@0], ~@1              ; clear specified interrupt enable bit
 0000               macro M8C_EnableWatchDog
 0000               and   reg[CPU_SCR], ~CPU_SCR_PORS_MASK
 0000               macro M8C_ClearWDT
 0000               mov   reg[RES_WDT], 00h
 0000               macro M8C_ClearWDTAndSleep
 0000               mov   reg[RES_WDT], 38h
 0000               macro M8C_Sleep
 0000               or    reg[CPU_SCR], CPU_SCR_SLEEP_MASK
 0000               ; The next instruction to be executed depends on the state of the
 0000               ; various interrupt enable bits. If some interrupts are enabled
 0000               ; and the global interrupts are disabled, the next instruction will
 0000               ; be the one that follows the invocation of this macro. If global
 0000               ; interrupts are also enabled then the next instruction will be
 0000               ; from the interrupt vector table. If no interrupts are enabled
 0000               ; then the CPU sleeps forever.
 0000               macro M8C_Stop
 0000               ; In general, you probably don't want to do this, but here's how:
 0000               or    reg[CPU_SCR], CPU_SCR_STOP_MASK
 0000               ; Next instruction to be executed is located in the interrupt
 0000               ; vector table entry for Power-On Reset.
 0000               macro M8C_Reset
 0000               ; Restore CPU to the power-on reset state.
 0000               mov A, 0
 0000               SSC
 0000               ; Next non-supervisor instruction will be at interrupt vector 0.
 0000               macro Suspend_CodeCompressor
 0000               or   F, 0
 0000               macro Resume_CodeCompressor
 0000               add  SP, 0
 0000           MACRO   GET_WORD
 0000               PUSH A                              ; Quickly get a RAM temp
 0000               PUSH A                              ; Save the source MSB
 0000               ROMX                                ; Get the first byte
 0000               PUSH X                              ; Save X
 0000               MOV  X,SP                           ; Get SP, to index to the temp 
 0000               MOV  [X - 3],A                      ; Save the first byte
 0000               POP  X                              ; Get back the source LSB
 0000               POP  A                              ; And the MSB
 0000               INC  X                              ; Point to the second byte
 0000               ADC  A, 0                           ; 
 0000               ROMX                                ; Get the second byte
 0000               MOV  X,A                            ; Save it in X
 0000               POP  A                              ; And the first byte in A
 0000           MACRO   NULL_PTR_CHECK
 0000               SWAP    A, X                        ; LSB non-zero?
 0000               JNZ     .ok                         ; Exit on non-zero
 0000               SWAP    A, X                        ; MSB zero
 0000               JZ      @0                          ; Jump to the null pointer handler
 0000               JMP     .exit
 0000           .ok:
 0000               SWAP    A, X                        ; Put them back
 0000           .exit:
 0000           NULL_PTR:   EQU 0                       ; Null pointer value
 0000           
 0000           ;--------------------------------------------------
 0000           ; TRANSFER DESCRIPTOR MACROS
 0000           ;--------------------------------------------------
 0000           
 0000           ;-----------------------------------------------
 0000           ; TD_START_TABLE MACRO
 0000           ;-----------------------------------------------
 0000           ; Parameters:
 0000           ;   @0 = Number of table entries
 0000           ; Register setup
 0000           ;   N/A (builds ROM data at assembly time)
 0000           ;-----------------------------------------------
 0000           MACRO   TD_START_TABLE
 0000               DB      ((@0) - 1)                 ; Number of table entries - 1
 0000           MACRO   TD_ENTRY
 0000               DB  @0                             ; Data source (USB_DS_*)
 0000               DW  @1                             ; Transfer size
 0000               DW  @2                             ; Data source address
 0000               DW  @3                             ; Transfer Completion Status Block Address
 0000               DB  0xde                           ; Reserved 
 0008           TD_ENTRY_SIZE:                         EQU 8
 0001           TD_START_SIZE:                         EQU 1
 0000           ;-----------------------------------------------
 0000           ; TD_INDEX_TO_OFFSET MACRO
 0000           ;-----------------------------------------------
 0000           ; Parameters:
 0000           ;   @0 = RAM address of Index
 0000           ; Register setup
 0000           ;   A = DC (restored)
 0000           ;   X = DC (not used)
 0000           ;--------------------------------------------------
 0000           MACRO   TD_INDEX_TO_OFFSET
 0000               PUSH    A                          ; Save a work register
 0000               ASL     [@0]                       ; Index * 2
 0000               ASL     [@0]                       ; Index * 4
 0000               ASL     [@0]                       ; Index * 4
 0000               POP     A                          ; Restore the work register
 0000           MACRO LT_START
 0000               DB      (@0)                       ; Table size
 0000           MACRO LT_ENTRY
 0000               DW      (@0)                       ; Table entry
 0000               DW      (@1)                       ; Table entry
 0002           LT_ENTRY_SIZE:                         EQU 2
 0001           LT_START_SIZE:                         EQU 1
 0000           
 0000           ;-----------------------------------------------
 0000           ; LT_INDEX_TO_OFFSET MACRO
 0000           ;-----------------------------------------------
 0000           ; Parameters:
 0000           ;   @0 = RAM address of Index
 0000           ; Register setup
 0000           ;   A = DC (not used)
 0000           ;   X = DC (not used)
 0000           ;--------------------------------------------------
 0000           MACRO   LT_INDEX_TO_OFFSET
 0000               ASL     [@0]                       ; Simply shift (mult by 2)
 0000               ASL     [@0]                       ;              (mult by 4)
 0000           MACRO DISPATCHER
 0000               CMP   A,@1
 0000               JNC   .dispatch_not_supported
 0000               ASL   A
 0000               JACC  @0
 0000           .dispatch_not_supported:
 0000               JMP  @2    
 0002           USB_bNumStringDescrs: EQU    2
 0000           
 0003           USB_NUM_ENDPOINTS:                          EQU 3 
 0002           USB_MAX_EP_NUMBER:                          EQU (USB_NUM_ENDPOINTS - 1) 
 0000           
 0000           ;--------------------------------------------------
 0000           ; Registers for USB API's.
 0000           ;--------------------------------------------------
 0074           USB_USBXCR:    EQU    USBXCR
 0040           USB_ADDR:      EQU    USBCR
 0041           USB_EP0CNT:    EQU    EP0CNT
 0042           USB_EP1CNT:    EQU    (EP0CNT + 1)
 0043           USB_EP2CNT:    EQU    (EP0CNT + 2)
 0044           USB_EP0MODE:   EQU    EP0MODE
 0045           USB_EP1MODE:   EQU    (EP0MODE + 1)
 0046           USB_EP2MODE:   EQU    (EP0MODE + 2)
 0050           USB_EP0DATA:   EQU    EP0DATA
 0058           USB_EP1DATA:   EQU    (EP0DATA + 8)
 0060           USB_EP2DATA:   EQU    (EP0DATA + 16)
 0000           
 0000           ;--------------------------------------------------
 0000           ; Endpoint 0 offsets (Table 9-2)
 0000           ;--------------------------------------------------
 0000           bmRequestType:                              EQU     0
 0001           bRequest:                                   EQU     1
 0002           wValue:                                     EQU     2
 0003           wValueHi:                                   EQU     3
 0002           wValueLo:                                   EQU     2
 0004           wIndex:                                     EQU     4
 0005           wIndexHi:                                   EQU     5
 0004           wIndexLo:                                   EQU     4
 0006           wLength:                                    EQU     6
 0007           wLengthHi:                                  EQU     7
 0006           wLengthLo:                                  EQU     6
 0000           
 0000           ;--------------------------------------------------
 0000           ; Request Types (Table 9-4)
 0000           ;--------------------------------------------------
 0000           USB_GET_STATUS:                             EQU    0x00
 0001           USB_CLEAR_FEATURE:                          EQU    0x01
 0003           USB_SET_FEATURE:                            EQU    0x03
 0005           USB_SET_ADDRESS:                            EQU    0x05
 0006           USB_GET_DESCRIPTOR:                         EQU    0x06
 0007           USB_SET_DESCRIPTOR:                         EQU    0x07
 0008           USB_GET_CONFIGURATION:                      EQU    0x08
 0009           USB_SET_CONFIGURATION:                      EQU    0x09
 000A           USB_GET_INTERFACE:                          EQU    0x0A
 000B           USB_SET_INTERFACE:                          EQU    0x0B
 000C           USB_SYNCH_FRAME:                            EQU    0x0C
 0000           
 0000           ;--------------------------------------------------
 0000           ; Descriptor Types (Table 9-5)
 0000           ;--------------------------------------------------
 0001           DESCR_TYPE_DEVICE:                          EQU     1
 0002           DESCR_TYPE_CONFIG:                          EQU     2
 0003           DESCR_TYPE_STRING:                          EQU     3
 0004           DESCR_TYPE_INTERFACE:                       EQU     4
 0005           DESCR_TYPE_ENDPOINT:                        EQU     5
 0006           DESCR_TYPE_DEVICE_QUALIFIER:                EQU     6
 0007           DESCR_TYPE_OTHER_SPEED:                     EQU     7
 0008           DESCR_TYPE_INTERFACE_POWER:                 EQU     8
 0000           
 0000           ;--------------------------------------------------
 0000           ; Feature Selectors (Table 9-6)
 0000           ;--------------------------------------------------
 0001           USB_DEVICE_REMOTE_WAKEUP:                   EQU    0x01
 0000           USB_ENDPOINT_HALT:                          EQU    0x00
 0002           USB_TEST_MODE:                              EQU    0x02
 0000           
 0000           ;--------------------------------------------------
 0000           ; USB Device Status (Figure 9-4)
 0000           ;--------------------------------------------------
 0000           USB_DEVICE_STATUS_BUS_POWERED:              EQU   0x00
 0001           USB_DEVICE_STATUS_SELF_POWERED:             EQU   0x01
 0002           USB_DEVICE_STATUS_REMOTE_WAKEUP:            EQU   0x02
 0000           
 0000           ;--------------------------------------------------
 0000           ; USB Endpoint Status (Figure 9-4)
 0000           ;--------------------------------------------------
 0001           USB_ENDPOINT_STATUS_HALT:                   EQU    0x01
 0000           
 0000           ;--------------------------------------------------
 0000           ; USB Endpoint Directions
 0000           ;--------------------------------------------------
 0080           USB_DIR_IN:                                 EQU    0x80
 0000           USB_DIR_OUT:                                EQU    0x00
 007F           USB_DIR_UNUSED:                             EQU    0x7F
 0000           
 0000           ;--------------------------------------------------
 0000           ; USB Endpoint Address Symbols 
 0000           ;--------------------------------------------------
 0000           EP0:                                        EQU    0x00
 0001           EP1:                                        EQU    0x01
 0002           EP2:                                        EQU    0x02
 0000           
 0000           ;--------------------------------------------------
 0000           ; Control Endpoint States--These act as JACC jump values
 0000           ;--------------------------------------------------
 0000           USB_TRANS_STATE_IDLE:                       EQU     0x00         ;
 0002           USB_TRANS_STATE_CONTROL_READ:               EQU     0x02         ;
 0004           USB_TRANS_STATE_CONTROL_WRITE:              EQU     0x04         ;
 0006           USB_TRANS_STATE_NO_DATA_CONTROL:            EQU     0x06         ;
 0000           
 0000           ;--------------------------------------------------
 0000           ; Control Write flag values to indicate pending data changes
 0000           ;--------------------------------------------------
 0001           USB_ADDRESS_CHANGE_PENDING:     EQU     0x01
 0000           
 0000           ;--------------------------------------------------
 0000           ; Register Constants for USB
 0000           ;--------------------------------------------------
 0080           USB_ADDR_ENABLE:                             EQU 0x80
 0040           USB_CNT_VALID:                               EQU 0x40
 0080           USB_CNT_TOGGLE:                              EQU 0x80
 0080           USB_PULLUP_ENABLE:                           EQU 0x80
 0000           
 0000           
 0000           USB_MODE_DISABLE:                            EQU 0x00
 0001           USB_MODE_NAK_IN_OUT:                         EQU 0x01
 0002           USB_MODE_STATUS_OUT_ONLY:                    EQU 0x02
 0003           USB_MODE_STALL_IN_OUT:                       EQU 0x03
 0004           USB_MODE_RESERVED_0100:                      EQU 0x04
 0005           USB_MODE_ISO_OUT:                            EQU 0x05
 0006           USB_MODE_STATUS_IN_ONLY:                     EQU 0x06
 0007           USB_MODE_ISO_IN:                             EQU 0x07
 0008           USB_MODE_NAK_OUT:                            EQU 0x08
 0009           USB_MODE_ACK_OUT:                            EQU 0x09
 000A           USB_MODE_RESERVED_1010:                      EQU 0x0A
 000B           USB_MODE_ACK_OUT_STATUS_IN:                  EQU 0x0B
 000C           USB_MODE_NAK_IN:                             EQU 0x0C
 000D           USB_MODE_ACK_IN:                             EQU 0x0D
 000E           USB_MODE_RESERVED_1110:                      EQU 0x0E
 000F           USB_MODE_ACK_IN_STATUS_OUT:                  EQU 0x0F
 0080           USB_MODE_STALL_DATA_EP:                      EQU 0x80
 0000           
 0000           ;--------------------------------------------------
 0000           ; FORCE J/K/SE0 (Argument values)
 0000           ;--------------------------------------------------
 0002           USB_FORCE_J:                                 EQU 0x02
 0001           USB_FORCE_K:                                 EQU 0x01
 0000           USB_FORCE_SE0:                               EQU 0x00
 00FF           USB_FORCE_NONE:                              EQU 0xFF
 0001           USB_FORCE_STATE:                             EQU 0x01
 0000           
 0000           ;-----------------------------------------------
 0000           ; Endpoint event flags
 0000           ;-----------------------------------------------
 0002           NO_EVENT_ALLOWED:	equ               2
 0001           EVENT_PENDING:      equ               1
 0000           NO_EVENT_PENDING:   equ               0
 0000           
 0000           IN_BUFFER_FULL:     equ               NO_EVENT_PENDING
 0001           IN_BUFFER_EMPTY:    equ               EVENT_PENDING
 0001           OUT_BUFFER_FULL:    equ               EVENT_PENDING
 0000           OUT_BUFFER_EMPTY:   equ               NO_EVENT_PENDING
 0000           
 0000           ;--------------------------------------------------
 0000           ; USB Request Dispatch Functions, including overrides
 0000           ;--------------------------------------------------
 0001           USB_NOT_SUPPORTED:  EQU 0x01
 0002           USB_UM_SUPPLIED:    EQU 0x02
 0004           USB_APP_SUPPLIED:   EQU 0x04
 0000           
 0000           ;--------------------------------------------------
 0000           ; Device to host (d2h) Standard (std) Device (dev)
 0000           ;--------------------------------------------------
 0002           USB_CB_SRC_d2h_std_dev_00: equ USB_UM_SUPPLIED
 0001           USB_CB_SRC_d2h_std_dev_01: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_dev_02: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_dev_03: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_dev_04: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_dev_05: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_d2h_std_dev_06: equ USB_UM_SUPPLIED
 0001           USB_CB_SRC_d2h_std_dev_07: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_d2h_std_dev_08: equ USB_UM_SUPPLIED
 0000           
 0000           ;--------------------------------------------------
 0000           ; Host to device (h2d) Standard (std) Device (dev)
 0000           ;--------------------------------------------------
 0001           USB_CB_SRC_h2d_std_dev_00: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_h2d_std_dev_01: equ USB_UM_SUPPLIED
 0001           USB_CB_SRC_h2d_std_dev_02: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_h2d_std_dev_03: equ USB_UM_SUPPLIED
 0001           USB_CB_SRC_h2d_std_dev_04: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_h2d_std_dev_05: equ USB_UM_SUPPLIED
 0001           USB_CB_SRC_h2d_std_dev_06: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_h2d_std_dev_07: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_h2d_std_dev_08: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_h2d_std_dev_09: equ USB_UM_SUPPLIED
 0000           
 0000           ;--------------------------------------------------
 0000           ; Device to host (d2h) Standard (std) Interface (ifc)
 0000           ;--------------------------------------------------
 0002           USB_CB_SRC_d2h_std_ifc_00: equ USB_UM_SUPPLIED
 0001           USB_CB_SRC_d2h_std_ifc_01: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_ifc_02: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_ifc_03: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_ifc_04: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_ifc_05: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_ifc_06: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_ifc_07: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_ifc_08: equ USB_NOT_SUPPORTED
 0001           USB_CB_SRC_d2h_std_ifc_09: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_d2h_std_ifc_10: equ USB_UM_SUPPLIED
 0000           
 0000           ;--------------------------------------------------
 0000           ; Host to device (h2d) Standard (std) Interface (ifc)
 0000           ;--------------------------------------------------
 0001           USB_CB_SRC_h2d_std_ifc_00: equ USB_NOT_SUPPORTED
 0000           
 0000           ;--------------------------------------------------
 0000           ; Device to host (d2h) Standard (std) Endpoint (ep)
 0000           ;--------------------------------------------------
 0002           USB_CB_SRC_d2h_std_ep_00: equ USB_UM_SUPPLIED
 0000           
 0000           ;--------------------------------------------------
 0000           ; Host to device (h2d) Standard (std) Endpoint (ep)
 0000           ;--------------------------------------------------
 0001           USB_CB_SRC_h2d_std_ep_00: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_h2d_std_ep_01: equ USB_UM_SUPPLIED
 0001           USB_CB_SRC_h2d_std_ep_02: equ USB_NOT_SUPPORTED
 0002           USB_CB_SRC_h2d_std_ep_03: equ USB_UM_SUPPLIED
 0000           
 0000           ;-----------------------------------------------
 0000           ; 1st Tier Dispatch--Standard Requests
 0000           ;-----------------------------------------------
 0001           USB_CB_h2d_std_dev: equ 1
 0001           USB_CB_h2d_std_ifc: equ 1
 0001           USB_CB_h2d_std_ep:  equ 1
 0000           USB_CB_h2d_std_oth: equ 0
 0001           USB_CB_d2h_std_dev: equ 1
 0001           USB_CB_d2h_std_ifc: equ 1
 0001           USB_CB_d2h_std_ep:  equ 1
 0000           USB_CB_d2h_std_oth: equ 0
 0000           
 0000           ;-----------------------------------------------
 0000           ; 1st Tier Dispatch--Class Requests
 0000           ;-----------------------------------------------
 0000           USB_CB_h2d_cls_dev: equ 0
 0000           USB_CB_h2d_cls_ifc: equ 0
 0000           USB_CB_h2d_cls_ep:  equ 0
 0000           USB_CB_h2d_cls_oth: equ 0
 0000           USB_CB_d2h_cls_dev: equ 0
 0000           USB_CB_d2h_cls_ifc: equ 0
 0000           USB_CB_d2h_cls_ep:  equ 0
 0000           USB_CB_d2h_cls_oth: equ 0
 0000           
 0000           ;-----------------------------------------------
 0000           ; 1st Tier Dispatch--Vendor Specific Requests
 0000           ;-----------------------------------------------
 0000           USB_CB_h2d_vnd_dev: equ 0
 0000           USB_CB_h2d_vnd_ifc: equ 0
 0000           USB_CB_h2d_vnd_ep:  equ 0
 0000           USB_CB_h2d_vnd_oth: equ 0
 0000           USB_CB_d2h_vnd_dev: equ 0
 0000           USB_CB_d2h_vnd_ifc: equ 0
 0000           USB_CB_d2h_vnd_ep:  equ 0
 0000           USB_CB_d2h_vnd_oth: equ 0
 0000           
 0000           ;-----------------------------------------------
 0000           ; 1st Tier Dispatch--Reserved Requests
 0000           ;-----------------------------------------------
 0000           USB_CB_h2d_rsv_dev: equ 0
 0000           USB_CB_h2d_rsv_ifc: equ 0
 0000           USB_CB_h2d_rsv_ep:  equ 0
 0000           USB_CB_h2d_rsv_oth: equ 0
 0000           USB_CB_d2h_rsv_dev: equ 0
 0000           USB_CB_d2h_rsv_ifc: equ 0
 0000           USB_CB_d2h_rsv_ep:  equ 0
 0000           USB_CB_d2h_rsv_oth: equ 0
 0000           
 0000           ;--------------------------------------------------
 0000           ; Transfer Descriptor--Data Source
 0000           ;--------------------------------------------------
 0000           USB_DS_ROM:                                      EQU 0x00
 0001           USB_DS_RAM:                                      EQU 0x01
 0002           USB_DS_RAM_CB:                                   EQU 0x02
 0003           USB_DS_RAM_MASK:                                 EQU 0x03
 0000           
 0000           ;-----------------------------------------------
 0000           ; Transfer Completion Notification
 0000           ;-----------------------------------------------
 0000           USB_XFER_IDLE:         equ      0x00
 0001           USB_XFER_STATUS_ACK:   equ      0x01
 0002           USB_XFER_PREMATURE:    equ      0x02
 0003           USB_XFER_ERROR:        equ      0x03
 0000           
 0000           ; This macro is used to allocate a completion status block
 0000           ; for all Requests.  The macro parameter is used
 0000           ; to prefix the two data elements.
 0000           USB_XFER_STATUS:       equ      0
 0001           USB_XFER_LENGTH:       equ      1
 0000           MACRO    USB_XFER_STATUS_BLOCK
 0000               BLK    1    ; Completion Status
 0000               BLK    2    ; Transfer Length
 0000           USB_CLASS_NONE:                        EQU    0x00
 0001           USB_CLASS_HID:                         EQU    0x01
 0000           USB_CLASS:                             EQU    USB_CLASS_NONE
 0000           
 0000           ;-----------------------------------------------
 0000           ; Modify the supported requests by redefining
 0000           ; them within the custom code area below
 0000           ;-----------------------------------------------
 0000           
 0000              ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
 0000              ;---------------------------------------------------
 0000              ; Insert your custom assembly code below this banner
 0000              ;---------------------------------------------------
 0000              ;   NOTE: interrupt service routines must preserve
 0000              ;   the values of the A and X CPU registers.
 0000              
 0000              ;---------------------------------------------------
 0000              ; Insert your custom assembly code above this banner
 0000              ;---------------------------------------------------
 0000              
 0000              ;---------------------------------------------------
 0000              ; Insert a lcall to a C function below this banner
 0000              ; and un-comment the lines between these banners
 0000              ;---------------------------------------------------
 0000              
 0000              ;PRESERVE_CPU_CONTEXT
 0000              ;lcall _My_C_Function
 0000              ;RESTORE_CPU_CONTEXT
 0000              
 0000              ;---------------------------------------------------
 0000              ; Insert a lcall to a C function above this banner
 0000              ; and un-comment the lines between these banners
 0000              ;---------------------------------------------------
 0000              ;@PSoC_UserCode_END@ (Do not change this line.)
 0000           ;-----------------------------------------------
 0000           ; Has the user enabled any of the Vendor Specific Requests
 0000           ;-----------------------------------------------
 0000           USB_VSR_SUPPORT: EQU 0
                IF USB_CB_h2d_vnd_dev
                USB_VSR_SUPPORT: EQU 1
                ENDIF
                IF USB_CB_h2d_vnd_ifc
                USB_VSR_SUPPORT: EQU 1
                ENDIF
                IF USB_CB_h2d_vnd_ep
                USB_VSR_SUPPORT: EQU 1
                ENDIF
                IF USB_CB_h2d_vnd_oth
                USB_VSR_SUPPORT: EQU 1
                ENDIF
                IF USB_CB_d2h_vnd_dev
                USB_VSR_SUPPORT: EQU 1
                ENDIF
                IF USB_CB_d2h_vnd_ifc
                USB_VSR_SUPPORT: EQU 1
                ENDIF
                IF USB_CB_d2h_vnd_ep
                USB_VSR_SUPPORT: EQU 1
                ENDIF
                IF USB_CB_d2h_vnd_oth
                USB_VSR_SUPPORT: EQU 1
                ENDIF
                
                ; end of file USB.inc
                
                ;-----------------------------------------------
                ;  Global Symbols
                ;-----------------------------------------------
                export  _USB_EP0_ISR
                export  USB_InitControlRead
                export  USB_InitControlWrite
                export  USB_InitNoDataStageControlTransfer
                export  USB_NoDataStageControlTransfer
                
                ;-----------------------------------------------
                ;  Macro Definitions
                ;-----------------------------------------------
                
                ;-----------------------------------------------
                ;  Constant Definitions
                ;-----------------------------------------------
                
                ;-----------------------------------------------
                ; Variable Allocation
                ;-----------------------------------------------
                AREA bss (RAM,REL)
                ;----------------------------------------------------------------------------
                ; Current Device
                ;----------------------------------------------------------------------------
                EXPORT USB_bCurrentDevice
 0000           USB_bCurrentDevice:                     BLK   1    ;  Current Device
 0001           ;----------------------------------------------------------------------------
 0001           ; Current Configuration
 0001           ;----------------------------------------------------------------------------
                EXPORT USB_Configuration, _USB_Configuration
 0001           _USB_Configuration:
 0001            USB_Configuration:                     BLK   1    ;  Current Configuration
 0002           ;----------------------------------------------------------------------------
 0002           ; Current Device Status
 0002           ;----------------------------------------------------------------------------
                EXPORT USB_DeviceStatus
 0002            USB_DeviceStatus:                      BLK   1    ;  Current Device Status
 0003           ;----------------------------------------------------------------------------
 0003           ; Interface Setting
 0003           ;----------------------------------------------------------------------------
                EXPORT USB_InterfaceSetting
 0003            USB_InterfaceSetting:                  BLK   1h    ; Interface Setting
 0004           ;----------------------------------------------------------------------------
 0004           ; Endpoint Status--USB Status
 0004           ;----------------------------------------------------------------------------
                EXPORT USB_EndpointStatus
 0004            USB_EndpointStatus:                    BLK   USB_NUM_ENDPOINTS    ; Endpoint Status
 0007           ;----------------------------------------------------------------------------
 0007           ; Last Packet Size
 0007           ;----------------------------------------------------------------------------
                EXPORT USB_LastSize
 0007            USB_LastSize:                          BLK   1    ;  Last Packet Size
 0008           ;----------------------------------------------------------------------------
 0008           ; Control Transfer State Machine
 0008           ; State values for Control Write
 0008           ; State values for Control Read
 0008           ;----------------------------------------------------------------------------
                EXPORT USB_TransferType
 0008            USB_TransferType:                      BLK   1    ; Control Transfer State Machine
 0009           ;----------------------------------------------------------------------------
 0009           ; Control Transfer Intermediate Buffer--Shared among the requests
 0009           ;----------------------------------------------------------------------------
                EXPORT USB_TransferBuffer
 0009            USB_TransferBuffer:                    BLK   8
 0011           ;----------------------------------------------------------------------------
 0011           ; Transfer Descriptor Data for Control Transfer
 0011           ;  --The following data have the same format as the first 5 bytes of the TD_ENTRY
 0011           ;----------------------------------------------------------------------------
 0011           ; Control Transfer Data Source
 0011           ;   USB_DS_ROM
 0011           ;   USB_DS_RAM
 0011           ;   USB_DS_RAM_AS_NEEDED
 0011           ;----------------------------------------------------------------------------
                EXPORT USB_CurrentTD, _USB_CurrentTD
 0011            USB_CurrentTD:
 0011           _USB_CurrentTD:
                EXPORT USB_DataSource, _USB_DataSource
 0011            USB_DataSource:
 0011           _USB_DataSource:                       BLK   1
 0012           ;----------------------------------------------------------------------------
 0012           ; Control Transfer Data Size
 0012           ;----------------------------------------------------------------------------
                EXPORT USB_TransferSize, _USB_TransferSize
 0012            USB_TransferSize:
 0012            _USB_TransferSize:                    BLK   2
 0014           ;----------------------------------------------------------------------------
 0014           ; Control Transfer Data Pointer
 0014           ;   Source for Control Read
 0014           ;   Destination for Control Write
 0014           ;----------------------------------------------------------------------------
                EXPORT USB_DataPtr, _USB_DataPtr
 0014            USB_DataPtr:
 0014            _USB_DataPtr:                         BLK   2
 0016           ;----------------------------------------------------------------------------
 0016           ; Transfer Completion Notification
 0016           ;----------------------------------------------------------------------------
                EXPORT USB_StatusBlockPtr, _USB_StatusBlockPtr
 0016            USB_StatusBlockPtr:
 0016            _USB_StatusBlockPtr:                  BLK   2
 0018           ;----------------------------------------------------------------------------
 0018           ; Control Transfer _TransferByteCount (Actually transfered)
 0018           ;----------------------------------------------------------------------------
 0018            USB_TransferByteCount:                 BLK   2
 001A           ;----------------------------------------------------------------------------
 001A           ; Control Endpoint Data toggle
                EXPORT USB_EPDataToggle
 001A            USB_EPDataToggle:
 001A            USB_EP0DataToggle:                     BLK   1
 001B           ;----------------------------------------------------------------------------
 001B           ; Control Endpoint Data Pending Flag
                EXPORT USB_fDataPending
 001B            USB_fDataPending:                      BLK   1
 001C           ;----------------------------------------------------------------------------
 001C           ; Control Endpoint Data Pending Flag
 001C           ;EXPORT USB_PendingData
 001C           ; USB_PendingData:                      BLK   1
 001C           ;----------------------------------------------------------------------------
 001C           ; Temporary Data registers
                EXPORT USB_t2, USB_t1, USB_t0
 001C            USB_t2:                                BLK   1    ; Temporary shared by the UM
 001D            USB_t1:                                BLK   1    ; Temporary shared by the UM
 001E            USB_t0:                                BLK   1    ; Temporary shared by the UM
 001F           ;----------------------------------------------------------------------------
 001F           ; Endpoint Transfer--API Status
 001F           ;----------------------------------------------------------------------------
                EXPORT USB_EndpointAPIStatus, _USB_EndpointAPIStatus
 001F            USB_EndpointAPIStatus:
 001F           _USB_EndpointAPIStatus:                 BLK   USB_NUM_ENDPOINTS    ; Endpoint Status
 0022           
                AREA UserModules (ROM, REL)
                ;-----------------------------------------------------------------------------
                ;  FUNCTION NAME: USB_EP0_ISR
                
                ;
                ;  DESCRIPTION:   The EPO ISR serves the control endpoint interrupts and
                ;                 dispaches all SETUP, IN, and OUT transfers to the proper
                ;                 dispatch routines for all supported USB requests.
                ;
                ;-----------------------------------------------------------------------------
                ;
                ;  ARGUMENTS:   n/a
                ;
                ;  RETURNS:     n/a
                ;
                ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                ;
                ;  THEORY of OPERATION or PROCEDURE:
                ;
                ;-----------------------------------------------------------------------------
 0000            USB_EP0_ISR:
 0000           _USB_EP0_ISR:
 0000 08            PUSH    A                          ; Save the context
 0001 10            PUSH    X                          ;
 0002               ; Dispatch to setup/in/out handlers
                EXPORT  USB_mode_read
 0002           USB_mode_read:
 0002 5D44         MOV    A, REG[USB_EP0MODE]           ; Get the mode reg
 0004           
 0004 5C            MOV     X, A ; store for later
 0005               ; Check EP0_CR for the following cases:
 0005               ; bit 7 is set but ack is not set or mode is not 1 => invalid setup
 0005               ; bit 7 is not set, bit 5 or 6 is set, but bit 4 is not set => invalid in/out
 0005 219F          AND     A, 9Fh
 0007 3991          CMP     A, 91h
 0009 A03D          JZ      USB_EP0_Setup
 000B               ; Check if setup bit is set--if so then invalid EP0_CR reg read so exit
 000B 2180          AND     A, 80h
 000D               ; Getting here means there is an invalid setup; exit without modifying the mode
 000D B036          JNZ     USB_EP0_ISR_EXIT
 000F               ; Getting here means the setup bit is not set, now check in/out
 000F 5B            MOV     A, X   ; restore EP0_CR reg as read
 0010 2170          AND     A, 70h
 0012 3950          CMP     A, 50h
 0014 A05C          JZ      USB_EP0_IN
 0016 3930          CMP     A, 30h
 0018 A066          JZ      USB_EP0_OUT
 001A               ; Getting here means there is an invalid in/out; exit without modifying the mode
 001A 8029          JMP     USB_EP0_ISR_EXIT  
 001C           ; ISR Exit Point to update the mode register
 001C           ;   mode and count have been pushed onto the stack
                EXPORT USB_EP0_UPD_MODE_EXIT
 001C           USB_EP0_UPD_MODE_EXIT:
 001C           
 001C 531E          MOV     [USB_t0], A                    ; store EP0_CNT reg value for later
 001E 5D44          MOV     A, reg[USB_EP0MODE]            ; unlock registers  
 0020 2180          AND     A, 80h                                      ; Check if SETUP bit is set
 0022 B021          JNZ     USB_EP0_ISR_EXIT                ;          then EXIT from the ISR   
 0024 511E          MOV     A, [USB_t0]                    ; restore EP0_CNT reg value
 0026 6041          MOV     reg[USB_EP0CNT], A             ; Update the count register
 0028 5D41          MOV     A, reg[USB_EP0CNT]             ; writing check
 002A 3A1E          CMP     A, [USB_t0]                    ; if writing was not succesful,
 002C B017          JNZ     USB_EP0_ISR_EXIT               ;         then abort the ISR    
 002E           
 002E 5A1E          MOV     [USB_t0], X                     ; store EP0_MODE reg value for later
 0030           .ReWriteMODE:
 0030 5D44          MOV     A, reg[USB_EP0MODE]             ; unblock registers    
 0032 2180          AND     A, 80h                                      ; Check if SETUP bit is set
 0034 B00F          JNZ     USB_EP0_ISR_EXIT                ;          then EXIT from the ISR
 0036               
 0036 511E          MOV     A, [USB_t0]                     ; restore the new MODE
 0038 6044          MOV     reg[USB_EP0MODE], A             ; Update the mode regiter
 003A               
 003A 5D44          MOV     A, reg[USB_EP0MODE]             ; writing check
 003C 210F          AND     A,  0Fh                                     ; clear 7-4 bits
 003E 3A1E          CMP     A, [USB_t0]                     ; if writing was succesful,
 0040 A003          JZ      USB_EP0_ISR_EXIT                ;          then EXIT from the ISR
 0042                                                                    ; if writing was not succesful,
 0042 8FED          JMP      .ReWriteMODE                                 ;           then repeat write operation   
 0044           
 0044           
 0044           USB_EP0_ISR_EXIT:
 0044           
 0044 20            POP X                              ;
 0045 18            POP A                              ; Restore Context
 0046 7E            RETI
 0047           ;-----------------------------------------------------------------------------
 0047           ;  FUNCTION NAME: USB_EP0_Setup
 0047           ;
 0047           ;  DESCRIPTION:   Dispatch a USB SETUP
 0047           ;
 0047           ;-----------------------------------------------------------------------------
 0047            USB_EP0_Setup:
 0047           _USB_EP0_Setup:
 0047           ; Check the byte count and validity.  All SETUP are 8 bytes and 0 toggle
 0047 5D44          MOV     A, reg[USB_EP0MODE]    ; unlock registers
 0049 6044          MOV     reg[USB_EP0MODE], A ; clear setup bit 
 004B 5D44          MOV     A, reg[USB_EP0MODE]    ; (re)read register
 004D 2180          AND     A, 80h                              ; Check if SETUP bit is set
 004F BFF4          JNZ     USB_EP0_ISR_EXIT       ; if SETUP bit set -> exit without modifying the mode    
 0051           
 0051 08            PUSH    A                          ; Save the mode register
 0052 5002          MOV     A, USB_XFER_PREMATURE      ; Return a Premature Completion?
 0054 91DE          CALL    USB_UpdateStatusBlock
 0056 18            POP     A                          ; Restore the mode register
 0057 5D41          MOV    A, REG[USB_EP0CNT]                ; Get the count reg
 0059 394A          CMP    A, (USB_CNT_VALID | 0x0A)
 005B A003          JZ      .dispatch
 005D           
 005D 8246          JMP    USB_Not_Supported_Local_Drv
 005F           ;-----------------------------------------------------------------------------
 005F           ; Jump here to dispatch the request
 005F           ; The SETUP request is encoded in [bmRequestType]. Among the 8 bits in [bmRequestType], only bits
 005F           ; 7,6,5,1,0 determine what the request is. Bits [2:4] are default to zero. The below code
 005F           ; re-organizes [bmRequestType] to the following format:
 005F           ; ( Zero, Zero, Bit7, Bit6, Bit5, Bit1, Bit0, Zero ), and depending on the value of this
 005F           ; "re-organization", the firmware will jump to an appropriate table to handle the request.
 005F           ;-----------------------------------------------------------------------------
 005F           .dispatch:
 005F 5D50          MOV     A, REG[USB_EP0DATA+bmRequestType]   ; Get bmRequestType
 0061 21E3          AND     A, E3h                           ; clear bits 4-3-2, these unused for our purposes
 0063 08            PUSH    A                                ; store value on the stack
 0064 67            ASR     A                                ; move bits 7-6-5 into 4-3-2's place
 0065 67            ASR     A                                ; "asr" instruction shift all bits one place to the right.
 0066 67            ASR     A                                ; Bit7 remains the same.
 0067 531C          MOV     [USB_t2], A                      ; store shifted value
 0069 18            POP     A                                ; get original value
 006A 2A1C          OR      A, [USB_t2]                      ; or the two to get the 5-bit field
 006C 211F          AND     A, 1Fh                           ; clear bits 7-6-5 (asr wraps bit7)
 006E                                                        ; Bit0 is loaded with a Zero. This results in multiplying
 006E                                                        ; the accumulator by 2, and the reason to mutiply it by 2
 006E                                                        ; is that each "jmp" instruction in the tables is two bytes long.
 006E           
 006E 7D029B        LJMP USB_bmRequestType_Dispatch
 0071           ;-----------------------------------------------------------------------------
 0071           ;  FUNCTION NAME: USB_EP0_IN
 0071           ;
 0071           ;  DESCRIPTION:   Dispatch a USB IN
 0071           ;
 0071           ;-----------------------------------------------------------------------------
 0071            USB_EP0_IN:
 0071           _USB_EP0_IN:
 0071 5D44          MOV     A, reg[USB_EP0MODE]    ; unlock registers
 0073           ;    MOV     reg[USB_EP0MODE], A ; clear setup bit 
 0073           ;    MOV     A, reg[USB_EP0MODE]    ; (re)read register
 0073           ;    AND     A, 80h                              ; Check if SETUP bit is set
 0073           ;    JNZ     USB_EP0_ISR_EXIT       ; if SETUP bit set -> exit without modifying the mode    
 0073           
 0073 5108          MOV     A, [USB_TransferType]
 0075           USB_ControlInDispatch:
 0075 E001          JACC    USB_ControlInDispatchTable
 0077           USB_ControlInDispatchTable:
 0077 822C          JMP     USB_Not_Supported_Local_Drv  ; USB_TRANS_STATE_IDLE
 0079 8039          JMP     USB_ControlReadDataStage     ; USB_TRANS_STATE_CONTROL_READ
 007B 80AF          JMP     USB_ControlWriteStatusStage  ; USB_TRANS_STATE_CONTROL_WRITE
 007D 80BA          JMP     USB_NoDataControlStatusStage ; USB_TRANS_STATE_NO_DATA_CONTROL
 007F           ;-----------------------------------------------------------------------------
 007F           ;  FUNCTION NAME: USB_EP0_OUT
 007F           ;
 007F           ;  DESCRIPTION:   Dispatch a USB OUT
 007F           ;
 007F           ;-----------------------------------------------------------------------------
 007F            USB_EP0_OUT:
 007F           _USB_EP0_OUT:
 007F 5D44          MOV     A, reg[USB_EP0MODE]    ; unlock registers
 0081           ;    MOV     reg[USB_EP0MODE], A ; clear setup bit 
 0081           ;    MOV     A, reg[USB_EP0MODE]    ; (re)read register
 0081           ;    AND     A, 80h                              ; Check if SETUP bit is set
 0081           ;    JNZ     USB_EP0_ISR_EXIT       ; if SETUP bit set -> exit without modifying the mode    
 0081           
 0081 5108          MOV     A, [USB_TransferType]
 0083 E001          JACC    USB_ControlOutDispatchTable
 0085           USB_ControlOutDispatchTable:
 0085 821E          JMP     USB_Not_Supported_Local_Drv  ; USB_TRANS_STATE_IDLE
 0087 802D          JMP     USB_ControlReadStatusStage   ; USB_TRANS_STATE_CONTROL_READ
 0089 805E          JMP     USB_ControlWriteDataStage    ; USB_TRANS_STATE_CONTROL_WRITE
 008B 80C6          JMP     USB_NoDataControlError       ; USB_TRANS_STATE_NO_DATA_CONTROL
 008D           ;-----------------------------------------------------------------------------
 008D           ;  FUNCTION NAME: USB_InitControlRead
 008D           ;
 008D           ;  DESCRIPTION:   This routine initializes a control read.  It must be JUMPed to,
 008D           ;                 not called.  It assumes a tranfer descriptor has been loaded
 008D           ;                 into the driver USB_CurrentTD data structure.
 008D           ;
 008D           ;-----------------------------------------------------------------------------
 008D            USB_InitControlRead:
 008D 5307          MOV     [USB_LastSize], A          ; Save the packet size?
 008F 91B9          CALL    USB_InitializeStatusBlock
 0091 550802        MOV     [USB_TransferType], USB_TRANS_STATE_CONTROL_READ
 0094           
 0094               ; Check the transfer size against the request size
 0094 5D57          MOV    A, REG[USB_EP0DATA+wLengthHi] ; MSB of wLength
 0096 3A12          CMP    A, [USB_TransferSize]
 0098 B007          JNZ    .L1
 009A           
 009A 5D56          MOV    A, REG[USB_EP0DATA+wLengthLo] ; LSB of wLength
 009C 3A13          CMP    A, [USB_TransferSize+1]
 009E A009          JZ     .L9
 00A0           .L1:
 00A0 D007          JNC    .L9
 00A2           ;
 00A2 5313          MOV    [USB_TransferSize+1], A     ;
 00A4 5D57          MOV    A, REG[USB_EP0DATA+wLengthHi] ;
 00A6 5312          MOV    [USB_TransferSize], A       ;
 00A8           .L9:
 00A8 551800        MOV    [USB_TransferByteCount], 0  ;
 00AB 551900        MOV    [USB_TransferByteCount+1], 0;
 00AE           
 00AE 2E1A01        OR     [USB_EP0DataToggle], 1 ; setup EP0 data toggle
 00B1 80AA          JMP    USB_LoadEndpoint            ;
 00B3           ;-----------------------------------------------------------------------------
 00B3           ;  FUNCTION NAME: USB_ControlReadDataStage
 00B3           ;
 00B3           ;  DESCRIPTION:   This routine processes the data stage of a control read.  It
 00B3           ;                 must be JUMPed to, not called.  It assumes a tranfer descriptor
 00B3           ;                 has been loaded into the driver USB_CurrentTD
 00B3           ;                 data structure.
 00B3           ;
 00B3           ;-----------------------------------------------------------------------------
 00B3            USB_ControlReadDataStage:
 00B3 80A8          JMP     USB_LoadEndpoint
 00B5           
 00B5           ;-----------------------------------------------------------------------------
 00B5           ;  FUNCTION NAME: USB_ControlReadStatusStage
 00B5           ;
 00B5           ;  DESCRIPTION:   This routine processes the status stage of a control read.  It
 00B5           ;                 must be JUMPed to, not called.  It handles short or 0 packet
 00B5           ;                 It assumes a tranfer descriptor has been loaded into the
 00B5           ;                 driver USB_CurrentTD data structure.
 00B5           ;
 00B5           ;-----------------------------------------------------------------------------
 00B5            USB_ControlReadStatusStage:
 00B5 5107          MOV    A, [USB_LastSize]           ; Get the number of bytes from the last transfer
 00B7 0419          ADD    [USB_TransferByteCount + 1], A ; Update the transfer byte count
 00B9 0E1800        ADC    [USB_TransferByteCount], 0  ;
 00BC 5001          MOV    A, USB_XFER_STATUS_ACK      ; Return a Status ACK Completion
 00BE 9174          CALL   USB_UpdateStatusBlock
 00C0 550800        MOV    [USB_TransferType], USB_TRANS_STATE_IDLE
 00C3 5000          MOV    A, 0                        ; Count Register
 00C5 5703          MOV    X, USB_MODE_STALL_IN_OUT
 00C7 8F54          JMP    USB_EP0_UPD_MODE_EXIT
 00C9           ;-----------------------------------------------------------------------------
 00C9           ;  FUNCTION NAME: USB_NoDataStageControlTransfer
 00C9           ;                 USB_InitNoDataStageControlTransfer
 00C9           ;
 00C9           ;  DESCRIPTION:   This routine processes the status stage of a no data control
 00C9           ;                 write.  It must be JUMPed to, not called.
 00C9           ;
 00C9           ;-----------------------------------------------------------------------------
 00C9            USB_NoDataStageControlTransfer:
 00C9            USB_InitNoDataStageControlTransfer:
 00C9 917F          CALL    USB_InitializeStatusBlock
 00CB           
 00CB 550806        MOV    [USB_TransferType], USB_TRANS_STATE_NO_DATA_CONTROL
 00CE           
 00CE 5000          MOV    A, 0                        ; Count Register
 00D0 5706          MOV    X, USB_MODE_STATUS_IN_ONLY
 00D2 8F49          JMP    USB_EP0_UPD_MODE_EXIT
 00D4           ;-----------------------------------------------------------------------------
 00D4           ;  FUNCTION NAME: USB_InitControlWrite
 00D4           ;
 00D4           ;  DESCRIPTION:   This routine initializes control write.  It must be JUMPed
 00D4           ;                 to, not called.  It assumes a tranfer descriptor has been loaded
 00D4           ;                 into the driver USB_CurrentTD data structure.
 00D4           ;
 00D4           ;-----------------------------------------------------------------------------
 00D4            USB_InitControlWrite:
 00D4 5111          MOV     A, [USB_DataSource]        ; Need to make sure the destination is not ROM
 00D6 3900          CMP     A, USB_DS_ROM
 00D8 A1CB          JZ      USB_Not_Supported_Local_Drv
 00DA           
 00DA 916E          CALL    USB_InitializeStatusBlock
 00DC           
 00DC 550804        MOV    [USB_TransferType], USB_TRANS_STATE_CONTROL_WRITE
 00DF           
 00DF 2E1A01        OR     [USB_EP0DataToggle], 1 ; setup EP0 data toggle
 00E2           
 00E2 5000          MOV    A, 0                        ; Count Register
 00E4 570B          MOV    X, USB_MODE_ACK_OUT_STATUS_IN
 00E6 8F35          JMP    USB_EP0_UPD_MODE_EXIT
 00E8           ;-----------------------------------------------------------------------------
 00E8           ;  FUNCTION NAME: USB_ControlWriteDataStage
 00E8           ;
 00E8           ;  DESCRIPTION:   This routine processes the data stage of a control
 00E8           ;                 write.  It must be JUMPed to, not called.  It assumes a
 00E8           ;                 tranfer descriptor has been loaded into the driver
 00E8           ;                 USB_CurrentTD data structure.
 00E8           ;
 00E8           ;-----------------------------------------------------------------------------
 00E8            USB_ControlWriteDataStage:
 00E8 361A01        XOR    [USB_EP0DataToggle], 1      ; Update data toggle
 00EB           
 00EB 5D41          MOV    A,REG[USB_EP0CNT]           ; Get the count
 00ED           
 00ED 210F          AND     A, 0x0F
 00EF 1102          SUB     A, 2                       ; Count include the two byte checksum
 00F1           
 00F1 531C          MOV     [USB_t2], A                ; Assume we have room to receive the whole packet
 00F3           
 00F3 5000          MOV     A, 0
 00F5 3A12          CMP     A, [USB_TransferSize]      ; If the MSB has anything just use the count
 00F7 B007          JNZ     .L1
 00F9           
 00F9 511C          MOV     A, [USB_t2]
 00FB 3A13          CMP     A, [USB_TransferSize+1]    ;
 00FD A006          JZ      .L6
 00FF           .L1:
 00FF C004          JC      .L6
 0101 5F1C13        MOV     [USB_t2], [USB_TransferSize+1]
 0104           
 0104           .L6:
 0104 511C          MOV     A, [USB_t2]
 0106 1413          SUB     [USB_TransferSize+1],A     ; Update the bytes remaining
 0108 1E1200        SBB     [USB_TransferSize], 0      ;
 010B           
 010B 0419          ADD     [USB_TransferByteCount + 1], A ; Update the transfer byte count
 010D 0E1800        ADC     [USB_TransferByteCount], 0 ;
 0110           
 0110 5700          MOV     X,0                        ; Start the index at 0
 0112           
 0112           .RAM_COPY:
 0112 5E50          MOV     A, REG[X+USB_EP0DATA]      ; Get the data
 0114 3F15          MVI     [USB_DataPtr+1], A         ; Store the data, bump the destination
 0116           
 0116 75            INC     X                          ; Bump the destination offset
 0117 5B            MOV     A,X                        ; Are we done?
 0118 3A1C          CMP     A, [USB_t2]
 011A CFF7          JC      .RAM_COPY                  ; Not done
 011C           
 011C 5000          MOV    A, 0                        ; Count Register
 011E 570B          MOV    X, USB_MODE_ACK_OUT_STATUS_IN
 0120 8EFB          JMP    USB_EP0_UPD_MODE_EXIT
 0122           
 0122           ; Jump here on data toggle error
 0122           .error:
 0122 550800        MOV    [USB_TransferType], USB_TRANS_STATE_IDLE  ; This simply aborts the transfer
 0125 5000          MOV    A, 0                        ; Count Register
 0127 5703          MOV    X, USB_MODE_STALL_IN_OUT
 0129 8EF2          JMP    USB_EP0_UPD_MODE_EXIT
 012B           ;-----------------------------------------------------------------------------
 012B           ;  FUNCTION NAME: USB_ControlWriteStatusStage
 012B           ;
 012B           ;  DESCRIPTION:   This routine processes the status stage of a control
 012B           ;                 write.  It must be JUMPed to, not called.  It assumes a
 012B           ;                 tranfer descriptor has been loaded into the driver
 012B           ;                 USB_CurrentTD data structure.
 012B           ;
 012B           ;-----------------------------------------------------------------------------
 012B            USB_ControlWriteStatusStage:
 012B 5001          MOV    A, USB_XFER_STATUS_ACK      ; Return a Status ACK Completion
 012D 9105          CALL   USB_UpdateStatusBlock
 012F 550800        MOV    [USB_TransferType], USB_TRANS_STATE_IDLE  ; The packet is done
 0132 5000          MOV    A, 0                        ; Count Register
 0134 5703          MOV    X, USB_MODE_STALL_IN_OUT
 0136 8EE5          JMP    USB_EP0_UPD_MODE_EXIT
 0138           ;-----------------------------------------------------------------------------
 0138           ;  FUNCTION NAME: USB_NoDataControlStatusStage
 0138           ;
 0138           ;  DESCRIPTION:   This routine processes the status stage of a control
 0138           ;                 write.  It must be JUMPed to, not called.  It assumes a
 0138           ;                 tranfer descriptor has been loaded into the driver
 0138           ;                 USB_CurrentTD data structure.
 0138           ;
 0138           ;                 USB Device Addressing happens here because we can't change
 0138           ;                 the SIE Address before the Status IN is received.
 0138           ;
 0138           ;-----------------------------------------------------------------------------
 0138            USB_NoDataControlStatusStage:
 0138 5001          MOV     A, USB_XFER_STATUS_ACK     ; Return a Status ACK Completion
 013A 90F8          CALL    USB_UpdateStatusBlock
 013C               ; Dispatch to the proper handler
 013C 3C1B01        CMP     [USB_fDataPending], USB_ADDRESS_CHANGE_PENDING
 013F B009          JNZ     .L1
 0141           
 0141               ; USB ADDRESS CHANGE
 0141 5109          MOV     A, [USB_TransferBuffer]    ; Get the pending data
 0143           
 0143 2980          OR      A, USB_ADDR_ENABLE         ; Set the enable bit
 0145 6040          MOV     REG[USB_ADDR], A           ; Update the SIE address
 0147 8001          JMP     .EXIT
 0149           .L1:
 0149           
 0149           .EXIT:
 0149 551B00        MOV     [USB_fDataPending], 0      ; Clear data pending
 014C           
 014C 5000          MOV    A, 0                        ; Count Register
 014E 5706          MOV    X, USB_MODE_STATUS_IN_ONLY  ; Wait for the next SETUP
 0150 8ECB          JMP    USB_EP0_UPD_MODE_EXIT
 0152           ;-----------------------------------------------------------------------------
 0152           ;  FUNCTION NAME: USB_NoDataControlError
 0152           ;
 0152           ;  DESCRIPTION:   This routine handles the condition when we expected a
 0152           ;                 status IN, but receive an OUT
 0152           ;
 0152           ;-----------------------------------------------------------------------------
 0152            USB_NoDataControlError:
 0152 5003          MOV    A, USB_XFER_ERROR           ; Return Transaction Error
 0154 90DE          CALL   USB_UpdateStatusBlock
 0156 5000          MOV    A, 0                        ; Count Register
 0158 5703          MOV    X, USB_MODE_STALL_IN_OUT    ; Set the mode register
 015A 8EC1          JMP    USB_EP0_UPD_MODE_EXIT
 015C           ;-----------------------------------------------------------------------------
 015C           ;  FUNCTION NAME: USB_LoadEndpoint
 015C           ;
 015C           ;  DESCRIPTION:  Load the endpoint buffer with the next data for the control
 015C           ;                transfer.  It assumes a tranfer descriptor has been loaded
 015C           ;                into the driver USB_CurrentTD data structure.
 015C           ;
 015C           ;-----------------------------------------------------------------------------
 015C           USB_LoadEndpoint:
 015C 5107          MOV     A, [USB_LastSize]          ; Get the number of bytes from the last transfer
 015E 0419          ADD     [USB_TransferByteCount + 1], A ; Update the transfer byte count
 0160 0E1800        ADC     [USB_TransferByteCount], 0 ;
 0163 5112          MOV     A,  [USB_TransferSize]     ; Check to see if we have any
 0165 2A13          OR      A,  [USB_TransferSize+1]   ;  more data to send
 0167 B00E          JNZ     .cont                      ; Jump if we have to send more data
 0169           
 0169           ; Flow here if there is no more data to send
 0169 3C0708        CMP     [USB_LastSize], 8          ; Was it a full packet?
 016C A047          JZ      .START_TRANSFER            ; Jump if it was full (need to send a zero length)
 016E           
 016E           ; Flow here if we are entering the status stage
 016E 5000          MOV    A, 0                        ; Count Register
 0170 5307          MOV    [USB_LastSize], A           ; Clear the byte count
 0172 5702          MOV    X, USB_MODE_STATUS_OUT_ONLY ; Only ACK the Status Out
 0174 8EA7          JMP    USB_EP0_UPD_MODE_EXIT
 0176           
 0176           ; Jump here to determine how many bytes should we transfer
 0176           .cont:
 0176 3C1200        CMP     [USB_TransferSize], 0      ; Check the MSB
 0179 B00A          JNZ     .L1
 017B           
 017B 3C1308        CMP     [USB_TransferSize+1], 8    ; Check the LSB
 017E D005          JNC     .L1
 0180           
 0180 5113          MOV     A,[USB_TransferSize+1]     ; Transfer all the remaing data
 0182 8003          JMP     .L3
 0184           
 0184           .L1:
 0184 5008          MOV     A, 8                       ; Just transfer the next 8 bytes
 0186           
 0186           .L3:
 0186           
 0186 1413          SUB     [USB_TransferSize+1],A     ; Update the bytes remaining
 0188 1E1200        SBB     [USB_TransferSize],0
 018B           
 018B 531C          MOV     [USB_t2],A                 ; Save the count
 018D 5700          MOV     X,0
 018F           
 018F 3C1100        CMP     [USB_DataSource],USB_DS_ROM  ; RAM or ROM copy?
 0192 B017          JNZ     .RAM_COPY
 0194           
 0194           ; Copy data from a ROM source
 0194           .ROM_COPY:
 0194 10            PUSH    X                          ; Save the destination offset
 0195 5114          MOV     A,[USB_DataPtr]            ; Get the transfer source MSB
 0197 5815          MOV     X,[USB_DataPtr+1]          ; Set the transfer source LSB
 0199 7615          INC     [USB_DataPtr+1]            ; Increment the data pointer
 019B 0E1400        ADC     [USB_DataPtr], 0           ;   MSB if necessary
 019E           
 019E 28            ROMX                               ; Get the data byte
 019F           
 019F 20            POP     X                          ; Get the destination offset
 01A0 6150          MOV     REG[X + USB_EP0DATA], A    ; Load the data
 01A2 75            INC     X                          ; Bump the destination offset
 01A3 5B            MOV     A,X                        ; Are we done?
 01A4 3A1C          CMP     A, [USB_t2]
 01A6 CFED          JC      .ROM_COPY                  ; Not done
 01A8 800B          JMP     .START_TRANSFER            ; Otherwise go start the transfer
 01AA           
 01AA           ; Copy data from a RAM source
 01AA           .RAM_COPY:
 01AA 3E15          MVI     A, [USB_DataPtr+1]         ; Get the data, bump the source
 01AC           
 01AC 6150          MOV     REG[X +USB_EP0DATA], A     ; Load the data
 01AE 75            INC     X                          ; Bump the destination offset
 01AF 5B            MOV     A,X                        ; Are we done?
 01B0 3A1C          CMP     A, [USB_t2]
 01B2 CFF7          JC      .RAM_COPY                  ; Not done
 01B4           
 01B4           ;; Set up the IN transfer count/mode/etc
 01B4           ;    A contains the byte count
 01B4           .START_TRANSFER:
 01B4 5307          MOV     [USB_LastSize], A          ; Save the packet size
 01B6           
 01B6 5001          MOV     A, 1
 01B8 221A          AND     A, [USB_EP0DataToggle]
 01BA A003          JZ      .BYPASS_T1
 01BC 5080          MOV     A, USB_CNT_TOGGLE          ; Or T1 in the data toggle
 01BE           
 01BE           .BYPASS_T1:
 01BE 2A07          OR      A, [USB_LastSize]
 01C0 361A01        XOR     [USB_EP0DataToggle], 1     ; Update the data toggle for next time
 01C3           
 01C3 570F          MOV    X, USB_MODE_ACK_IN_STATUS_OUT  ; Set the mode register
 01C5 8E56          JMP    USB_EP0_UPD_MODE_EXIT
 01C7           ;-----------------------------------------------------------------------------
 01C7           ;  FUNCTION NAME: USB_GetTableEntry
 01C7           ;
 01C7           ;  DESCRIPTION:   Copies a TD to the USB_CurrentTD data structure.
 01C7           ;
 01C7           ;-----------------------------------------------------------------------------
                EXPORT USB_GetTableEntry
 01C7           USB_GetTableEntry:
 01C7           
 01C7 75            INC     X                          ; Point to the first table entry
 01C8 0900          ADC     A, 0                       ;
 01CA           
 01CA 08            PUSH    A                          ; Save a work register
 01CB 651C          ASL     [USB_t2]                       ; Index * 2
 01CD 651C          ASL     [USB_t2]                       ; Index * 4
 01CF 651C          ASL     [USB_t2]                       ; Index * 4
 01D1 18            POP     A                          ; Restore the work register
 01D2           
 01D2 4B            SWAP    A, X
 01D3 021C          ADD     A, [USB_t2]
 01D5 4B            SWAP    A, X
 01D6 0900          ADC     A, 0                       ; A:X now points to the descriptor table entry we want
 01D8           
 01D8           ; Flow here to load the Transfer Descriptor (TD_ENTRY)
 01D8 551C11        MOV     [USB_t2], USB_CurrentTD    ; Use Temp as MVI pointer
 01DB 9026          CALL     USB_GETBYTE               ; Get the descriptor data source
 01DD 901C          CALL     USB_GETWORD               ; Get the descriptor size
 01DF 901A          CALL     USB_GETWORD               ; Get the descriptor address
 01E1 9018          CALL     USB_GETWORD               ; Get the Status Pointer
 01E3           ; Dispatch to InitControlRead or InitControlWrite based on d2h/h2d in the request
 01E3 5D50          MOV    A, REG[USB_EP0DATA+bmRequestType]; Get bmRequestType
 01E5 2180          AND     A,0x80                          ; Control Read or Write
 01E7 A003          JZ      .control_write
 01E9           
 01E9 8EA3          JMP     USB_InitControlRead
 01EB           
 01EB           .control_write:
 01EB 8EE8          JMP     USB_InitControlWrite
 01ED           
 01ED           ;-----------------------------------------------------------------------------
 01ED           ;  FUNCTION NAME: USB_LOOKUP
 01ED           ;
 01ED           ;  DESCRIPTION:    Returns the address of an entry in a lookup table (LT_ENTRY)
 01ED           ;
 01ED           ;-----------------------------------------------------------------------------
 01ED           ;
 01ED           ;  ARGUMENTS:    A:X Point to the lookup table
 01ED           ;                USB_t2 contain the table index
 01ED           ;
 01ED           ;  RETURNS:      Address of the LT_ENTRY in A:X
 01ED           ;
 01ED           ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 01ED           ;
 01ED           ;  THEORY of OPERATION or PROCEDURE:
 01ED           ;
 01ED           ;-----------------------------------------------------------------------------
                EXPORT USB_LOOKUP
 01ED           USB_LOOKUP:
 01ED 75            INC     X                          ; Point to the first table entry
 01EE 0900          ADC     A, 0                       ;
 01F0           
 01F0 651C          ASL     [USB_t2]                       ; Simply shift (mult by 2)
 01F2 651C          ASL     [USB_t2]                       ;              (mult by 4)
 01F4 4B            SWAP    A, X
 01F5 021C          ADD     A, [USB_t2]                ;
 01F7 4B            SWAP    A, X
 01F8 0900          ADC     A, 0
 01FA 7F            RET
 01FB           ;-----------------------------------------------------------------------------
 01FB           ;  FUNCTION NAME: USB_GETWORD/USB_GETBYTE
 01FB           ;
 01FB           ;  DESCRIPTION:    Get a word value from ROM
 01FB           ;
 01FB           ;-----------------------------------------------------------------------------
 01FB           ;
 01FB           ;  ARGUMENTS:    A:X is the ROM Address
 01FB           ;                USB_t2 is the destination address
 01FB           ;
 01FB           ;  RETURNS:      USB_t1
 01FB           ;
 01FB           ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 01FB           ;                USES USB_t2
 01FB           ;                A:X points to the subsequent locaction ROM location
 01FB           ;  THEORY of OPERATION or PROCEDURE:
 01FB           ;
 01FB           ;-----------------------------------------------------------------------------
                EXPORT USB_GETWORD
 01FB           USB_GETWORD:
 01FB           
 01FB 08            PUSH    A                          ; Don't loose the pointer MSB
 01FC 28            ROMX                               ; Data source flag
 01FD 3F1C          MVI     [USB_t2], A                ; Save the data source
 01FF 18            POP     A                          ; Get the MSB back
 0200 75            INC     X                          ; Point to the next  entry
 0201 0900          ADC     A, 0                       ;
 0203           
                EXPORT USB_GETBYTE
 0203           USB_GETBYTE:
 0203           
 0203 08            PUSH    A                          ; Don't loose the pointer MSB
 0204 28            ROMX                               ; Data source flag
 0205 3F1C          MVI     [USB_t2], A                ; Save the data source
 0207 18            POP     A                          ; Get the MSB back
 0208 75            INC     X                          ; Point to the next  entry
 0209 0900          ADC     A, 0                       ;
 020B 7F            RET
 020C           ;-----------------------------------------------------------------------------
 020C           ;  FUNCTION NAME: USB_GET_DEVICE_TABLE_ENTRY
 020C           ;
 020C           ;  DESCRIPTION:    Get the address of the current DEVICE_TABLE entry
 020C           ;                  Not intended for use by C fucntions
 020C           ;
 020C           ;-----------------------------------------------------------------------------
 020C           ;
 020C           ;  ARGUMENTS:
 020C           ;
 020C           ;  RETURNS:        A:X points the the current DEVICE_TABLE entry
 020C           ;                  Carry flag is set if the current device index is out of range
 020C           ;
 020C           ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 020C           ;
 020C           ;  THEORY of OPERATION or PROCEDURE:
 020C           ;
 020C           ;-----------------------------------------------------------------------------
                EXPORT USB_GET_DEVICE_TABLE_ENTRY
 020C           USB_GET_DEVICE_TABLE_ENTRY:
 020C 5F1C00        MOV     [USB_t2], [USB_bCurrentDevice]  ; Use the UM temp var--Selector
 020F           
 020F 5000          MOV     A,>USB_DEVICE_LOOKUP       ; Get the ROM Address MSB
 0211 5700          MOV     X,<USB_DEVICE_LOOKUP       ; Get the ROM Address LSB
 0213 28            ROMX                               ; First entry is the table size (only a byte)
 0214 3A1C          CMP     A, [USB_t2]                ; Range check
 0216 5000          MOV     A,>USB_DEVICE_LOOKUP       ; Get the ROM Address MSB
 0218 C003          JC      .exit
 021A           ; Flow here if the index is valid
 021A 9FD1          CALL    USB_LOOKUP                 ; Look up the configuration
 021C           ; Jump or flow here on exit
 021C           .exit:
 021C 7F            RET
 021D           ;-----------------------------------------------------------------------------
 021D           ;  FUNCTION NAME: USB_GET_CONFIG_TABLE_ENTRY
 021D           ;
 021D           ;  DESCRIPTION:    Get the address of the current DEVICE_TABLE entry
 021D           ;                  Not intended for use by C fucntions
 021D           ;                  Does not do range checking on
 021D           ;
 021D           ;-----------------------------------------------------------------------------
 021D           ;
 021D           ;  ARGUMENTS:
 021D           ;
 021D           ;  RETURNS:        A:X points the the current CONFIG_TABLE entry
 021D           ;                  Carry flag is set if the current device index is out of range
 021D           ;
 021D           ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 021D           ;
 021D           ;  THEORY of OPERATION or PROCEDURE:
 021D           ;
 021D           ;-----------------------------------------------------------------------------
                EXPORT USB_GET_CONFIG_TABLE_ENTRY
 021D           USB_GET_CONFIG_TABLE_ENTRY:
 021D 9FED          CALL    USB_GET_DEVICE_TABLE_ENTRY ; Get the selected device
 021F 551C1D        MOV     [USB_t2],USB_t1            ; Set the GETWORD destination
 0222 9FD7          CALL    USB_GETWORD                ; Get the pointer to the CONFIG_LOOKUP table
 0224                                                  ; ITempW has the address
 0224 5D52          MOV     A, REG[USB_EP0DATA+wValueLo]  ; Get the configuration number
 0226 531C          MOV     [USB_t2],A                 ; Save it
 0228 511D          MOV     A, [USB_t1]                ; Get the CONFIG_LOOKUP ROM Address MSB
 022A 581E          MOV     X, [USB_t1+1]              ; Get the CONFIG_LOOKUP ROM Address LSB
 022C           
 022C           ; A:X Points to the CONFIG_LOOKUP, so get the current entry
 022C 5F1C01        MOV     [USB_t2], [USB_Configuration] ; Get the configuration number
 022F 7A1C          DEC     [USB_t2]                   ; We don't populate the 0th entry
 0231 9FBA          CALL    USB_LOOKUP                 ; Look up the configuration
 0233 7F            RET
 0234           ;-----------------------------------------------------------------------------
 0234           ;  FUNCTION NAME: USB_UpdateStatusBlock
 0234           ;
 0234           ;  DESCRIPTION:    Update the Completion Status Block for a Request.  The
 0234           ;                  block is updated with the completion code from the
 0234           ;                  argument (A) and the _TransferByteCount.
 0234           ;
 0234           ;                  The StatusBlock Pointer (_StatusBlockPtr) is set to NULL (0)
 0234           ;                  to make sure no other updates are made to the StatusBlock by
 0234           ;                  the USB User Module.
 0234           ;
 0234           ;-----------------------------------------------------------------------------
 0234           ;
 0234           ;  ARGUMENTS:      A contains the Completion Status Code
 0234           ;
 0234           ;  RETURNS:        None
 0234           ;
 0234           ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 0234           ;
 0234           ;  THEORY of OPERATION or PROCEDURE:
 0234           ;
 0234           ;-----------------------------------------------------------------------------
 0234           USB_UpdateStatusBlock:
 0234 5817          MOV     X, [USB_StatusBlockPtr + 1];
 0236 4B            SWAP    A, X                       ; Don't loose the completion code
 0237 3900          CMP     A, 0                       ; NULL?
 0239 A00F          JZ      .done                      ; No update on NULL
 023B           ; Flow here to update the VSR Completion Status Block
 023B 4B            SWAP    A, X                       ; Completion code A, Pointer in X
 023C 5400          MOV     [X + 0], A                 ; Update the completion Code
 023E 5118          MOV     A, [USB_TransferByteCount] ; Actual Byte Count MSB
 0240 5401          MOV     [X + 1], A
 0242 5119          MOV     A, [USB_TransferByteCount + 1] ; Actual Byte Count LSB
 0244 5402          MOV     [X + 2], A
 0246 551700        MOV     [USB_StatusBlockPtr + 1], 0; Clear the Block Pointer
 0249           .done:
 0249 7F            RET                                ; All done
 024A           ;-----------------------------------------------------------------------------
 024A           ;  FUNCTION NAME: USB_InitializeStatusBlock
 024A           ;
 024A           ;  DESCRIPTION:    Initialize the Completion Status Block for a Request.
 024A           ;                  The completion code is set to USB_XFER_IDLE.
 024A           ;
 024A           ;-----------------------------------------------------------------------------
 024A           ;
 024A           ;  ARGUMENTS:      None
 024A           ;
 024A           ;  RETURNS:        None
 024A           ;
 024A           ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 024A           ;
 024A           ;  THEORY of OPERATION or PROCEDURE:
 024A           ;
 024A           ;-----------------------------------------------------------------------------
 024A           USB_InitializeStatusBlock:
 024A 5117          MOV     A, [USB_StatusBlockPtr + 1];
 024C 3900          CMP     A, 0                       ; NULL?
 024E A00B          JZ      .done                      ; No update on NULL
 0250           ; Flow here to initialize the Completion Status Block
 0250 4B            SWAP    A, X                       ; Pointer in X
 0251 560000        MOV     [X + 0], USB_XFER_IDLE     ; Initialize the completion code (0)
 0254 551800        MOV     [USB_TransferByteCount], 0 ; Clear the byte count
 0257 551900        MOV     [USB_TransferByteCount + 1], 0 ;
 025A           .done:
 025A 7F            RET                                ; All done
 025B           ;-----------------------------------------------------------------------------
 025B           ;  FUNCTION NAME: ;  USB 1st Tier Dispactch Jump Table (based on bmRequestType)
 025B           ;
 025B           ;  DESCRIPTION:
 025B           ;
 025B           ;-----------------------------------------------------------------------------
 025B           ;
 025B           ;  ARGUMENTS:
 025B           ;
 025B           ;  RETURNS:
 025B           ;
 025B           ;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
 025B           ;
 025B           ;  THEORY of OPERATION or PROCEDURE:
 025B           ;
 025B           ;-----------------------------------------------------------------------------
 025B           MACRO BMREQUEST_DISPATCH
 025B           IF (USB_CB_@0_@1_@2 & 1)
 025B               jmp     USB_DT_@0_@1_@2_Dispatch
 025B           ELSE
 025B               jmp     USB_Not_Supported_Local_Drv
 025B           ENDIF
 025B           USB_DT_bmRequestType::
                IF (USB_CB_h2d_std_dev & 1)
 025B 8000          jmp     USB_DT_h2d_std_dev_Dispatch
                ELSE
                    jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_h2d_std_ifc & 1)
 025D 8000          jmp     USB_DT_h2d_std_ifc_Dispatch
                ELSE
                    jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_h2d_std_ep & 1)
 025F 8000          jmp     USB_DT_h2d_std_ep_Dispatch
                ELSE
                    jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_h2d_std_oth & 1)
                    jmp     USB_DT_h2d_std_oth_Dispatch
                ELSE
 0261 8042          jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_h2d_cls_dev & 1)
                    jmp     USB_DT_h2d_cls_dev_Dispatch
                ELSE
 0263 8040          jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_h2d_cls_ifc & 1)
                    jmp     USB_DT_h2d_cls_ifc_Dispatch
                ELSE
 0265 803E          jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_h2d_cls_ep & 1)
                    jmp     USB_DT_h2d_cls_ep_Dispatch
                ELSE
 0267 803C          jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_h2d_cls_oth & 1)
                    jmp     USB_DT_h2d_cls_oth_Dispatch
                ELSE
 0269 803A          jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_h2d_vnd_dev & 1)
                    jmp     USB_DT_h2d_vnd_dev_Dispatch
                ELSE
 026B 8038          jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_h2d_vnd_ifc & 1)
                    jmp     USB_DT_h2d_vnd_ifc_Dispatch
                ELSE
 026D 8036          jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_h2d_vnd_ep & 1)
                    jmp     USB_DT_h2d_vnd_ep_Dispatch
                ELSE
 026F 8034          jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_h2d_vnd_oth & 1)
                    jmp     USB_DT_h2d_vnd_oth_Dispatch
                ELSE
 0271 8032          jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_h2d_rsv_dev & 1)
                    jmp     USB_DT_h2d_rsv_dev_Dispatch
                ELSE
 0273 8030          jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_h2d_rsv_ifc & 1)
                    jmp     USB_DT_h2d_rsv_ifc_Dispatch
                ELSE
 0275 802E          jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_h2d_rsv_ep & 1)
                    jmp     USB_DT_h2d_rsv_ep_Dispatch
                ELSE
 0277 802C          jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_h2d_rsv_oth & 1)
                    jmp     USB_DT_h2d_rsv_oth_Dispatch
                ELSE
 0279 802A          jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_d2h_std_dev & 1)
 027B 8000          jmp     USB_DT_d2h_std_dev_Dispatch
                ELSE
                    jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_d2h_std_ifc & 1)
 027D 8000          jmp     USB_DT_d2h_std_ifc_Dispatch
                ELSE
                    jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_d2h_std_ep & 1)
 027F 8000          jmp     USB_DT_d2h_std_ep_Dispatch
                ELSE
                    jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_d2h_std_oth & 1)
                    jmp     USB_DT_d2h_std_oth_Dispatch
                ELSE
 0281 8022          jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_d2h_cls_dev & 1)
                    jmp     USB_DT_d2h_cls_dev_Dispatch
                ELSE
 0283 8020          jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_d2h_cls_ifc & 1)
                    jmp     USB_DT_d2h_cls_ifc_Dispatch
                ELSE
 0285 801E          jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_d2h_cls_ep & 1)
                    jmp     USB_DT_d2h_cls_ep_Dispatch
                ELSE
 0287 801C          jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_d2h_cls_oth & 1)
                    jmp     USB_DT_d2h_cls_oth_Dispatch
                ELSE
 0289 801A          jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_d2h_vnd_dev & 1)
                    jmp     USB_DT_d2h_vnd_dev_Dispatch
                ELSE
 028B 8018          jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_d2h_vnd_ifc & 1)
                    jmp     USB_DT_d2h_vnd_ifc_Dispatch
                ELSE
 028D 8016          jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_d2h_vnd_ep & 1)
                    jmp     USB_DT_d2h_vnd_ep_Dispatch
                ELSE
 028F 8014          jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_d2h_vnd_oth & 1)
                    jmp     USB_DT_d2h_vnd_oth_Dispatch
                ELSE
 0291 8012          jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_d2h_rsv_dev & 1)
                    jmp     USB_DT_d2h_rsv_dev_Dispatch
                ELSE
 0293 8010          jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_d2h_rsv_ifc & 1)
                    jmp     USB_DT_d2h_rsv_ifc_Dispatch
                ELSE
 0295 800E          jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_d2h_rsv_ep & 1)
                    jmp     USB_DT_d2h_rsv_ep_Dispatch
                ELSE
 0297 800C          jmp     USB_Not_Supported_Local_Drv
                ENDIF
                IF (USB_CB_d2h_rsv_oth & 1)
                    jmp     USB_DT_d2h_rsv_oth_Dispatch
                ELSE
 0299 800A          jmp     USB_Not_Supported_Local_Drv
                ENDIF
 029B           USB_DT_End:
 0020           USB_DT_Size: equ (USB_DT_End-USB_DT_bmRequestType) / 2
 029B           USB_bmRequestType_Dispatch::
 029B 3920          CMP   A,USB_DT_Size
 029D D004          JNC   .dispatch_not_supported
 029F 64            ASL   A
 02A0 EFBA          JACC  USB_DT_bmRequestType
 02A2           .dispatch_not_supported:
 02A2 8001          JMP  USB_Not_Supported_Local_Drv    
 02A4           
 02A4           USB_Not_Supported_Local_Drv:
 02A4 7D0000            LJMP     USB_Not_Supported
 02A7           
 02A7           
 02A7           ;-----------------------------------------------
 02A7           ; Add custom application code for routines
 02A7           ;-----------------------------------------------
 02A7           
 02A7              ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
 02A7              ;---------------------------------------------------
 02A7              ; Insert your custom code below this banner
 02A7              ;---------------------------------------------------
 02A7           
 02A7              ;---------------------------------------------------
 02A7              ; Insert your custom code above this banner
 02A7              ;---------------------------------------------------
 02A7              ;@PSoC_UserCode_END@ (Do not change this line.)
 02A7           
 02A7           ; End of File USB_drv.asm
