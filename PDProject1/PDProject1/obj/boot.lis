 0000           ;  Generated by PSoC Designer 5.4.3191
 0000           ;
 0000           ;@Id: boot.tpl#902 @
 0000           ;=============================================================================
 0000           ;  FILENAME:   boot.asm
 0000           ;  Version:    4.09
 0000           ;
 0000           ;  DESCRIPTION:
 0000           ;  M8C Boot Code for CY7C63300 microcontroller family.
 0000           ;  This file also contains the Interrupt Service Routines for enCoRe II GPIO
 0000           ;  interrupts: INT0, INT1, INT2, as well as the GPIO Port interrupts for
 0000           ;  port 0, port 1, port 2, and port 3.
 0000           ;
 0000           ;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
 0000           ;
 0000           ; NOTES:
 0000           ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
 0000           ; the project's root directory to create BOOT.ASM. Any changes made to 
 0000           ; BOOT.ASM will be  overwritten every time the project is generated; therefore
 0000           ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
 0000           ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
 0000           ; are not accidentally modified.
 0000           ;
 0000           ;=============================================================================
 0000           
 0000           CPU_CLOCK:				equ	0h	;CPU Clock value
 0001           CPU_CLOCK_MASK:			equ	1h 	;CPU Clock mask
 0000           CPU_CLOCK_JUST:			equ	0h 	;CPU Clock value justified
 0000           
 0003           CPU_CLOCK_SPEED:		equ	3h	;CPU Clock Speed value
 0007           CPU_CLOCK_SPEED_MASK: 	equ	7h	;CPU Clock Speed mask
 0003           CPU_CLOCK_SPEED_JUST:  	equ	3h	;CPU Clock Speed value justified
 0000           
 0000           TIMER_CLOCK: 			equ	0h	;Timer Clock value
 0003           TIMER_CLOCK_MASK:		equ	3h	;Timer Clock mask
 0000           TIMER_CLOCK_JUST:		equ	0h	;Timer Clock value justified
 0000           
 0000           TIMER_CLOCK_SPEED:		equ	0h	;Timer clock speed value
 000C           TIMER_CLOCK_SPEED_MASK:	equ	ch	;Timer clock speed mask
 0000           TIMER_CLOCK_SPEED_JUST:	equ	0h	;Timer clock speed value justified
 0000           
 0000           CAPT_CLOCK: 			equ	0h	;Capture Clock value
 0030           CAPT_CLOCK_MASK:		equ	30h	;Capture Clock mask
 0000           CAPT_CLOCK_JUST:		equ	0h	;Capture Clock value justified
 0000           
 0002           CAPT_CLOCK_SPEED: 	  	equ	2h	;Capture Clock speed value
 00C0           CAPT_CLOCK_SPEED_MASK:	equ	c0h	;Capture Clock speed mask
 0080           CAPT_CLOCK_SPEED_JUST: 	equ	80h	;Capture Clock speed value justified
 0000           
 0000           CAPT_EDGE: 				equ	0h	;Capture Edge value
 0080           CAPT_EDGE_MASK:			equ	80h	;Capture Edge mask
 0000           CAPT_EDGE_JUST:			equ	0h	;Capture Edge value justified
 0000           
 0000           CAPT_PRESCALE: 		 	equ	0h	;Capture Prescale value
 0070           CAPT_PRESCALE_MASK:		equ	70h	;Capture Prescale mask
 0000           CAPT_PRESCALE_JUST:	 	equ	0h	;Capture Prescale value justified
 0000           
 0000           USB_CLOCK:				equ	0h	;USB Clock source value
 0020           USB_CLOCK_MASK:			equ	20h	;USB Clock source mask
 0000           USB_CLOCK_JUST:			equ	0h	;USB Clock source justified
 0000           
 0000           USB_CLOCK_SPEED:	  	equ	0h	;USB Clock div by 2 value
 0040           USB_CLOCK_SPEED_MASK: 	equ	40h	;USB Clock div by 2 mask
 0000           USB_CLOCK_SPEED_JUST: 	equ	0h	;USB Clock div by 2 justified
 0000           
 0000           CLOCK_OUT:				equ	0h  ;Clock Out value
 0003           CLOCK_OUT_MASK:			equ	3h	;Clock Out mask
 0000           CLOCK_OUT_JUST:			equ	0h 	;Clock Out value justified
 0000           
 0004           LV_DETECT_LEVEL:		equ	4h	;Low V Detect Level value
 0007           LV_DETECT_LEVEL_MASK:	equ	7h	;Low V Detect Level mask
 0004           LV_DETECT_LEVEL_JUST:	equ	4h	;Low V Detect Level value justified
 0000           
 0001           PWR_ON_RESET_LEVEL:   	 	equ	1h	;PowerOn Reset Level value
 0030           PWR_ON_RESET_LEVEL_MASK:	equ	30h	;PowerOn Reset Level mask
 0010           PWR_ON_RESET_LEVEL_JUST:	equ	10h	;PowerOn Reset Level value justified
 0000           
 0000           WATCHDOG_ENABLE: 	   	equ	0h	;Watchdog Enable value
 0010           FLAG_XIO_MASK:  equ 10h
 0008           FLAG_SUPER:     equ 08h
 0004           FLAG_CARRY:     equ 04h
 0002           FLAG_ZERO:      equ 02h
 0001           FLAG_GLOBAL_IE: equ 01h
 0000           
 0000           ;;=============================================================================
 0000           ;;      Register Space, Bank 0
 0000           ;;=============================================================================
 0000           
 0000           ;------------------------------------------------
 0000           ;  Port Registers
 0000           ;------------------------------------------------
 0000           ; Port Data Registers
 0000           P0DATA:       equ 00h          ; Port 0 Data Register                     (RW)
 0001           P1DATA:       equ 01h          ; Port 1 Data Register                     (RW)
 0002           P2DATA:       equ 02h          ; Port 2 Data Register                     (RW)
 0003           P3DATA:       equ 03h          ; Port 3 Data Register                     (RW)
 0004           P4DATA:       equ 04h          ; Port 4 Data Register                     (RW)
 0000           ; PSoC Compatability
 0000           PRT0DR:       equ 00h          ; Port 0 Data Register                     (RW)(PSoC)
 0001           PRT1DR:       equ 01h          ; Port 1 Data Register                     (RW)(PSoC)
 0002           PRT2DR:       equ 02h          ; Port 2 Data Register                     (RW)(PSoC)
 0003           PRT3DR:       equ 03h          ; Port 3 Data Register                     (RW)(PSoC)
 0004           PRT4DR:       equ 04h          ; Port 4 Data Register                     (RW)(PSoC)
 0000           
 0000           ; Port/Pin Configuration Registers
 0005           P00CR:        equ 05h          ; P0.0 Configuration Register              (RW)
 0006           P01CR:        equ 06h          ; P0.1 Configuration Register              (RW)
 0007           P02CR:        equ 07h          ; P0.2 Configuration Register              (RW)
 0008           P03CR:        equ 08h          ; P0.3 Configuration Register              (RW)
 0009           P04CR:        equ 09h          ; P0.4 Configuration Register              (RW)
 000A           P05CR:        equ 0Ah          ; P0.5 Configuration Register              (RW)
 000B           P06CR:        equ 0Bh          ; P0.6 Configuration Register              (RW)
 000C           P07CR:        equ 0Ch          ; P0.7 Configuration Register              (RW)
 000D           P10CR:        equ 0Dh          ; P1.0 Configuration Register              (RW)
 000E           P11CR:        equ 0Eh          ; P1.1 Configuration Register              (RW)
 000F           P12CR:        equ 0Fh          ; P1.2 Configuration Register              (RW)
 0010           P13CR:        equ 10h          ; P1.3 Configuration Register              (RW)
 0011           P14CR:        equ 11h          ; P1.4 Configuration Register              (RW)
 0012           P15CR:        equ 12h          ; P1.5 Configuration Register              (RW)
 0013           P16CR:        equ 13h          ; P1.6 Configuration Register              (RW)
 0014           P17CR:        equ 14h          ; P1.7 Configuration Register              (RW)
 0015           P2CR:         equ 15h          ; P2.0-P2.7 Configuration Register         (RW)
 0016           P3CR:         equ 16h          ; P3.0-P3.7 Configuration Register         (RW)
 0017           P4CR:         equ 17h          ; P4.0-P4.7 Configuration Register         (RW)
 0000           
 0000           ; Timer Registers
 0020           FRTMRL:       equ 20h          ; Free Running Timer Low                   (RW)
 0021           FRTMRH:       equ 21h          ; Free Running Timer High                  (RW)
 0022           TCAP0R:       equ 22h          ; Capture 0 Rising                         (R)             
 0023           TCAP1R:       equ 23h          ; Capture 1 Rising                         (R)             
 0024           TCAP0F:       equ 24h          ; Capture 0 Falling                        (R)             
 0025           TCAP1F:       equ 25h          ; Capture 1 Falling                        (R)             
 0026           PITMRL:       equ 26h          ; Programmable Interval Timer Low          (RW)
 0027           PITMRH:       equ 27h          ; Programmable Interval Timer High         (RW)
 0028           PIRL:         equ 28h          ; Programmable Interval Timer Reload Low   (RW)
 0029           PIRH:         equ 29h          ; Programmable Interval Timer Reload High  (RW)
 002A           TMRCR:        equ 2Ah          ; Timer Configuration Register             (RW)
 002B           TCAPINTE:     equ 2Bh          ; Capture Timer Interrupt Enable           (RW)
 002C           TCAPINTS:     equ 2Ch          ; Capture Timer Interrupt Status           (RW)
 0000           
 0000           ; Clock Configuration Registers
 0030           CPUCLKCR:     equ 30h          ; CPU Clock Configuration Register         (RW)
 0000           CPUCLK_SEL_INT:         equ 00h ; CPU Clock Select Internal Oscillator
 0001           CPUCLK_SEL_EXT:         equ 01h ; CPU Clock Select External Clock
 0000           CPUCLK_USBCLK_SEL_INT:  equ 00h ; USB Clock Select Internal Clock
 0040           CPUCLK_USBCLK_SEL_EXT:  equ 40h ; USB Clock Select External Clock
 0000           CPUCLK_USBCLK_DIV2_DIS: equ 00h ; USB Clock Divide by 2 disable
 0080           CPUCLK_USBCLK_DIV2_ENA: equ 80h ; USB Clock Divide by 2 enable
 0000           
 0031           TMRCLKCR:     equ 31h          ; Timer Clock Configuration Register       (RW)
 0000           TMRCLKCR_ITMRCLK_IOSC:     equ 00h ; MASK: ITMRCLK Source--Internal Oscillator
 0001           TMRCLKCR_ITMRCLK_XOSC:     equ 01h ; MASK: ITMRCLK Source--External Oscillator or CLKIN
 0002           TMRCLKCR_ITMRCLK_LPO:      equ 02h ; MASK: ITMRCLK Source--Low Power Oscillator (32 Khz)
 0003           TMRCLKCR_ITMRCLK_TCAPCLK:  equ 03h ; MASK: ITMRCLK Source--TCAPCLK
 0000           TMRCLKCR_ITMRCLK_DIV_1:    equ 00h ; MASK: ITMRCLK Divider Value 1
 0004           TMRCLKCR_ITMRCLK_DIV_2:    equ 04h ; MASK: ITMRCLK Divider Value 2
 0008           TMRCLKCR_ITMRCLK_DIV_3:    equ 08h ; MASK: ITMRCLK Divider Value 3
 000C           TMRCLKCR_ITMRCLK_DIV_4:    equ 0Ch ; MASK: ITMRCLK Divider Value 4
 0002           TMRCLKCR_ITMRCLK_LPO:      equ 02h ; MASK: ITMRCLK Source--Low Power Oscillator (32 Khz)
 0000           TMRCLKCR_TCAPCLK_IOSC:     equ 00h ; MASK: TCAPCLK Source--Internal Oscillator
 0010           TMRCLKCR_TCAPCLK_XOSC:     equ 10h ; MASK: TCAPCLK Source--External Oscillator or CLKIN
 0020           TMRCLKCR_TCAPCLK_LPO:      equ 20h ; MASK: TCAPCLK Source--Low Power Oscillator (32 Khz)
 0030           TMRCLKCR_TCAPCLK_DISABLED: equ 30h ; MASK: TCAPCLK Source--DISABLED
 0000           TMRCLKCR_TCAPCLK_DIV_2:    equ 00h ; MASK: TCAPCLK Divider Value 2
 0040           TMRCLKCR_TCAPCLK_DIV_4:    equ 40h ; MASK: TCAPCLK Divider Value 4
 0080           TMRCLKCR_TCAPCLK_DIV_6:    equ 80h ; MASK: TCAPCLK Divider Value 6
 00C0           TMRCLKCR_TCAPCLK_DIV_8:    equ 0C0h ; MASK: TCAPCLK Divider Value 8
 0000           
 0032           CLKIOCR:      equ 32h          ; Clock I/O Configuration Register         (RW)
 0000           CLKIOCR_CLKOUT_IOSC:       equ 00h ; MASK: Clock Source--Internal Oscillator
 0001           CLKIOCR_CLKOUT_XOSC:       equ 01h ; MASK: Clock Source--External Oscillator or CLKIN
 0002           CLKIOCR_CLKOUT_LPO:        equ 02h ; MASK: Clock Source--Low Power Oscillator (32 Khz)
 0003           CLKIOCR_CLKOUT_CPUCLK:     equ 03h ; MASK: Clock Source--CPUCLK
 0000           
 0000           ; Oscillator Configuration Registers
 0034           IOSCTR:       equ 34h          ; Internal Oscillator Trim Register        (R)
 0035           XOSCTR:       equ 35h          ; Crystal Oscillator Trim Register         (R)
 0036           LPOSCTR:      equ 36h          ; Low Power Oscillator Trim Register       (RW)
 0000           
 0000           ; SPI Configuration/Data Registers
 003C           SPIDATA:      equ 3Ch          ; SPI Data Register                        (RW)
 003D           SPICR:        equ 3Dh          ; SPI Configuration Register               (RW)
 0000           
 0000           ; USB SIE Configuration/Data Registers
 0040           USBCR:        equ 40h          ; USB Configuration Register               (RW)
 0041           EP0CNT:       equ 41h          ; Endpoint 0 Count Register                (RW)
 0042           EP1CNT:       equ 42h          ; Endpoint 1 Count Register                (RW)
 0043           EP2CNT:       equ 43h          ; Endpoint 2 Count Register                (RW)
 0044           EP0MODE:      equ 44h          ; Endpoint 0 Mode  Register                (RW)
 0045           EP1MODE:      equ 45h          ; Endpoint 1 Mode  Register                (RW)
 0046           EP2MODE:      equ 46h          ; Endpoint 2 Mode  Register                (RW)
 0050           EP0DATA:      equ 50h          ; Endpoint 0 Data  Register (50h-57h)      (RW)
 0058           EP1DATA:      equ 58h          ; Endpoint 1 Data  Register (58h-5Fh)      (RW)
 0060           EP2DATA:      equ 60h          ; Endpoint 2 Data  Register (60h-67h)      (RW)
 0000           
 0000           ; Band-gap/TRIMBUF Configuration Registers
 0070           BGAPTR:       equ 70h          ; Band-gap Trim Register                   (R)
 0071           TRIM0:        equ 71h          ; TRIMBUF Trim Register 0                  (R)
 0072           TRIM1:        equ 72h          ; TRIMBUF Trim Register 1                  (R)
 0000           
 0000           ; VREG Configuration Register
 0073           VREGCR:       equ 73h          ; VREG Configuration Register              (RW)
 0000           
 0000           ; USB Transceiver Configuration Registers
 0074           USBXCR:       equ 74h          ; USB Transceiver Configuration Register   (RW)
 0080           USBXCR_ENABLE:    equ 80h      ; USB Transceiver Enable
 0001           USBXCR_FORCE:     equ 01h      ; USB Transceiver Force
 0000           
 0000           ; Data Pointer Registers--Listed for compatability with other M8C based parts.
 00D0           CPPDR:        equ 0D0h          ; Current Page Pointer Data Register       (RW)
 00D4           DPRDR:        equ 0D4h          ; Data Page Read Register                  (RW)
 00D5           DPWDR:        equ 0D5h          ; Data Page Write Register                 (RW)
 0000           
 0000           ; Watchdog Timer Reset
 00E3           RESWDT:       equ 0E3h          ; Watchdog Timer Reset                     (W)
 00E3           RES_WDT:      equ 0E3h          ; WatchDog Timer Register                  (W) (PSoC)
 0000           
 0000           ;------------------------------------------------
 0000           ;  System and Global Resource Registers
 0000           ;------------------------------------------------
 00DA           INT_CLR0:     equ 0DAh          ; Interrupt Clear Register 0               (RW)
 0000                                          ; Use INT_MSK0 bit field masks
 00DB           INT_CLR1:     equ 0DBh          ; Interrupt Clear Register 1               (RW)
 0000                                          ; Use INT_MSK1 bit field masks
 00DC           INT_CLR2:     equ 0DCh          ; Interrupt Clear Register 2               (RW)
 0000                                          ; Use INT_MSK2 bit field masks
 0000           
 00DE           INT_MSK3:     equ 0DEh          ; Interrupt Mask Register                  (RW)
 0080           INT_MSK3_ENSWINT:          equ 80h ; MASK: enable/disable SW interrupt
 0000           
 00DF           INT_MSK2:     equ 0DFh          ; Interrupt Mask Register                  (RW)
 0040           INT_MSK2_GPIO_PORT4:       equ 40h ; MASK: enable/disable GPIO Port 4 interrupt
 0020           INT_MSK2_GPIO_PORT3:       equ 20h ; MASK: enable/disable GPIO Port 3 interrupt
 0010           INT_MSK2_GPIO_PORT2:       equ 10h ; MASK: enable/disable GPIO Port 2 interrupt
 0008           INT_MSK2_PS2_DATA_LOW:     equ 08h ; MASK: enable/disable PS/2 Data Low
 0004           INT_MSK2_GPIO_INT2:        equ 04h ; MASK: enable/disable GPIO INT2 interrupt
 0002           INT_MSK2_CTR_16_WRAP:      equ 02h ; MASK: enable/disable 16 bit counter wrap
 0001           INT_MSK2_TCAP1:            equ 01h ; MASK: enable/disable Timer/Capture 0 interrupt
 0000           
 00E0           INT_MSK0:     equ 0E0h          ; Interrupt Mask Register                 (RW)
 0080           INT_MSK0_GPIO_PORT1:       equ 80h ; MASK: enable/disable GPIO Port 1 interrupt
 0040           INT_MSK0_SLEEP:            equ 40h ; MASK: enable/disable sleep interrupt
 0020           INT_MSK0_GPIO_INT1:        equ 20h ; MASK: enable/disable GPIO INT1 interrupt
 0010           INT_MSK0_GPIO_PORT0:       equ 10h ; MASK: enable/disable GPIO Port 0 interrupt
 0008           INT_MSK0_SPI_RX:           equ 08h ; MASK: enable/disable SPI Receive interrupt
 0004           INT_MSK0_SPI_TX:           equ 04h ; MASK: enable/disable SPI Transmit interrupt
 0002           INT_MSK0_GPIO_INT0:        equ 02h ; MASK: enable/disable GPIO INT0 interrupt
 0001           INT_MSK0_POR_LVD:          equ 01h ; MASK: enable/disable POR/LVD interrupt
 0000           
 00E1           INT_MSK1:     equ 0E1h          ; Interrupt Mask Register                 (RW)
 0080           INT_MSK1_TCAP0:            equ 80h ; MASK: enable/disable Timer/Capture 0 interrupt
 0040           INT_MSK1_PIT:              equ 40h ; MASK: enable/disable Progrmmable Interval Timer
 0020           INT_MSK1_MS_TIMER:         equ 20h ; MASK: enable/disable One Millisecond Timer interrupt
 0010           INT_MSK1_USB_ACTIVITY:     equ 10h ; MASK: enable/disable USB Bus Activity interrupt
 0008           INT_MSK1_USB_BUS_RESET:    equ 08h ; MASK: enable/disable USB Bus Reset interrupt
 0004           INT_MSK1_USB_EP2:          equ 04h ; MASK: enable/disable USB Endpoint 2 interrupt
 0002           INT_MSK1_USB_EP1:          equ 02h ; MASK: enable/disable USB Endpoint 1 interrupt
 0001           INT_MSK1_USB_EP0:          equ 01h ; MASK: enable/disable USB Endpoint 0 interrupt
 0000           
 00E2           INT_VC:       equ 0E2h          ; Interrupt vector register                (RC)
 0000           
 0000           ;------------------------------------------------------
 0000           ;        Register bank 1.
 0000           ;------------------------------------------------------
 00E0           OSC_CR0:                   equ 0E0h  ; System Oscillator Control Register 0     (RW)
 0020           OSC_CR0_NO_BUZZ:           equ 20h    ; MASK: Bandgap always powered/BUZZ bandgap
 0018           OSC_CR0_SLEEP:             equ 18h    ; MASK: Set Sleep timer freq/period
 0000           OSC_CR0_SLEEP_512Hz:       equ 00h    ;     Set sleep bits for 1.95ms period
 0008           OSC_CR0_SLEEP_64Hz:        equ 08h    ;     Set sleep bits for 15.6ms period
 0010           OSC_CR0_SLEEP_8Hz:         equ 10h    ;     Set sleep bits for 125ms period
 0018           OSC_CR0_SLEEP_1Hz:         equ 18h    ;     Set sleep bits for 1 sec period
 0000           
 0007           OSC_CR0_CPU:               equ 07h    ; MASK: Set CPU Frequency
 0000           OSC_CR0_CPU_3MHz:          equ 00h    ;     set CPU Freq bits for 3MHz Operation
 0001           OSC_CR0_CPU_6MHz:          equ 01h    ;     set CPU Freq bits for 6MHz Operation
 0002           OSC_CR0_CPU_12MHz:         equ 02h    ;     set CPU Freq bits for 12MHz Operation
 0003           OSC_CR0_CPU_24MHz:         equ 03h    ;     set CPU Freq bits for 24MHz Operation
 0004           OSC_CR0_CPU_1d5MHz:        equ 04h    ;     set CPU Freq bits for 1.5MHz Operation
 0005           OSC_CR0_CPU_750kHz:        equ 05h    ;     set CPU Freq bits for 750kHz Operation
 0006           OSC_CR0_CPU_187d5kHz:      equ 06h    ;     set CPU Freq bits for 187.5kHz Operation
 0000           
 0000           ;------------------------------------------------------
 0000           ;  Note: The following registers are mapped into both
 0000           ;        register bank 0 AND register bank 1.
 0000           ;------------------------------------------------------
 00F7           CPU_F:        equ 0F7h          ; CPU Flag Register Access                 (RO)
 0000                                              ; Use FLAG_ masks defined at top of file
 00FF           CPU_SCR:     equ 0FFh          ; CPU Status and Control Register          (#)
 0080           CPU_SCR_GIE_MASK:      equ 80h    ; MASK: Global Interrupt Enable shadow
 0020           CPU_SCR_WDRS_MASK:     equ 20h    ; MASK: Watch Dog Timer Reset
 0010           CPU_SCR_PORS_MASK:     equ 10h    ; MASK: power-on reset bit PORS
 0008           CPU_SCR_SLEEP_MASK:    equ 08h    ; MASK: Enable Sleep
 0001           CPU_SCR_STOP_MASK:     equ 01h    ; MASK: Halt CPU bit
 0000           
 0000           ;;=============================================================================
 0000           ;;      Register Space, Bank 1
 0000           ;;=============================================================================
 0000           
 0000           ;------------------------------------------------
 0000           ;  Clock and System Control Registers
 0000           ;------------------------------------------------
 0000           
 0000           ;;=============================================================================
 0000           ;;      M8C System Macros
 0000           ;;  These macros should be used when their functions are needed.
 0000           ;;=============================================================================
 0000           
 0000           ;----------------------------------------------------
 0000           ;  Swapping Register Banks
 0000           ;----------------------------------------------------
 0000               macro M8C_SetBank0
 0000               and   F, ~FLAG_XIO_MASK
 0000               macro M8C_SetBank1
 0000               or    F, FLAG_XIO_MASK
 0000               macro M8C_EnableGInt
 0000               or    F, FLAG_GLOBAL_IE
 0000               macro M8C_DisableGInt
 0000               and   F, ~FLAG_GLOBAL_IE
 0000               macro M8C_DisableIntMask
 0000               and   reg[@0], ~@1              ; disable specified interrupt enable bit
 0000               macro M8C_EnableIntMask
 0000               or    reg[@0], @1               ; enable specified interrupt enable bit
 0000               macro M8C_ClearIntFlag
 0000               mov   reg[@0], ~@1              ; clear specified interrupt enable bit
 0000               macro M8C_EnableWatchDog
 0000               and   reg[CPU_SCR], ~CPU_SCR_PORS_MASK
 0000               macro M8C_ClearWDT
 0000               mov   reg[RES_WDT], 00h
 0000               macro M8C_ClearWDTAndSleep
 0000               mov   reg[RES_WDT], 38h
 0000               macro M8C_Sleep
 0000               or    reg[CPU_SCR], CPU_SCR_SLEEP_MASK
 0000               ; The next instruction to be executed depends on the state of the
 0000               ; various interrupt enable bits. If some interrupts are enabled
 0000               ; and the global interrupts are disabled, the next instruction will
 0000               ; be the one that follows the invocation of this macro. If global
 0000               ; interrupts are also enabled then the next instruction will be
 0000               ; from the interrupt vector table. If no interrupts are enabled
 0000               ; then the CPU sleeps forever.
 0000               macro M8C_Stop
 0000               ; In general, you probably don't want to do this, but here's how:
 0000               or    reg[CPU_SCR], CPU_SCR_STOP_MASK
 0000               ; Next instruction to be executed is located in the interrupt
 0000               ; vector table entry for Power-On Reset.
 0000               macro M8C_Reset
 0000               ; Restore CPU to the power-on reset state.
 0000               mov A, 0
 0000               SSC
 0000               ; Next non-supervisor instruction will be at interrupt vector 0.
 0000               macro Suspend_CodeCompressor
 0000               or   F, 0
 0000               macro Resume_CodeCompressor
 0000               add  SP, 0
 00F8              bSSC_KEY1:                       equ      0F8h   ; supervisory key
 00F9              bSSC_KEYSP:                      equ      0F9h   ; supervisory stack ptr key
 00FA              bSSC_TABLE_TableId:              equ      0FAh   ; table ID
 0000                    
 003A           OPER_KEY:		                    equ      3Ah   ; operation key
 0000           ;--------------------------------
 0000           ; SSC_Action macro command codes 
 0000           ;--------------------------------
 0001           FLASH_READ:                         equ      1     ; flash read command
 0002           FLASH_WRITE:                        equ      2     ; flash write command
 0003           FLASH_ERASE:                        equ      3     ; flash erase command
 0000           
 0006           TABLE_READ:							equ      6     ; table read command
 0007           FLASH_CHECKSUM:						equ      7	   ; flash checksum calculation command
 0008           CALIBRATE0:                         equ      8     ; Calibrate without checksum
 0009           CALIBRATE1:                         equ      9     ; Calibrate with checksum
 0000           ;--------------------------------
 0000           ; SSC_Action table read addresses
 0000           ;--------------------------------
 00F8           SILICON_ID_1:						equ		 F8h   ; first byte of silicon ID
 00F9           SILICON_ID_0:						equ		 F9h   ; second byte of silicon ID
 00F8           VOLTAGE_TRIM_3V:					equ		 F8h   ; 3.3V internal voltage reference trim value
 00F9           OSCILLATOR_TRIM_3V:					equ		 F9h   ; 3.3V internal main oscillator trim value
 00FC           VOLTAGE_TRIM_5V:					equ		 FCh   ; 5V internal voltage reference trim value
 00FD           OSCILLATOR_TRIM_5V:					equ		 FDh   ; 5V internal main oscillator trim value
 0000           ;-----------------------------------------------------------------------------
 0000           ;  MACRO NAME: SSC_Action
 0000           ;
 0000           ;  DESCRIPTION:
 0000           ;     Performs locally defined supervisory operations.
 0000           ;     Macro Instantiation: SSC_Action bOperation
 0000           ;
 0000           ;     !!! DO NOT CHANGE THIS CODE !!!
 0000           ;        This sequence of opcodes provides a 
 0000           ;        signature for the debugger and ICE.
 0000           ;     !!! DO NOT CHANGE THIS CODE !!!
 0000           ;
 0000           ;  ARGUMENTS:
 0000           ;     BYTE  bOperation   - specified supervisory operation - defined operations
 0000           ;                          are:  FLASH_WRITE, FLASH_ERASE, FLASH_READ, TABLE_READ,
 0000           ;                                FLASH_CHECKSUM, PROTECT_BLOCK
 0000           ;
 0000           ;  RETURNS:
 0000           ;     none.
 0000           ;
 0000           ;  SIDE EFFECTS:
 0000           ;     A and X registers are destroyed
 0000           ;
 0000           ;  PROCEDURE:  
 0000           ;     1) specify a 3 byte stack frame.  Save in [KEYSP]
 0000           ;     2) insert the flash Supervisory key in [KEY1]
 0000           ;     3) store function code in A
 0000           ;     4) call the supervisory code
 0000           ;-----------------------------------------------------------------------------
 0000           macro SSC_Action  
 0000                 mov   X, SP                         ; copy SP into X
 0000                 mov   A, X                          ; mov to A
 0000                 add   A, 3                          ; create 3 byte stack frame
 0000                 mov   [bSSC_KEYSP], A               ; save stack frame for supervisory code
 0000                 mov   [bSSC_KEY1], OPER_KEY                 ; load the supervisory code for supervisory operations
 0000                 mov   A, @0                         ; load A with specific Flash operation
 0000                 SSC                                 ; SSC call the supervisory code
 0000           SYSTEM_STACK_PAGE: equ 0   
 0000           SYSTEM_STACK_BASE_ADDR: equ 0h   
 0000           SYSTEM_LARGE_MEMORY_MODEL: equ 0   
 0001           SYSTEM_SMALL_MEMORY_MODEL: equ 1   
 0001           IMAGECRAFT: equ 1   
 0002           HITECH: equ 2   
 0001           TOOLCHAIN: equ IMAGECRAFT   
 0001           SYSTEM_TOOLS: equ 1   
 0001           SYSTEM_IDXPG_TRACKS_STK_PP: equ 1   
 0000           SYSTEM_IDXPG_TRACKS_IDX_PP: equ 0   
 0000           SYSTEM_MULTIPAGE_STACK: equ 0 
 0000           
 0000           
 0000           ;  ******* Function Class Definitions *******
 0000           ;
 0000           ;  These definitions are used to describe RAM access patterns. They provide
 0000           ;  documentation and they control prologue and epilogue macros that perform
 0000           ;  the necessary housekeeping functions for large memory model devices like
 0000           ;  the CY7C63300.
 0000           
 0001           RAM_USE_CLASS_1:               equ 1   ; PUSH, POP & I/O access
 0002           RAM_USE_CLASS_2:               equ 2   ; Indexed address mode on stack page
 0004           RAM_USE_CLASS_3:               equ 4   ; Indexed address mode to any page
 0008           RAM_USE_CLASS_4:               equ 8   ; Direct/Indirect address mode access
 0000           
 0000           ; ******* Hi Tech Specific *******
 0000           ; Turn on the expansion of all macros by default
                IF (TOOLCHAIN & HITECH)
                OPT EXPAND
                ENDIF
                ;  ******* Page Pointer Manipulation Macros *******
                ;
                ;  Most of the following macros are conditionally compiled so they only
                ;  produce code if the large memory model is selected.
                
                   ;-----------------------------------------------
                   ;  Set Stack Page Macro
                   ;-----------------------------------------------
                   ;
                   ;  DESC: Modify STK_PP in the large or small memory Models.
                   ;
                   ; INPUT: Constant (e.g., SYSTEM_STACK_PAGE) that specifies the RAM page on
                   ;        which stack operations like PUSH and POP store and retrieve their
                   ;        data
                   ;
                   ;  COST: 8 instruction cycles (in LMM only)
                
 0000              macro RAM_SETPAGE_STK( PG_NUMBER )
 0000              IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000                 mov reg[STK_PP], @PG_NUMBER
 0000              ENDIF
 0000              macro RAM_SETPAGE_CUR( PG_NUMBER )
 0000              IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000                 mov reg[CUR_PP], @PG_NUMBER
 0000              ENDIF
 0000              macro RAM_SETPAGE_IDX( PG_NUMBER )
 0000              IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000                 mov reg[IDX_PP], @PG_NUMBER
 0000              ENDIF
 0000              macro RAM_SETPAGE_MVR( PG_NUMBER )
 0000              IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000                 mov reg[MVR_PP], @PG_NUMBER
 0000              ENDIF
 0000              macro RAM_SETPAGE_MVW( PG_NUMBER )
 0000              IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000                 mov reg[MVW_PP], @PG_NUMBER
 0000              ENDIF
 0000              macro RAM_SETPAGE_IDX2STK
 0000              IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000                 IF ( SYSTEM_MULTIPAGE_STACK )
 0000                    mov   A, reg[STK_PP]
 0000                    mov   reg[IDX_PP], A
 0000                 ELSE
 0000                    RAM_SETPAGE_IDX SYSTEM_STACK_PAGE
 0000                 ENDIF
 0000              ENDIF
 0000              macro RAM_CHANGE_PAGE_MODE( MODE )
 0000              IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000                 and   F, ~FLAG_PGMODE_MASK        ; NOTE: transition thru 00b state
 0000                 or    F,  FLAG_PGMODE_MASK & @MODE
 0000              ENDIF
 0000              macro RAM_SET_NATIVE_PAGING
 0000              IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000              IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
 0000                 or    F,  FLAG_PGMODE_11b            ; LMM w/ IndexPage<==>StackPage
 0000              ENDIF ;  PGMODE LOCKED
 0000              IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
 0000                 or    F,  FLAG_PGMODE_10b            ; LMM with independent IndexPage
 0000              ENDIF ; PGMODE FREE
 0000              ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
 0000              macro RAM_RESTORE_NATIVE_PAGING
 0000              IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000              IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
 0000                 RAM_CHANGE_PAGE_MODE FLAG_PGMODE_11b ; LMM w/ IndexPage<==>StackPage
 0000              ENDIF ;  PGMODE LOCKED
 0000              IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
 0000                 RAM_CHANGE_PAGE_MODE FLAG_PGMODE_10b ; LMM with independent IndexPage
 0000              ENDIF ; PGMODE FREE
 0000              ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
 0000              macro RAM_X_POINTS_TO_STACKPAGE
 0000              IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000                 or   F, FLAG_PGMODE_01b
 0000              ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
 0000              macro RAM_X_POINTS_TO_INDEXPAGE
 0000              IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000                 and  F, ~FLAG_PGMODE_01b
 0000              ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
 0000              macro RAM_PROLOGUE( ACTUAL_CLASS )
 0000           
 0000              IF ( @ACTUAL_CLASS & RAM_USE_CLASS_1 )
 0000              ; Nothing to do
 0000              ENDIF ; RAM_USE_CLASS_1
 0000           
 0000              IF ( @ACTUAL_CLASS & RAM_USE_CLASS_2 )
 0000                 IF ( SYSTEM_IDXPG_TRACKS_IDX_PP )
 0000                    RAM_X_POINTS_TO_STACKPAGE         ; exit native paging mode!
 0000                 ENDIF
 0000              ENDIF ; RAM_USE_CLASS_2
 0000           
 0000              IF ( @ACTUAL_CLASS & RAM_USE_CLASS_3 )
 0000                 IF ( SYSTEM_IDXPG_TRACKS_STK_PP )
 0000                    RAM_X_POINTS_TO_INDEXPAGE         ; exit native paging mode!
 0000                 ENDIF
 0000              ENDIF ; RAM_USE_CLASS_3
 0000           
 0000              IF ( @ACTUAL_CLASS & RAM_USE_CLASS_4 )
 0000              ; Nothing to do
 0000              ENDIF ; RAM_USE_CLASS_4
 0000           
 0000              macro RAM_EPILOGUE( ACTUAL_CLASS )
 0000           
 0000              IF ( @ACTUAL_CLASS & RAM_USE_CLASS_1 )
 0000              ; Nothing to do
 0000              ENDIF ; RAM_USE_CLASS_1
 0000           
 0000              IF ( @ACTUAL_CLASS & RAM_USE_CLASS_2 )
 0000                 RAM_RESTORE_NATIVE_PAGING
 0000              ENDIF ; RAM_USE_CLASS_2
 0000           
 0000              IF ( @ACTUAL_CLASS & RAM_USE_CLASS_3 )
 0000                 RAM_RESTORE_NATIVE_PAGING
 0000              ENDIF ; RAM_USE_CLASS_3
 0000           
 0000              IF ( @ACTUAL_CLASS & RAM_USE_CLASS_4 )
 0000              ; Nothing to do
 0000              ENDIF ; RAM_USE_CLASS_4
 0000           
 0000              macro REG_PRESERVE( IOReg )
 0000              mov   A, reg[ @IOReg ]
 0000              push  A
 0000              macro REG_RESTORE( IOReg )
 0000              pop   A
 0000              mov   reg[ @IOReg ], A
 0000              macro ISR_PRESERVE_PAGE_POINTERS
 0000              IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000                 REG_PRESERVE CUR_PP
 0000                 REG_PRESERVE IDX_PP
 0000                 REG_PRESERVE MVR_PP
 0000                 REG_PRESERVE MVW_PP
 0000              ENDIF
 0000              macro ISR_RESTORE_PAGE_POINTERS
 0000              IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000                 REG_RESTORE MVW_PP
 0000                 REG_RESTORE MVR_PP
 0000                 REG_RESTORE IDX_PP
 0000                 REG_RESTORE CUR_PP
 0000              ENDIF
 0000           macro PRESERVE_CPU_CONTEXT
 0000           IF ( TOOLCHAIN & IMAGECRAFT )
 0000             PUSH A
 0000             IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000               ISR_PRESERVE_PAGE_POINTERS
 0000               RAM_RESTORE_NATIVE_PAGING
 0000               MOV reg[CUR_PP], >__r0 ;Set CUR_PP to same page as virtual registers
 0000             ENDIF
 0000             MOV A, [__r0]
 0000             PUSH A
 0000             MOV A, [__r1]
 0000             PUSH A
 0000             MOV A, [__r2]
 0000             PUSH A
 0000             MOV A, [__r3]
 0000             PUSH A
 0000             MOV A, [__r4]
 0000             PUSH A
 0000             MOV A, [__r5]
 0000             PUSH A
 0000             MOV A, [__r6]
 0000             PUSH A
 0000             MOV A, [__r7]
 0000             PUSH A
 0000             MOV A, [__r8]
 0000             PUSH A
 0000             MOV A, [__r9]
 0000             PUSH A
 0000             MOV A, [__r10]
 0000             PUSH A
 0000             MOV A, [__r11]
 0000             PUSH A
 0000             MOV A, [__rX]
 0000             PUSH A
 0000             MOV A, [__rY]
 0000             PUSH A
 0000             MOV A, [__rZ]
 0000             PUSH A
 0000             IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000               MOV REG[CUR_PP], 0
 0000             ENDIF
 0000           ENDIF
 0000           macro RESTORE_CPU_CONTEXT
 0000           IF ( TOOLCHAIN & IMAGECRAFT )
 0000             IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000               RAM_RESTORE_NATIVE_PAGING
 0000               MOV reg[CUR_PP], >__r0 ;Set CUR_PP to same page as virtual registers
 0000             ENDIF
 0000             POP A
 0000             MOV [__rZ], A
 0000             POP A
 0000             MOV [__rY], A
 0000             POP A
 0000             MOV [__rX], A
 0000             POP A
 0000             MOV [__r11], A
 0000             POP A
 0000             MOV [__r10], A
 0000             POP A
 0000             MOV [__r9], A
 0000             POP A
 0000             MOV [__r8], A
 0000             POP A
 0000             MOV [__r7], A
 0000             POP A
 0000             MOV [__r6], A
 0000             POP A
 0000             MOV [__r5], A
 0000             POP A
 0000             MOV [__r4], A
 0000             POP A
 0000             MOV [__r3], A
 0000             POP A
 0000             MOV [__r2], A
 0000             POP A
 0000             MOV [__r1], A
 0000             POP A
 0000             MOV [__r0], A
 0000             IF ( SYSTEM_LARGE_MEMORY_MODEL )
 0000               ISR_RESTORE_PAGE_POINTERS
 0000               AND F, FLAG_PGMODE_0
 0000             ENDIF
 0000             POP A
 0000           ENDIF
 0001           C_LANGUAGE_SUPPORT: equ 1   ;Set to 0 to optimize for ASM only
 0000           
 0000           ; For historical reasons, by default the boot code uses an lcall instruction
 0000           ; to invoke the user's _main code. If _main executes a return instruction,
 0000           ; boot provides an infinite loop. By changing the following equate from zero
 0000           ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
 0000           ; bytes on the stack which are otherwise required for the return address. If
 0000           ; this option is enabled, _main must not return. (Beginning with the 4.2
 0000           ; release, the C compiler automatically places an infinite loop at the end
 0000           ; of main, rather than a return instruction.)
 0000           ;
 0000           ENABLE_LJMP_TO_MAIN:             equ 0
 0000           
 0000           ;-----------------------------------------------------------------------------
 0000           ; Export Declarations
 0000           ;-----------------------------------------------------------------------------
 0000           
                export __Start
                IF      (TOOLCHAIN & HITECH)
                ELSE
                export __bss_start
                
                export __lit_start
                export __idata_start
                export __data_start
                export __func_lit_start
                export __text_start
                export __usermodules_start
                export __psoc_config_start
                ENDIF
                ;-----------------------------------------------------------------------------
                ; Interrupt Vector Table
                ;-----------------------------------------------------------------------------
                ;
                ; Interrupt vector table entries are 4 bytes long and contain the code that
                ; services the interrupt (or causes it to be serviced).
                ;
                ;-----------------------------------------------------------------------------
                
                    AREA    TOP(ROM,ABS,CON)
                
                    org 0                   ;Reset Interrupt Vector
                IF      (TOOLCHAIN & HITECH)
                ;   jmp   __Start                  ;C compiler fills in this vector
                ELSE
 0000 8067          jmp   __Start                  ;First instruction executed following a Reset
                ENDIF
                    ;@PSoC_BOOT_ISR_UserCode_START@
                    ;---------------------------------------------------
                    ; Insert your custom code below this banner
                    ;---------------------------------------------------
                
                    org 04h                 ;Low Voltage Detect (LVD) Interrupt Vector
 0004 30            halt                    ;Stop execution if power falls too low
 0005           
                    org 08h                 ;INT0 Interrupt Vector
 0008 7D0000        ljmp    INT0_ISR
 000B 7E            reti
 000C           
                    org 0Ch                 ;SPI TX Empty Interrupt Vector
                    // call     void_handler
 000C 7E            reti
 000D           
                    org 10h                 ;SPI RX Full Interrupt Vector
                    // call     void_handler
 0010 7E            reti
 0011           
                    org 14h                 ;GPIO Port 0 Interrupt Vector
 0014 7D0003        ljmp    PORT0_ISR
 0017 7E            reti
 0018               
                    org 18h                 ;GPIO Port 1 Interrupt Vector
 0018 7D0004        ljmp    PORT1_ISR
 001B 7E            reti
 001C               
                    org 1Ch                 ;INT1 Interrupt Vector
 001C 7D0001        ljmp    INT1_ISR
 001F 7E            reti
 0020               
                    org 20h                 ;USB Endpoint 0 Interrupt Vector
 0020 7D0000        ljmp        _USB_EP0_ISR
 0023 7E            reti
 0024           
                    org 24h                 ;USB Endpoint 1 Interrupt Vector
 0024 7D0000        ljmp        _USB_EP1_ISR
 0027 7E            reti
 0028           
                    org 28h                 ;USB Endpoint 2 Interrupt Vector
 0028 7D0000        ljmp        _USB_EP2_ISR
 002B 7E            reti
 002C           
                    org 2Ch                 ;USB Bus Reset Interrupt Vector
 002C 7D0000        ljmp        _USB_RESET_ISR
 002F 7E            reti
 0030           
                    org 30h                 ;USB Bus Activity Interrupt Vector
 0030 7D0000        ljmp        _USB_ACT_ISR
 0033 7E            reti
 0034           
                    org 34h                 ;One Millisecond Interval Timer Interrupt Vector
                    // call     void_handler
 0034 7E            reti
 0035           
                    org 38h                 ;Programmable Interval Timer Interrupt Vector
                    // call     void_handler
 0038 7E            reti
 0039           
                    org 3Ch                 ;Timer Capture 0 Interrupt Vector
                    // call     void_handler
 003C 7E            reti
 003D                   
                    org 40h                 ;Timer Capture 1 Interrupt Vector
                    // call     void_handler
 0040 7E            reti
 0041           
                    org 44h                 ;Free Running Counter Wrap Interrupt Vector
                    // call     void_handler
 0044 7E            reti
 0045           
                    org 48h                 ;INT 2 Interrupt Vector
 0048 7D0002        ljmp    INT2_ISR
 004B 7E            reti
 004C           
                    org 4Ch                 ;PS2 Data Low
                    // call     void_handler
 004C 7E            reti
 004D           
                    org 50h                 ;GPIO Port 2 Interrupt Vector
 0050 7D0005        ljmp    PORT2_ISR
 0053 7E            reti
 0054           
                    org 54h                 ;GPIO Port 3 Interrupt Vector
 0054 7D0006        ljmp    PORT3_ISR
 0057 7E            reti
 0058           
                    org 58h                 ;Reserved
                    // call     void_handler
 0058 7E            reti
 0059           
                    org 5Ch                 ;Reserved
                    // call     void_handler
 005C 7E            reti
 005D           
                    org 60h                 ;Reserved
                    // call     void_handler
 0060 7E            reti
 0061           
                    org 64h                 ;Sleep Timer Interrupt Vector
                    // call     void_handler
 0064 7E            reti
 0065               ;---------------------------------------------------
 0065               ; Insert your custom code above this banner
 0065               ;---------------------------------------------------
 0065               ;@PSoC_BOOT_ISR_UserCode_END@
 0065           
 0065           ;-----------------------------------------------------------------------------
 0065           ;  Start of Execution
 0065           ;  CPU is operating at 3 MHz, change to 12 MHz
 0065           ;  IO Bank is Bank0
 0065           ;-----------------------------------------------------------------------------
 0065           
                IF      (TOOLCHAIN & HITECH)
                        AREA PD_startup(CODE, REL, CON)
                ELSE
                    org 68h
                ENDIF
 0068           __Start:
 0068           
 0068 62E338        mov   reg[RES_WDT], 38h
                IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                    and   reg[CPU_SCR], ~CPU_SCR_PORS_MASK
                ENDIF
                    ;------------------
                    ; Set up the clocks
                    ;------------------
                
                    ; Configure the Clock Out
 006B 433200        OR   REG[CLKIOCR], (CLOCK_OUT_JUST)
 006E           
 006E 55F800        mov  [bSSC_KEY1],0             ; Lockout Flash and Supervisiory operations
 0071 55F900        mov  [bSSC_KEYSP],0      
 0074           
                IF      (TOOLCHAIN & HITECH)
                    ;---------------------------
                    ; Set up the Temporary stack
                    ;---------------------------
                    ; A temporary stack is set up for the SSC instructions.
                    ; The real stack start will be assigned later.
                    ;
                        global          __Lstackps
                        mov     a,low __Lstackps
                        swap    a,sp
                ELSE
                    ;------------------
                    ; Set up the stack
                    ;------------------
 0074 5000          mov   A, __ramareas_end        ; Set top of stack to end of used RAM
 0076 4E            swap  SP, A                    ; This is only temporary if going to LMM
                ENDIF
                
                    ;@PSoC_BOOT_LOADCFG_UserCode_START@
                    ;---------------------------------------------------
                    ; Insert your custom code below this banner
                    ;---------------------------------------------------
                
                    ;---------------------------------------------------
                    ; Insert your custom code above this banner
                    ;---------------------------------------------------
                    ;@PSoC_BOOT_LOADCFG_UserCode_END@ 
                
                    ;-------------------------------------------------------------------------
                    ; All the user selections and UserModule selections are now loaded,
                    ; except CPU frequency (CPU is runing at 12 MHz).  Load the PSoC 
                    ; configuration with a 12 MHz CPU clock to keep config time short.
                    ;-------------------------------------------------------------------------
 0077 7C0000        lcall LoadConfigInit           ; Configure PSoC blocks per Dev Editor
                IF      (TOOLCHAIN & HITECH)
                ; The C compiler will customize the startup code - it's not required here
                
                ELSE
                IF (C_LANGUAGE_SUPPORT)
 007A 9008          call InitCRunTime              ; Initialize for C language
                ENDIF ;(C_LANGUAGE_SUPPORT)
                
                ENDIF
                
                
                
                    ;-------------------------------------------------------------------------
                    ; Global Interrupt are NOT enabled, this should be done in main().
                    ; LVD is set but will not occur unless Global Interrupts are enabled. 
                    ; Global Interrupts should be as soon as possible in main().
                    ;-------------------------------------------------------------------------
 007C 62E200        mov  reg[INT_VC],0              ; Clear any pending interrupts which may
 007F                                               ; have been set during the boot process. 
                IF      (TOOLCHAIN & HITECH)
                        ljmp  startup                  ; Jump to C compiler startup code
                ELSE
                IF ENABLE_LJMP_TO_MAIN
                    ljmp  _main                    ; goto main (no return)
                ELSE
 007F 7C0000        lcall _main                    ; call main
 0082           .Exit:
 0082 8FFF          jmp  .Exit                     ; Wait here after return till power-off or reset
                ENDIF
                ENDIF ; TOOLCHAIN
                
                
                ;-----------------------------------------------------------------------------
                ; C Runtime Environment Initialization
                ; The following code is conditionally assembled.
                ;-----------------------------------------------------------------------------
                IF (TOOLCHAIN & IMAGECRAFT)
                IF (C_LANGUAGE_SUPPORT)
                
 0084           InitCRunTime:
 0084               ;-----------------------------
 0084               ; clear bss segment
 0084               ;-----------------------------
 0084 5000          mov  A,0
 0086 550000        mov  [__r0],<__bss_start
 0089           BssLoop:
 0089 3C0000        cmp  [__r0],<__bss_end
 008C A005          jz   BssDone
 008E 3F00          mvi  [__r0],A
 0090 8FF8          jmp  BssLoop
 0092           BssDone:
 0092               ;----------------------------
 0092               ; copy idata to data segment
 0092               ;----------------------------
 0092 5000          mov  A,>__idata_start
 0094 5700          mov  X,<__idata_start
 0096 550000        mov  [__r0],<__data_start
 0099           IDataLoop:
 0099 3C0000        cmp  [__r0],<__data_end
 009C A00B          jz   IDataDone
 009E 08            push A
 009F 28            romx
 00A0 3F00          mvi  [__r0],A
 00A2 18            pop  A
 00A3 75            inc  X
 00A4 0900          adc  A,0
 00A6 8FF2          jmp  IDataLoop
 00A8           IDataDone:
 00A8 7F            ret
 00A9           
                ENDIF ;(C_LANGUAGE_SUPPORT)
                ENDIF ;(TOOLCHAIN)
                
                IF      (TOOLCHAIN & HITECH)
                ELSE
                
                ;-----------------------------------------------------------------------------
                ; RAM segments for C CONST, static & global items
                ;-----------------------------------------------------------------------------
                    AREA lit
 0000           __lit_start:
 0000           
                    AREA idata
 0000           __idata_start:
 0000           
                    AREA func_lit
 0000           __func_lit_start:
 0000           
                    AREA psoc_config(ROM,REL,CON)
 0000           __psoc_config_start:
 0000           
                    AREA UserModules(ROM,REL,CON)
 0000           __usermodules_start:
 0000           
                    AREA gpio_isr(ROM,REL,CON)
 0000           __gpio_isr_start:
 0000           
 0000           ;---------------------------------------------
 0000           ;         CODE segment for general use
 0000           ;---------------------------------------------
                    AREA text(ROM,REL,CON)
 0000           __text_start:
 0000           
 0000           ;---------------------------------------------
 0000           ;         Begin RAM area usage
 0000           ;---------------------------------------------
                    AREA data              (RAM, REL, CON)   ; initialized RAM
 0000           __data_start:
 0000           
                    AREA virtual_registers (RAM, REL, CON)   ; Temp vars of C compiler
                    AREA InterruptRAM      (RAM, REL, CON)   ; Interrupts, on Page 0
                    AREA bss               (RAM, REL, CON)   ; general use
 0000           __bss_start:
                ENDIF ; TOOLCHAIN
                ;-----------------------------------------------------------------------------
                ; End of the boot code
                ;-----------------------------------------------------------------------------
                
                ;-----------------------------------------------------------------------------
                ; GPIO Interrupt Service Routines
                ;-----------------------------------------------------------------------------
                 AREA gpio_isr(ROM,REL,CON)
                ;-----------------------------------------------------------------------------
                ;  FUNCTION NAME: INT0_ISR
                ;
                ;  DESCRIPTION:   This is the ISR for the the INT0 GPIO interrupt
                ;
                ;-----------------------------------------------------------------------------
 0000           INT0_ISR:
 0000              ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
 0000              ;---------------------------------------------------
 0000              ; Insert your custom code below this banner
 0000              ;---------------------------------------------------
 0000              ;   NOTE: interrupt service routines must preserve
 0000              ;   the values of the A and X CPU registers.
 0000           
 0000              ;---------------------------------------------------
 0000              ; Insert your custom code above this banner
 0000              ;---------------------------------------------------
 0000              ;@PSoC_UserCode_END@ (Do not change this line.)
 0000 7E           RETI
 0001           ;-----------------------------------------------------------------------------
 0001           ;  FUNCTION NAME: INT1_ISR
 0001           ;
 0001           ;  DESCRIPTION:   This is the ISR for the the INT1 GPIO interrupt
 0001           ;
 0001           ;-----------------------------------------------------------------------------
 0001           INT1_ISR:
 0001              ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
 0001              ;---------------------------------------------------
 0001              ; Insert your custom code below this banner
 0001              ;---------------------------------------------------
 0001              ;   NOTE: interrupt service routines must preserve
 0001              ;   the values of the A and X CPU registers.
 0001           
 0001              ;---------------------------------------------------
 0001              ; Insert your custom code above this banner
 0001              ;---------------------------------------------------
 0001              ;@PSoC_UserCode_END@ (Do not change this line.)
 0001 7E           RETI
 0002           ;-----------------------------------------------------------------------------
 0002           ;  FUNCTION NAME: INT2_ISR
 0002           ;
 0002           ;  DESCRIPTION:   This is the ISR for the the INT2 GPIO interrupt
 0002           ;
 0002           ;-----------------------------------------------------------------------------
 0002           INT2_ISR:
 0002              ;@PSoC_UserCode_BODY_3@ (Do not change this line.)
 0002              ;---------------------------------------------------
 0002              ; Insert your custom code below this banner
 0002              ;---------------------------------------------------
 0002              ;   NOTE: interrupt service routines must preserve
 0002              ;   the values of the A and X CPU registers.
 0002           
 0002              ;---------------------------------------------------
 0002              ; Insert your custom code above this banner
 0002              ;---------------------------------------------------
 0002              ;@PSoC_UserCode_END@ (Do not change this line.)
 0002 7E           RETI
 0003           ;-----------------------------------------------------------------------------
 0003           ;  FUNCTION NAME: PORT0_ISR
 0003           ;
 0003           ;  DESCRIPTION:   This is the ISR for the the PORT0 GPIO interrupt
 0003           ;                 Note: Interrupts for GPIO P0.2, P0.3, and P0.4 are
 0003           ;                 not dispatched through this ISR.  Those interrupts
 0003           ;                 are dipatched through INT0, INT1 and INT2 respectively.
 0003           ;
 0003           ;-----------------------------------------------------------------------------
 0003           PORT0_ISR:
 0003              ;@PSoC_UserCode_BODY_4@ (Do not change this line.)
 0003              ;---------------------------------------------------
 0003              ; Insert your custom code below this banner
 0003              ;---------------------------------------------------
 0003              ;   NOTE: interrupt service routines must preserve
 0003              ;   the values of the A and X CPU registers.
 0003           
 0003              ;---------------------------------------------------
 0003              ; Insert your custom code above this banner
 0003              ;---------------------------------------------------
 0003              ;@PSoC_UserCode_END@ (Do not change this line.)
 0003 7E           RETI
 0004           ;-----------------------------------------------------------------------------
 0004           ;  FUNCTION NAME: PORT1_ISR
 0004           ;
 0004           ;  DESCRIPTION:   This is the ISR for the the PORT1 GPIO interrupt
 0004           ;
 0004           ;-----------------------------------------------------------------------------
 0004           PORT1_ISR:
 0004              ;@PSoC_UserCode_BODY_5@ (Do not change this line.)
 0004              ;---------------------------------------------------
 0004              ; Insert your custom code below this banner
 0004              ;---------------------------------------------------
 0004              ;   NOTE: interrupt service routines must preserve
 0004              ;   the values of the A and X CPU registers.
 0004           
 0004              ;---------------------------------------------------
 0004              ; Insert your custom code above this banner
 0004              ;---------------------------------------------------
 0004              ;@PSoC_UserCode_END@ (Do not change this line.)
 0004 7E           RETI
 0005           ;-----------------------------------------------------------------------------
 0005           ;  FUNCTION NAME: PORT2_ISR
 0005           ;
 0005           ;  DESCRIPTION:   This is the ISR for the the PORT2 GPIO interrupt
 0005           ;
 0005           ;-----------------------------------------------------------------------------
 0005           PORT2_ISR:
 0005              ;@PSoC_UserCode_BODY_5@ (Do not change this line.)
 0005              ;---------------------------------------------------
 0005              ; Insert your custom code below this banner
 0005              ;---------------------------------------------------
 0005              ;   NOTE: interrupt service routines must preserve
 0005              ;   the values of the A and X CPU registers.
 0005           
 0005              ;---------------------------------------------------
 0005              ; Insert your custom code above this banner
 0005              ;---------------------------------------------------
 0005              ;@PSoC_UserCode_END@ (Do not change this line.)
 0005 7E           RETI
 0006           ;-----------------------------------------------------------------------------
 0006           ;  FUNCTION NAME: PORT3_ISR
 0006           ;
 0006           ;  DESCRIPTION:   This is the ISR for the the PORT3 GPIO interrupt
 0006           ;
 0006           ;-----------------------------------------------------------------------------
 0006           PORT3_ISR:
 0006              ;@PSoC_UserCode_BODY_6@ (Do not change this line.)
 0006              ;---------------------------------------------------
 0006              ; Insert your custom code below this banner
 0006              ;---------------------------------------------------
 0006              ;   NOTE: interrupt service routines must preserve
 0006              ;   the values of the A and X CPU registers.
 0006           
 0006              ;---------------------------------------------------
 0006              ; Insert your custom code above this banner
 0006              ;---------------------------------------------------
 0006              ;@PSoC_UserCode_END@ (Do not change this line.)
 0006 7E           RETI
 0007           ;-----------------------------------------------------------------------------
 0007           ; End GPIO Interrupt Service Routines
 0007           ;-----------------------------------------------------------------------------
 0007           ;end of file
